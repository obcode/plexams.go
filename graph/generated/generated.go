// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package generated

import (
	"bytes"
	"context"
	"errors"
	"fmt"
	"strconv"
	"sync"
	"sync/atomic"
	"time"

	"github.com/99designs/gqlgen/graphql"
	"github.com/99designs/gqlgen/graphql/introspection"
	"github.com/obcode/plexams.go/graph/model"
	gqlparser "github.com/vektah/gqlparser/v2"
	"github.com/vektah/gqlparser/v2/ast"
)

// region    ************************** generated!.gotpl **************************

// NewExecutableSchema creates an ExecutableSchema from the ResolverRoot interface.
func NewExecutableSchema(cfg Config) graphql.ExecutableSchema {
	return &executableSchema{
		schema:     cfg.Schema,
		resolvers:  cfg.Resolvers,
		directives: cfg.Directives,
		complexity: cfg.Complexity,
	}
}

type Config struct {
	Schema     *ast.Schema
	Resolvers  ResolverRoot
	Directives DirectiveRoot
	Complexity ComplexityRoot
}

type ResolverRoot interface {
	GeneratedExam() GeneratedExamResolver
	Mutation() MutationResolver
	PlanEntry() PlanEntryResolver
	PlannedExam() PlannedExamResolver
	PlannedRoom() PlannedRoomResolver
	Query() QueryResolver
	RoomsForSlot() RoomsForSlotResolver
}

type DirectiveRoot struct {
}

type ComplexityRoot struct {
	AnCode struct {
		Ancode func(childComplexity int) int
	}

	Conflict struct {
		AnCode        func(childComplexity int) int
		NumberOfStuds func(childComplexity int) int
	}

	ConflictPerProgram struct {
		Conflicts func(childComplexity int) int
		Program   func(childComplexity int) int
	}

	Conflicts struct {
		AnCode     func(childComplexity int) int
		Conflicts  func(childComplexity int) int
		MainExamer func(childComplexity int) int
		Module     func(childComplexity int) int
	}

	ConflictsPerProgramAncode struct {
		Ancode    func(childComplexity int) int
		Conflicts func(childComplexity int) int
		Program   func(childComplexity int) int
	}

	ConnectedExam struct {
		Errors            func(childComplexity int) int
		OtherPrimussExams func(childComplexity int) int
		PrimussExams      func(childComplexity int) int
		ZpaExam           func(childComplexity int) int
	}

	Constraints struct {
		Ancode          func(childComplexity int) int
		ExcludeDays     func(childComplexity int) int
		FixedDay        func(childComplexity int) int
		FixedTime       func(childComplexity int) int
		NotPlannedByMe  func(childComplexity int) int
		Online          func(childComplexity int) int
		PossibleDays    func(childComplexity int) int
		RoomConstraints func(childComplexity int) int
		SameSlot        func(childComplexity int) int
	}

	Emails struct {
		AdditionalExamer func(childComplexity int) int
		Fs               func(childComplexity int) int
		Lbas             func(childComplexity int) int
		LbasLastSemester func(childComplexity int) int
		Profs            func(childComplexity int) int
		Sekr             func(childComplexity int) int
	}

	EnhancedPrimussExam struct {
		Conflicts   func(childComplexity int) int
		Exam        func(childComplexity int) int
		Ntas        func(childComplexity int) int
		StudentRegs func(childComplexity int) int
	}

	ExamDay struct {
		Date   func(childComplexity int) int
		Number func(childComplexity int) int
	}

	ExamWithRegsAndRooms struct {
		Exam              func(childComplexity int) int
		NormalRegsMtknr   func(childComplexity int) int
		NtasInAloneRooms  func(childComplexity int) int
		NtasInNormalRooms func(childComplexity int) int
		Rooms             func(childComplexity int) int
	}

	ExamerInPlan struct {
		MainExamer   func(childComplexity int) int
		MainExamerID func(childComplexity int) int
	}

	FK07Program struct {
		Name func(childComplexity int) int
	}

	GeneratedExam struct {
		Ancode           func(childComplexity int) int
		Conflicts        func(childComplexity int) int
		Constraints      func(childComplexity int) int
		MainExamer       func(childComplexity int) int
		MaxDuration      func(childComplexity int) int
		Ntas             func(childComplexity int) int
		PrimussExams     func(childComplexity int) int
		StudentRegsCount func(childComplexity int) int
		ZpaExam          func(childComplexity int) int
	}

	Invigilation struct {
		Duration           func(childComplexity int) int
		InvigilatorID      func(childComplexity int) int
		IsReserve          func(childComplexity int) int
		IsSelfInvigilation func(childComplexity int) int
		RoomName           func(childComplexity int) int
		Slot               func(childComplexity int) int
	}

	InvigilationSlot struct {
		Reserve               func(childComplexity int) int
		RoomsWithInvigilators func(childComplexity int) int
	}

	InvigilationTodos struct {
		InvigilatorCount                    func(childComplexity int) int
		Invigilators                        func(childComplexity int) int
		SumExamRooms                        func(childComplexity int) int
		SumOtherContributions               func(childComplexity int) int
		SumOtherContributionsOvertimeCutted func(childComplexity int) int
		SumReserve                          func(childComplexity int) int
		TodoPerInvigilator                  func(childComplexity int) int
		TodoPerInvigilatorOvertimeCutted    func(childComplexity int) int
	}

	Invigilator struct {
		Requirements func(childComplexity int) int
		Teacher      func(childComplexity int) int
		Todos        func(childComplexity int) int
	}

	InvigilatorRequirements struct {
		AllContributions       func(childComplexity int) int
		ExamDateTimes          func(childComplexity int) int
		ExamDays               func(childComplexity int) int
		ExcludedDates          func(childComplexity int) int
		ExcludedDays           func(childComplexity int) int
		Factor                 func(childComplexity int) int
		FreeSemester           func(childComplexity int) int
		LiveCodingContribution func(childComplexity int) int
		MasterContribution     func(childComplexity int) int
		OnlyInSlots            func(childComplexity int) int
		OralExamsContribution  func(childComplexity int) int
		OvertimeLastSemester   func(childComplexity int) int
		OvertimeThisSemester   func(childComplexity int) int
		PartTime               func(childComplexity int) int
	}

	InvigilatorTodos struct {
		DoingMinutes     func(childComplexity int) int
		Enough           func(childComplexity int) int
		InvigilationDays func(childComplexity int) int
		Invigilations    func(childComplexity int) int
		TotalMinutes     func(childComplexity int) int
	}

	InvigilatorsForDay struct {
		Can  func(childComplexity int) int
		Want func(childComplexity int) int
	}

	MucDaiExam struct {
		Duration       func(childComplexity int) int
		ExamType       func(childComplexity int) int
		IsRepeaterExam func(childComplexity int) int
		MainExamer     func(childComplexity int) int
		MainExamerID   func(childComplexity int) int
		Module         func(childComplexity int) int
		PlannedBy      func(childComplexity int) int
		PrimussAncode  func(childComplexity int) int
		Program        func(childComplexity int) int
	}

	Mutation struct {
		AddConstraints    func(childComplexity int, ancode int, constraints model.ConstraintsInput) int
		AddExamToSlot     func(childComplexity int, day int, time int, ancode int) int
		AddNta            func(childComplexity int, input model.NTAInput) int
		AddZpaExamToPlan  func(childComplexity int, ancode int) int
		Exahm             func(childComplexity int, ancode int) int
		ExcludeDays       func(childComplexity int, ancode int, days []string) int
		Lab               func(childComplexity int, ancode int) int
		NotPlannedByMe    func(childComplexity int, ancode int) int
		Online            func(childComplexity int, ancode int) int
		PlacesWithSockets func(childComplexity int, ancode int) int
		PossibleDays      func(childComplexity int, ancode int, days []string) int
		PrePlanRoom       func(childComplexity int, ancode int, roomName string, reserve bool, mtknr *string) int
		RmConstraints     func(childComplexity int, ancode int) int
		RmExamFromSlot    func(childComplexity int, ancode int) int
		RmZpaExamFromPlan func(childComplexity int, ancode int) int
		SameSlot          func(childComplexity int, ancode int, ancodes []int) int
		Seb               func(childComplexity int, ancode int) int
		ZpaExamsToPlan    func(childComplexity int, input []int) int
	}

	NTA struct {
		Compensation         func(childComplexity int) int
		Deactivated          func(childComplexity int) int
		DeltaDurationPercent func(childComplexity int) int
		Email                func(childComplexity int) int
		Exams                func(childComplexity int) int
		From                 func(childComplexity int) int
		LastSemester         func(childComplexity int) int
		Mtknr                func(childComplexity int) int
		Name                 func(childComplexity int) int
		NeedsHardware        func(childComplexity int) int
		NeedsRoomAlone       func(childComplexity int) int
		Program              func(childComplexity int) int
		Until                func(childComplexity int) int
	}

	NTAExam struct {
		AnCode     func(childComplexity int) int
		MainExamer func(childComplexity int) int
		Module     func(childComplexity int) int
		Semester   func(childComplexity int) int
	}

	NTAWithRegs struct {
		Nta  func(childComplexity int) int
		Regs func(childComplexity int) int
	}

	NTAWithRegsByExam struct {
		Exam func(childComplexity int) int
		Ntas func(childComplexity int) int
	}

	NTAWithRegsByExamAndTeacher struct {
		Exams   func(childComplexity int) int
		Teacher func(childComplexity int) int
	}

	PlanEntry struct {
		Ancode     func(childComplexity int) int
		DayNumber  func(childComplexity int) int
		Locked     func(childComplexity int) int
		SlotNumber func(childComplexity int) int
		Starttime  func(childComplexity int) int
	}

	PlannedExam struct {
		Ancode           func(childComplexity int) int
		Conflicts        func(childComplexity int) int
		Constraints      func(childComplexity int) int
		MainExamer       func(childComplexity int) int
		MaxDuration      func(childComplexity int) int
		Ntas             func(childComplexity int) int
		PlanEntry        func(childComplexity int) int
		PlannedRooms     func(childComplexity int) int
		PrimussExams     func(childComplexity int) int
		StudentRegsCount func(childComplexity int) int
		ZpaExam          func(childComplexity int) int
	}

	PlannedRoom struct {
		Ancode            func(childComplexity int) int
		Day               func(childComplexity int) int
		Duration          func(childComplexity int) int
		Handicap          func(childComplexity int) int
		HandicapRoomAlone func(childComplexity int) int
		NtaMtknr          func(childComplexity int) int
		PrePlanned        func(childComplexity int) int
		Reserve           func(childComplexity int) int
		Room              func(childComplexity int) int
		Slot              func(childComplexity int) int
		StudentsInRoom    func(childComplexity int) int
	}

	PreExam struct {
		Constraints func(childComplexity int) int
		PlanEntry   func(childComplexity int) int
		ZpaExam     func(childComplexity int) int
	}

	PrePlannedRoom struct {
		Ancode   func(childComplexity int) int
		Mtknr    func(childComplexity int) int
		Reserve  func(childComplexity int) int
		RoomName func(childComplexity int) int
	}

	PrimussExam struct {
		AnCode     func(childComplexity int) int
		ExamType   func(childComplexity int) int
		MainExamer func(childComplexity int) int
		Module     func(childComplexity int) int
		Presence   func(childComplexity int) int
		Program    func(childComplexity int) int
	}

	PrimussExamAncode struct {
		Ancode        func(childComplexity int) int
		NumberOfStuds func(childComplexity int) int
		Program       func(childComplexity int) int
	}

	PrimussExamByProgram struct {
		Exams   func(childComplexity int) int
		Program func(childComplexity int) int
	}

	PrimussExamWithCount struct {
		Ancode           func(childComplexity int) int
		ExamType         func(childComplexity int) int
		MainExamer       func(childComplexity int) int
		Module           func(childComplexity int) int
		Presence         func(childComplexity int) int
		Program          func(childComplexity int) int
		StudentRegsCount func(childComplexity int) int
	}

	Query struct {
		AllProgramsInPlan             func(childComplexity int) int
		AllSemesterNames              func(childComplexity int) int
		AllowedSlots                  func(childComplexity int, ancode int) int
		AncodesInPlan                 func(childComplexity int) int
		AwkwardSlots                  func(childComplexity int, ancode int) int
		ConflictingAncodes            func(childComplexity int, ancode int) int
		ConnectedExam                 func(childComplexity int, ancode int) int
		ConnectedExams                func(childComplexity int) int
		ConstraintForAncode           func(childComplexity int, ancode int) int
		ExamerInPlan                  func(childComplexity int) int
		ExamsInSlot                   func(childComplexity int, day int, time int) int
		ExamsWithoutSlot              func(childComplexity int) int
		Fk07programs                  func(childComplexity int) int
		GeneratedExam                 func(childComplexity int, ancode int) int
		GeneratedExams                func(childComplexity int) int
		InvigilatorTodos              func(childComplexity int) int
		Invigilators                  func(childComplexity int) int
		InvigilatorsForDay            func(childComplexity int, day int) int
		InvigilatorsWithReq           func(childComplexity int) int
		MucdaiExams                   func(childComplexity int) int
		Nta                           func(childComplexity int, mtknr string) int
		Ntas                          func(childComplexity int) int
		NtasWithRegs                  func(childComplexity int) int
		PlannedExam                   func(childComplexity int, ancode int) int
		PlannedExams                  func(childComplexity int) int
		PlannedRoomForStudent         func(childComplexity int, ancode int, mtknr string) int
		PlannedRoomNames              func(childComplexity int) int
		PlannedRoomNamesInSlot        func(childComplexity int, day int, time int) int
		PlannedRooms                  func(childComplexity int) int
		PlannedRoomsInSlot            func(childComplexity int, day int, time int) int
		PreExamsInSlot                func(childComplexity int, day int, time int) int
		PrePlannedRooms               func(childComplexity int) int
		PrimussExam                   func(childComplexity int, program string, ancode int) int
		PrimussExams                  func(childComplexity int) int
		PrimussExamsForAnCode         func(childComplexity int, ancode int) int
		Rooms                         func(childComplexity int) int
		RoomsForSlots                 func(childComplexity int) int
		RoomsWithInvigilationsForSlot func(childComplexity int, day int, time int) int
		Semester                      func(childComplexity int) int
		SemesterConfig                func(childComplexity int) int
		StudentByMtknr                func(childComplexity int, mtknr string) int
		StudentRegsForProgram         func(childComplexity int, program string) int
		StudentRegsImportErrors       func(childComplexity int) int
		Students                      func(childComplexity int) int
		StudentsByName                func(childComplexity int, regex string) int
		Teacher                       func(childComplexity int, id int) int
		Teachers                      func(childComplexity int, fromZpa *bool) int
		ZpaAnCodes                    func(childComplexity int) int
		ZpaExam                       func(childComplexity int, ancode int) int
		ZpaExams                      func(childComplexity int, fromZpa *bool) int
		ZpaExamsByType                func(childComplexity int) int
		ZpaExamsNotToPlan             func(childComplexity int) int
		ZpaExamsPlaningStatusUnknown  func(childComplexity int) int
		ZpaExamsToPlan                func(childComplexity int) int
		ZpaExamsToPlanWithConstraints func(childComplexity int) int
	}

	RegWithError struct {
		Error        func(childComplexity int) int
		Registration func(childComplexity int) int
	}

	RegWithProgram struct {
		Program func(childComplexity int) int
		Reg     func(childComplexity int) int
	}

	Room struct {
		Exahm            func(childComplexity int) int
		Handicap         func(childComplexity int) int
		HmebSeats        func(childComplexity int) int
		Lab              func(childComplexity int) int
		Name             func(childComplexity int) int
		NeedsRequest     func(childComplexity int) int
		PlacesWithSocket func(childComplexity int) int
		Seats            func(childComplexity int) int
		Seb              func(childComplexity int) int
		SebSeats         func(childComplexity int) int
	}

	RoomAndExam struct {
		Exam func(childComplexity int) int
		Room func(childComplexity int) int
	}

	RoomConstraints struct {
		AllowedRooms     func(childComplexity int) int
		Comments         func(childComplexity int) int
		Exahm            func(childComplexity int) int
		KdpJiraURL       func(childComplexity int) int
		Lab              func(childComplexity int) int
		MaxStudents      func(childComplexity int) int
		PlacesWithSocket func(childComplexity int) int
		Seb              func(childComplexity int) int
	}

	RoomWithInvigilator struct {
		Invigilator  func(childComplexity int) int
		MaxDuration  func(childComplexity int) int
		Name         func(childComplexity int) int
		RoomAndExams func(childComplexity int) int
		StudentCount func(childComplexity int) int
	}

	RoomsForSlot struct {
		Day   func(childComplexity int) int
		Rooms func(childComplexity int) int
		Slot  func(childComplexity int) int
	}

	Semester struct {
		ID func(childComplexity int) int
	}

	SemesterConfig struct {
		Days           func(childComplexity int) int
		Emails         func(childComplexity int) int
		ForbiddenSlots func(childComplexity int) int
		From           func(childComplexity int) int
		FromFk07       func(childComplexity int) int
		GoDay0         func(childComplexity int) int
		GoSlots        func(childComplexity int) int
		GoSlotsRaw     func(childComplexity int) int
		Slots          func(childComplexity int) int
		Starttimes     func(childComplexity int) int
		Until          func(childComplexity int) int
	}

	Slot struct {
		DayNumber  func(childComplexity int) int
		SlotNumber func(childComplexity int) int
		Starttime  func(childComplexity int) int
	}

	Starttime struct {
		Number func(childComplexity int) int
		Start  func(childComplexity int) int
	}

	Student struct {
		Group           func(childComplexity int) int
		Mtknr           func(childComplexity int) int
		Name            func(childComplexity int) int
		Nta             func(childComplexity int) int
		Program         func(childComplexity int) int
		Regs            func(childComplexity int) int
		RegsWithProgram func(childComplexity int) int
		ZpaStudent      func(childComplexity int) int
	}

	StudentReg struct {
		AnCode   func(childComplexity int) int
		Group    func(childComplexity int) int
		Mtknr    func(childComplexity int) int
		Name     func(childComplexity int) int
		Presence func(childComplexity int) int
		Program  func(childComplexity int) int
	}

	StudentRegsPerAncode struct {
		Ancode     func(childComplexity int) int
		PerProgram func(childComplexity int) int
	}

	StudentRegsPerAncodeAndProgram struct {
		Ancode      func(childComplexity int) int
		Program     func(childComplexity int) int
		StudentRegs func(childComplexity int) int
	}

	StudentRegsPerStudent struct {
		Ancodes func(childComplexity int) int
		Student func(childComplexity int) int
	}

	Teacher struct {
		Email        func(childComplexity int) int
		FK           func(childComplexity int) int
		Fullname     func(childComplexity int) int
		ID           func(childComplexity int) int
		IsActive     func(childComplexity int) int
		IsLBA        func(childComplexity int) int
		IsProf       func(childComplexity int) int
		IsProfHC     func(childComplexity int) int
		IsStaff      func(childComplexity int) int
		LastSemester func(childComplexity int) int
		Shortname    func(childComplexity int) int
	}

	ZPAConflict struct {
		Ancode         func(childComplexity int) int
		NumberOfStuds  func(childComplexity int) int
		PrimussAncodes func(childComplexity int) int
	}

	ZPAExam struct {
		AnCode         func(childComplexity int) int
		Duration       func(childComplexity int) int
		ExamType       func(childComplexity int) int
		ExamTypeFull   func(childComplexity int) int
		Groups         func(childComplexity int) int
		IsRepeaterExam func(childComplexity int) int
		MainExamer     func(childComplexity int) int
		MainExamerID   func(childComplexity int) int
		Module         func(childComplexity int) int
		PrimussAncodes func(childComplexity int) int
		Semester       func(childComplexity int) int
		ZpaID          func(childComplexity int) int
	}

	ZPAExamWithConstraints struct {
		Constraints func(childComplexity int) int
		PlanEntry   func(childComplexity int) int
		ZpaExam     func(childComplexity int) int
	}

	ZPAExamsForType struct {
		Exams func(childComplexity int) int
		Type  func(childComplexity int) int
	}

	ZPAInvigilator struct {
		HasSubmittedRequirements func(childComplexity int) int
		Teacher                  func(childComplexity int) int
	}

	ZPAPrimussAncodes struct {
		Ancode  func(childComplexity int) int
		Program func(childComplexity int) int
	}

	ZPAStudent struct {
		Email     func(childComplexity int) int
		FirstName func(childComplexity int) int
		Gender    func(childComplexity int) int
		Greeting  func(childComplexity int) int
		Group     func(childComplexity int) int
		LastName  func(childComplexity int) int
	}

	ZPAStudentReg struct {
		AnCode  func(childComplexity int) int
		Mtknr   func(childComplexity int) int
		Program func(childComplexity int) int
	}

	ZPAStudentRegError struct {
		AnCode   func(childComplexity int) int
		Exam     func(childComplexity int) int
		Mtknr    func(childComplexity int) int
		Program  func(childComplexity int) int
		Semester func(childComplexity int) int
	}
}

type GeneratedExamResolver interface {
	MainExamer(ctx context.Context, obj *model.GeneratedExam) (*model.Teacher, error)
}
type MutationResolver interface {
	NotPlannedByMe(ctx context.Context, ancode int) (bool, error)
	ExcludeDays(ctx context.Context, ancode int, days []string) (bool, error)
	PossibleDays(ctx context.Context, ancode int, days []string) (bool, error)
	SameSlot(ctx context.Context, ancode int, ancodes []int) (bool, error)
	PlacesWithSockets(ctx context.Context, ancode int) (bool, error)
	Lab(ctx context.Context, ancode int) (bool, error)
	Exahm(ctx context.Context, ancode int) (bool, error)
	Seb(ctx context.Context, ancode int) (bool, error)
	Online(ctx context.Context, ancode int) (bool, error)
	AddConstraints(ctx context.Context, ancode int, constraints model.ConstraintsInput) (*model.Constraints, error)
	RmConstraints(ctx context.Context, ancode int) (bool, error)
	AddNta(ctx context.Context, input model.NTAInput) (*model.NTA, error)
	AddExamToSlot(ctx context.Context, day int, time int, ancode int) (bool, error)
	RmExamFromSlot(ctx context.Context, ancode int) (bool, error)
	PrePlanRoom(ctx context.Context, ancode int, roomName string, reserve bool, mtknr *string) (bool, error)
	ZpaExamsToPlan(ctx context.Context, input []int) ([]*model.ZPAExam, error)
	AddZpaExamToPlan(ctx context.Context, ancode int) (bool, error)
	RmZpaExamFromPlan(ctx context.Context, ancode int) (bool, error)
}
type PlanEntryResolver interface {
	Starttime(ctx context.Context, obj *model.PlanEntry) (*time.Time, error)
}
type PlannedExamResolver interface {
	MainExamer(ctx context.Context, obj *model.PlannedExam) (*model.Teacher, error)
}
type PlannedRoomResolver interface {
	Room(ctx context.Context, obj *model.PlannedRoom) (*model.Room, error)
}
type QueryResolver interface {
	AllSemesterNames(ctx context.Context) ([]*model.Semester, error)
	Semester(ctx context.Context) (*model.Semester, error)
	SemesterConfig(ctx context.Context) (*model.SemesterConfig, error)
	ConstraintForAncode(ctx context.Context, ancode int) (*model.Constraints, error)
	ZpaExamsToPlanWithConstraints(ctx context.Context) ([]*model.ZPAExamWithConstraints, error)
	ConnectedExam(ctx context.Context, ancode int) (*model.ConnectedExam, error)
	ConnectedExams(ctx context.Context) ([]*model.ConnectedExam, error)
	GeneratedExams(ctx context.Context) ([]*model.GeneratedExam, error)
	GeneratedExam(ctx context.Context, ancode int) (*model.GeneratedExam, error)
	PlannedExams(ctx context.Context) ([]*model.PlannedExam, error)
	PlannedExam(ctx context.Context, ancode int) (*model.PlannedExam, error)
	MucdaiExams(ctx context.Context) ([]*model.MucDaiExam, error)
	ConflictingAncodes(ctx context.Context, ancode int) ([]*model.Conflict, error)
	InvigilatorTodos(ctx context.Context) (*model.InvigilationTodos, error)
	InvigilatorsWithReq(ctx context.Context) ([]*model.Invigilator, error)
	RoomsWithInvigilationsForSlot(ctx context.Context, day int, time int) (*model.InvigilationSlot, error)
	InvigilatorsForDay(ctx context.Context, day int) (*model.InvigilatorsForDay, error)
	Ntas(ctx context.Context) ([]*model.NTA, error)
	NtasWithRegs(ctx context.Context) ([]*model.Student, error)
	Nta(ctx context.Context, mtknr string) (*model.NTAWithRegs, error)
	AllProgramsInPlan(ctx context.Context) ([]string, error)
	AncodesInPlan(ctx context.Context) ([]int, error)
	ExamerInPlan(ctx context.Context) ([]*model.ExamerInPlan, error)
	PreExamsInSlot(ctx context.Context, day int, time int) ([]*model.PreExam, error)
	ExamsInSlot(ctx context.Context, day int, time int) ([]*model.PlannedExam, error)
	ExamsWithoutSlot(ctx context.Context) ([]*model.PlannedExam, error)
	AllowedSlots(ctx context.Context, ancode int) ([]*model.Slot, error)
	AwkwardSlots(ctx context.Context, ancode int) ([]*model.Slot, error)
	PrimussExams(ctx context.Context) ([]*model.PrimussExamByProgram, error)
	PrimussExam(ctx context.Context, program string, ancode int) (*model.PrimussExam, error)
	PrimussExamsForAnCode(ctx context.Context, ancode int) ([]*model.PrimussExam, error)
	StudentRegsForProgram(ctx context.Context, program string) ([]*model.StudentReg, error)
	Rooms(ctx context.Context) ([]*model.Room, error)
	PrePlannedRooms(ctx context.Context) ([]*model.PrePlannedRoom, error)
	RoomsForSlots(ctx context.Context) ([]*model.RoomsForSlot, error)
	PlannedRooms(ctx context.Context) ([]*model.PlannedRoom, error)
	PlannedRoomNames(ctx context.Context) ([]string, error)
	PlannedRoomNamesInSlot(ctx context.Context, day int, time int) ([]string, error)
	PlannedRoomsInSlot(ctx context.Context, day int, time int) ([]*model.PlannedRoom, error)
	PlannedRoomForStudent(ctx context.Context, ancode int, mtknr string) (*model.PlannedRoom, error)
	StudentByMtknr(ctx context.Context, mtknr string) (*model.Student, error)
	StudentsByName(ctx context.Context, regex string) ([]*model.Student, error)
	Students(ctx context.Context) ([]*model.Student, error)
	Teacher(ctx context.Context, id int) (*model.Teacher, error)
	Teachers(ctx context.Context, fromZpa *bool) ([]*model.Teacher, error)
	Invigilators(ctx context.Context) ([]*model.ZPAInvigilator, error)
	Fk07programs(ctx context.Context) ([]*model.FK07Program, error)
	ZpaExams(ctx context.Context, fromZpa *bool) ([]*model.ZPAExam, error)
	ZpaExamsByType(ctx context.Context) ([]*model.ZPAExamsForType, error)
	ZpaExamsToPlan(ctx context.Context) ([]*model.ZPAExam, error)
	ZpaExamsNotToPlan(ctx context.Context) ([]*model.ZPAExam, error)
	ZpaExamsPlaningStatusUnknown(ctx context.Context) ([]*model.ZPAExam, error)
	ZpaExam(ctx context.Context, ancode int) (*model.ZPAExam, error)
	ZpaAnCodes(ctx context.Context) ([]*model.AnCode, error)
	StudentRegsImportErrors(ctx context.Context) ([]*model.RegWithError, error)
}
type RoomsForSlotResolver interface {
	Rooms(ctx context.Context, obj *model.RoomsForSlot) ([]*model.Room, error)
}

type executableSchema struct {
	schema     *ast.Schema
	resolvers  ResolverRoot
	directives DirectiveRoot
	complexity ComplexityRoot
}

func (e *executableSchema) Schema() *ast.Schema {
	if e.schema != nil {
		return e.schema
	}
	return parsedSchema
}

func (e *executableSchema) Complexity(ctx context.Context, typeName, field string, childComplexity int, rawArgs map[string]any) (int, bool) {
	ec := executionContext{nil, e, 0, 0, nil}
	_ = ec
	switch typeName + "." + field {

	case "AnCode.ancode":
		if e.complexity.AnCode.Ancode == nil {
			break
		}

		return e.complexity.AnCode.Ancode(childComplexity), true

	case "Conflict.ancode":
		if e.complexity.Conflict.AnCode == nil {
			break
		}

		return e.complexity.Conflict.AnCode(childComplexity), true

	case "Conflict.numberOfStuds":
		if e.complexity.Conflict.NumberOfStuds == nil {
			break
		}

		return e.complexity.Conflict.NumberOfStuds(childComplexity), true

	case "ConflictPerProgram.conflicts":
		if e.complexity.ConflictPerProgram.Conflicts == nil {
			break
		}

		return e.complexity.ConflictPerProgram.Conflicts(childComplexity), true

	case "ConflictPerProgram.program":
		if e.complexity.ConflictPerProgram.Program == nil {
			break
		}

		return e.complexity.ConflictPerProgram.Program(childComplexity), true

	case "Conflicts.ancode":
		if e.complexity.Conflicts.AnCode == nil {
			break
		}

		return e.complexity.Conflicts.AnCode(childComplexity), true

	case "Conflicts.conflicts":
		if e.complexity.Conflicts.Conflicts == nil {
			break
		}

		return e.complexity.Conflicts.Conflicts(childComplexity), true

	case "Conflicts.mainExamer":
		if e.complexity.Conflicts.MainExamer == nil {
			break
		}

		return e.complexity.Conflicts.MainExamer(childComplexity), true

	case "Conflicts.module":
		if e.complexity.Conflicts.Module == nil {
			break
		}

		return e.complexity.Conflicts.Module(childComplexity), true

	case "ConflictsPerProgramAncode.ancode":
		if e.complexity.ConflictsPerProgramAncode.Ancode == nil {
			break
		}

		return e.complexity.ConflictsPerProgramAncode.Ancode(childComplexity), true

	case "ConflictsPerProgramAncode.conflicts":
		if e.complexity.ConflictsPerProgramAncode.Conflicts == nil {
			break
		}

		return e.complexity.ConflictsPerProgramAncode.Conflicts(childComplexity), true

	case "ConflictsPerProgramAncode.program":
		if e.complexity.ConflictsPerProgramAncode.Program == nil {
			break
		}

		return e.complexity.ConflictsPerProgramAncode.Program(childComplexity), true

	case "ConnectedExam.errors":
		if e.complexity.ConnectedExam.Errors == nil {
			break
		}

		return e.complexity.ConnectedExam.Errors(childComplexity), true

	case "ConnectedExam.otherPrimussExams":
		if e.complexity.ConnectedExam.OtherPrimussExams == nil {
			break
		}

		return e.complexity.ConnectedExam.OtherPrimussExams(childComplexity), true

	case "ConnectedExam.primussExams":
		if e.complexity.ConnectedExam.PrimussExams == nil {
			break
		}

		return e.complexity.ConnectedExam.PrimussExams(childComplexity), true

	case "ConnectedExam.zpaExam":
		if e.complexity.ConnectedExam.ZpaExam == nil {
			break
		}

		return e.complexity.ConnectedExam.ZpaExam(childComplexity), true

	case "Constraints.ancode":
		if e.complexity.Constraints.Ancode == nil {
			break
		}

		return e.complexity.Constraints.Ancode(childComplexity), true

	case "Constraints.excludeDays":
		if e.complexity.Constraints.ExcludeDays == nil {
			break
		}

		return e.complexity.Constraints.ExcludeDays(childComplexity), true

	case "Constraints.fixedDay":
		if e.complexity.Constraints.FixedDay == nil {
			break
		}

		return e.complexity.Constraints.FixedDay(childComplexity), true

	case "Constraints.fixedTime":
		if e.complexity.Constraints.FixedTime == nil {
			break
		}

		return e.complexity.Constraints.FixedTime(childComplexity), true

	case "Constraints.notPlannedByMe":
		if e.complexity.Constraints.NotPlannedByMe == nil {
			break
		}

		return e.complexity.Constraints.NotPlannedByMe(childComplexity), true

	case "Constraints.online":
		if e.complexity.Constraints.Online == nil {
			break
		}

		return e.complexity.Constraints.Online(childComplexity), true

	case "Constraints.possibleDays":
		if e.complexity.Constraints.PossibleDays == nil {
			break
		}

		return e.complexity.Constraints.PossibleDays(childComplexity), true

	case "Constraints.roomConstraints":
		if e.complexity.Constraints.RoomConstraints == nil {
			break
		}

		return e.complexity.Constraints.RoomConstraints(childComplexity), true

	case "Constraints.sameSlot":
		if e.complexity.Constraints.SameSlot == nil {
			break
		}

		return e.complexity.Constraints.SameSlot(childComplexity), true

	case "Emails.additionalExamer":
		if e.complexity.Emails.AdditionalExamer == nil {
			break
		}

		return e.complexity.Emails.AdditionalExamer(childComplexity), true

	case "Emails.fs":
		if e.complexity.Emails.Fs == nil {
			break
		}

		return e.complexity.Emails.Fs(childComplexity), true

	case "Emails.lbas":
		if e.complexity.Emails.Lbas == nil {
			break
		}

		return e.complexity.Emails.Lbas(childComplexity), true

	case "Emails.lbasLastSemester":
		if e.complexity.Emails.LbasLastSemester == nil {
			break
		}

		return e.complexity.Emails.LbasLastSemester(childComplexity), true

	case "Emails.profs":
		if e.complexity.Emails.Profs == nil {
			break
		}

		return e.complexity.Emails.Profs(childComplexity), true

	case "Emails.sekr":
		if e.complexity.Emails.Sekr == nil {
			break
		}

		return e.complexity.Emails.Sekr(childComplexity), true

	case "EnhancedPrimussExam.conflicts":
		if e.complexity.EnhancedPrimussExam.Conflicts == nil {
			break
		}

		return e.complexity.EnhancedPrimussExam.Conflicts(childComplexity), true

	case "EnhancedPrimussExam.exam":
		if e.complexity.EnhancedPrimussExam.Exam == nil {
			break
		}

		return e.complexity.EnhancedPrimussExam.Exam(childComplexity), true

	case "EnhancedPrimussExam.ntas":
		if e.complexity.EnhancedPrimussExam.Ntas == nil {
			break
		}

		return e.complexity.EnhancedPrimussExam.Ntas(childComplexity), true

	case "EnhancedPrimussExam.studentRegs":
		if e.complexity.EnhancedPrimussExam.StudentRegs == nil {
			break
		}

		return e.complexity.EnhancedPrimussExam.StudentRegs(childComplexity), true

	case "ExamDay.date":
		if e.complexity.ExamDay.Date == nil {
			break
		}

		return e.complexity.ExamDay.Date(childComplexity), true

	case "ExamDay.number":
		if e.complexity.ExamDay.Number == nil {
			break
		}

		return e.complexity.ExamDay.Number(childComplexity), true

	case "ExamWithRegsAndRooms.exam":
		if e.complexity.ExamWithRegsAndRooms.Exam == nil {
			break
		}

		return e.complexity.ExamWithRegsAndRooms.Exam(childComplexity), true

	case "ExamWithRegsAndRooms.normalRegsMtknr":
		if e.complexity.ExamWithRegsAndRooms.NormalRegsMtknr == nil {
			break
		}

		return e.complexity.ExamWithRegsAndRooms.NormalRegsMtknr(childComplexity), true

	case "ExamWithRegsAndRooms.ntasInAloneRooms":
		if e.complexity.ExamWithRegsAndRooms.NtasInAloneRooms == nil {
			break
		}

		return e.complexity.ExamWithRegsAndRooms.NtasInAloneRooms(childComplexity), true

	case "ExamWithRegsAndRooms.ntasInNormalRooms":
		if e.complexity.ExamWithRegsAndRooms.NtasInNormalRooms == nil {
			break
		}

		return e.complexity.ExamWithRegsAndRooms.NtasInNormalRooms(childComplexity), true

	case "ExamWithRegsAndRooms.rooms":
		if e.complexity.ExamWithRegsAndRooms.Rooms == nil {
			break
		}

		return e.complexity.ExamWithRegsAndRooms.Rooms(childComplexity), true

	case "ExamerInPlan.mainExamer":
		if e.complexity.ExamerInPlan.MainExamer == nil {
			break
		}

		return e.complexity.ExamerInPlan.MainExamer(childComplexity), true

	case "ExamerInPlan.mainExamerID":
		if e.complexity.ExamerInPlan.MainExamerID == nil {
			break
		}

		return e.complexity.ExamerInPlan.MainExamerID(childComplexity), true

	case "FK07Program.name":
		if e.complexity.FK07Program.Name == nil {
			break
		}

		return e.complexity.FK07Program.Name(childComplexity), true

	case "GeneratedExam.ancode":
		if e.complexity.GeneratedExam.Ancode == nil {
			break
		}

		return e.complexity.GeneratedExam.Ancode(childComplexity), true

	case "GeneratedExam.conflicts":
		if e.complexity.GeneratedExam.Conflicts == nil {
			break
		}

		return e.complexity.GeneratedExam.Conflicts(childComplexity), true

	case "GeneratedExam.constraints":
		if e.complexity.GeneratedExam.Constraints == nil {
			break
		}

		return e.complexity.GeneratedExam.Constraints(childComplexity), true

	case "GeneratedExam.mainExamer":
		if e.complexity.GeneratedExam.MainExamer == nil {
			break
		}

		return e.complexity.GeneratedExam.MainExamer(childComplexity), true

	case "GeneratedExam.maxDuration":
		if e.complexity.GeneratedExam.MaxDuration == nil {
			break
		}

		return e.complexity.GeneratedExam.MaxDuration(childComplexity), true

	case "GeneratedExam.ntas":
		if e.complexity.GeneratedExam.Ntas == nil {
			break
		}

		return e.complexity.GeneratedExam.Ntas(childComplexity), true

	case "GeneratedExam.primussExams":
		if e.complexity.GeneratedExam.PrimussExams == nil {
			break
		}

		return e.complexity.GeneratedExam.PrimussExams(childComplexity), true

	case "GeneratedExam.studentRegsCount":
		if e.complexity.GeneratedExam.StudentRegsCount == nil {
			break
		}

		return e.complexity.GeneratedExam.StudentRegsCount(childComplexity), true

	case "GeneratedExam.zpaExam":
		if e.complexity.GeneratedExam.ZpaExam == nil {
			break
		}

		return e.complexity.GeneratedExam.ZpaExam(childComplexity), true

	case "Invigilation.duration":
		if e.complexity.Invigilation.Duration == nil {
			break
		}

		return e.complexity.Invigilation.Duration(childComplexity), true

	case "Invigilation.invigilatorID":
		if e.complexity.Invigilation.InvigilatorID == nil {
			break
		}

		return e.complexity.Invigilation.InvigilatorID(childComplexity), true

	case "Invigilation.isReserve":
		if e.complexity.Invigilation.IsReserve == nil {
			break
		}

		return e.complexity.Invigilation.IsReserve(childComplexity), true

	case "Invigilation.isSelfInvigilation":
		if e.complexity.Invigilation.IsSelfInvigilation == nil {
			break
		}

		return e.complexity.Invigilation.IsSelfInvigilation(childComplexity), true

	case "Invigilation.roomName":
		if e.complexity.Invigilation.RoomName == nil {
			break
		}

		return e.complexity.Invigilation.RoomName(childComplexity), true

	case "Invigilation.slot":
		if e.complexity.Invigilation.Slot == nil {
			break
		}

		return e.complexity.Invigilation.Slot(childComplexity), true

	case "InvigilationSlot.reserve":
		if e.complexity.InvigilationSlot.Reserve == nil {
			break
		}

		return e.complexity.InvigilationSlot.Reserve(childComplexity), true

	case "InvigilationSlot.roomsWithInvigilators":
		if e.complexity.InvigilationSlot.RoomsWithInvigilators == nil {
			break
		}

		return e.complexity.InvigilationSlot.RoomsWithInvigilators(childComplexity), true

	case "InvigilationTodos.invigilatorCount":
		if e.complexity.InvigilationTodos.InvigilatorCount == nil {
			break
		}

		return e.complexity.InvigilationTodos.InvigilatorCount(childComplexity), true

	case "InvigilationTodos.invigilators":
		if e.complexity.InvigilationTodos.Invigilators == nil {
			break
		}

		return e.complexity.InvigilationTodos.Invigilators(childComplexity), true

	case "InvigilationTodos.sumExamRooms":
		if e.complexity.InvigilationTodos.SumExamRooms == nil {
			break
		}

		return e.complexity.InvigilationTodos.SumExamRooms(childComplexity), true

	case "InvigilationTodos.sumOtherContributions":
		if e.complexity.InvigilationTodos.SumOtherContributions == nil {
			break
		}

		return e.complexity.InvigilationTodos.SumOtherContributions(childComplexity), true

	case "InvigilationTodos.sumOtherContributionsOvertimeCutted":
		if e.complexity.InvigilationTodos.SumOtherContributionsOvertimeCutted == nil {
			break
		}

		return e.complexity.InvigilationTodos.SumOtherContributionsOvertimeCutted(childComplexity), true

	case "InvigilationTodos.sumReserve":
		if e.complexity.InvigilationTodos.SumReserve == nil {
			break
		}

		return e.complexity.InvigilationTodos.SumReserve(childComplexity), true

	case "InvigilationTodos.todoPerInvigilator":
		if e.complexity.InvigilationTodos.TodoPerInvigilator == nil {
			break
		}

		return e.complexity.InvigilationTodos.TodoPerInvigilator(childComplexity), true

	case "InvigilationTodos.todoPerInvigilatorOvertimeCutted":
		if e.complexity.InvigilationTodos.TodoPerInvigilatorOvertimeCutted == nil {
			break
		}

		return e.complexity.InvigilationTodos.TodoPerInvigilatorOvertimeCutted(childComplexity), true

	case "Invigilator.requirements":
		if e.complexity.Invigilator.Requirements == nil {
			break
		}

		return e.complexity.Invigilator.Requirements(childComplexity), true

	case "Invigilator.teacher":
		if e.complexity.Invigilator.Teacher == nil {
			break
		}

		return e.complexity.Invigilator.Teacher(childComplexity), true

	case "Invigilator.todos":
		if e.complexity.Invigilator.Todos == nil {
			break
		}

		return e.complexity.Invigilator.Todos(childComplexity), true

	case "InvigilatorRequirements.allContributions":
		if e.complexity.InvigilatorRequirements.AllContributions == nil {
			break
		}

		return e.complexity.InvigilatorRequirements.AllContributions(childComplexity), true

	case "InvigilatorRequirements.examDateTimes":
		if e.complexity.InvigilatorRequirements.ExamDateTimes == nil {
			break
		}

		return e.complexity.InvigilatorRequirements.ExamDateTimes(childComplexity), true

	case "InvigilatorRequirements.examDays":
		if e.complexity.InvigilatorRequirements.ExamDays == nil {
			break
		}

		return e.complexity.InvigilatorRequirements.ExamDays(childComplexity), true

	case "InvigilatorRequirements.excludedDates":
		if e.complexity.InvigilatorRequirements.ExcludedDates == nil {
			break
		}

		return e.complexity.InvigilatorRequirements.ExcludedDates(childComplexity), true

	case "InvigilatorRequirements.excludedDays":
		if e.complexity.InvigilatorRequirements.ExcludedDays == nil {
			break
		}

		return e.complexity.InvigilatorRequirements.ExcludedDays(childComplexity), true

	case "InvigilatorRequirements.factor":
		if e.complexity.InvigilatorRequirements.Factor == nil {
			break
		}

		return e.complexity.InvigilatorRequirements.Factor(childComplexity), true

	case "InvigilatorRequirements.freeSemester":
		if e.complexity.InvigilatorRequirements.FreeSemester == nil {
			break
		}

		return e.complexity.InvigilatorRequirements.FreeSemester(childComplexity), true

	case "InvigilatorRequirements.liveCodingContribution":
		if e.complexity.InvigilatorRequirements.LiveCodingContribution == nil {
			break
		}

		return e.complexity.InvigilatorRequirements.LiveCodingContribution(childComplexity), true

	case "InvigilatorRequirements.masterContribution":
		if e.complexity.InvigilatorRequirements.MasterContribution == nil {
			break
		}

		return e.complexity.InvigilatorRequirements.MasterContribution(childComplexity), true

	case "InvigilatorRequirements.onlyInSlots":
		if e.complexity.InvigilatorRequirements.OnlyInSlots == nil {
			break
		}

		return e.complexity.InvigilatorRequirements.OnlyInSlots(childComplexity), true

	case "InvigilatorRequirements.oralExamsContribution":
		if e.complexity.InvigilatorRequirements.OralExamsContribution == nil {
			break
		}

		return e.complexity.InvigilatorRequirements.OralExamsContribution(childComplexity), true

	case "InvigilatorRequirements.overtimeLastSemester":
		if e.complexity.InvigilatorRequirements.OvertimeLastSemester == nil {
			break
		}

		return e.complexity.InvigilatorRequirements.OvertimeLastSemester(childComplexity), true

	case "InvigilatorRequirements.overtimeThisSemester":
		if e.complexity.InvigilatorRequirements.OvertimeThisSemester == nil {
			break
		}

		return e.complexity.InvigilatorRequirements.OvertimeThisSemester(childComplexity), true

	case "InvigilatorRequirements.partTime":
		if e.complexity.InvigilatorRequirements.PartTime == nil {
			break
		}

		return e.complexity.InvigilatorRequirements.PartTime(childComplexity), true

	case "InvigilatorTodos.doingMinutes":
		if e.complexity.InvigilatorTodos.DoingMinutes == nil {
			break
		}

		return e.complexity.InvigilatorTodos.DoingMinutes(childComplexity), true

	case "InvigilatorTodos.enough":
		if e.complexity.InvigilatorTodos.Enough == nil {
			break
		}

		return e.complexity.InvigilatorTodos.Enough(childComplexity), true

	case "InvigilatorTodos.invigilationDays":
		if e.complexity.InvigilatorTodos.InvigilationDays == nil {
			break
		}

		return e.complexity.InvigilatorTodos.InvigilationDays(childComplexity), true

	case "InvigilatorTodos.invigilations":
		if e.complexity.InvigilatorTodos.Invigilations == nil {
			break
		}

		return e.complexity.InvigilatorTodos.Invigilations(childComplexity), true

	case "InvigilatorTodos.totalMinutes":
		if e.complexity.InvigilatorTodos.TotalMinutes == nil {
			break
		}

		return e.complexity.InvigilatorTodos.TotalMinutes(childComplexity), true

	case "InvigilatorsForDay.can":
		if e.complexity.InvigilatorsForDay.Can == nil {
			break
		}

		return e.complexity.InvigilatorsForDay.Can(childComplexity), true

	case "InvigilatorsForDay.want":
		if e.complexity.InvigilatorsForDay.Want == nil {
			break
		}

		return e.complexity.InvigilatorsForDay.Want(childComplexity), true

	case "MucDaiExam.duration":
		if e.complexity.MucDaiExam.Duration == nil {
			break
		}

		return e.complexity.MucDaiExam.Duration(childComplexity), true

	case "MucDaiExam.examType":
		if e.complexity.MucDaiExam.ExamType == nil {
			break
		}

		return e.complexity.MucDaiExam.ExamType(childComplexity), true

	case "MucDaiExam.isRepeaterExam":
		if e.complexity.MucDaiExam.IsRepeaterExam == nil {
			break
		}

		return e.complexity.MucDaiExam.IsRepeaterExam(childComplexity), true

	case "MucDaiExam.mainExamer":
		if e.complexity.MucDaiExam.MainExamer == nil {
			break
		}

		return e.complexity.MucDaiExam.MainExamer(childComplexity), true

	case "MucDaiExam.mainExamerID":
		if e.complexity.MucDaiExam.MainExamerID == nil {
			break
		}

		return e.complexity.MucDaiExam.MainExamerID(childComplexity), true

	case "MucDaiExam.module":
		if e.complexity.MucDaiExam.Module == nil {
			break
		}

		return e.complexity.MucDaiExam.Module(childComplexity), true

	case "MucDaiExam.plannedBy":
		if e.complexity.MucDaiExam.PlannedBy == nil {
			break
		}

		return e.complexity.MucDaiExam.PlannedBy(childComplexity), true

	case "MucDaiExam.primussAncode":
		if e.complexity.MucDaiExam.PrimussAncode == nil {
			break
		}

		return e.complexity.MucDaiExam.PrimussAncode(childComplexity), true

	case "MucDaiExam.program":
		if e.complexity.MucDaiExam.Program == nil {
			break
		}

		return e.complexity.MucDaiExam.Program(childComplexity), true

	case "Mutation.addConstraints":
		if e.complexity.Mutation.AddConstraints == nil {
			break
		}

		args, err := ec.field_Mutation_addConstraints_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.AddConstraints(childComplexity, args["ancode"].(int), args["constraints"].(model.ConstraintsInput)), true

	case "Mutation.addExamToSlot":
		if e.complexity.Mutation.AddExamToSlot == nil {
			break
		}

		args, err := ec.field_Mutation_addExamToSlot_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.AddExamToSlot(childComplexity, args["day"].(int), args["time"].(int), args["ancode"].(int)), true

	case "Mutation.addNTA":
		if e.complexity.Mutation.AddNta == nil {
			break
		}

		args, err := ec.field_Mutation_addNTA_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.AddNta(childComplexity, args["input"].(model.NTAInput)), true

	case "Mutation.addZpaExamToPlan":
		if e.complexity.Mutation.AddZpaExamToPlan == nil {
			break
		}

		args, err := ec.field_Mutation_addZpaExamToPlan_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.AddZpaExamToPlan(childComplexity, args["ancode"].(int)), true

	case "Mutation.exahm":
		if e.complexity.Mutation.Exahm == nil {
			break
		}

		args, err := ec.field_Mutation_exahm_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.Exahm(childComplexity, args["ancode"].(int)), true

	case "Mutation.excludeDays":
		if e.complexity.Mutation.ExcludeDays == nil {
			break
		}

		args, err := ec.field_Mutation_excludeDays_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.ExcludeDays(childComplexity, args["ancode"].(int), args["days"].([]string)), true

	case "Mutation.lab":
		if e.complexity.Mutation.Lab == nil {
			break
		}

		args, err := ec.field_Mutation_lab_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.Lab(childComplexity, args["ancode"].(int)), true

	case "Mutation.notPlannedByMe":
		if e.complexity.Mutation.NotPlannedByMe == nil {
			break
		}

		args, err := ec.field_Mutation_notPlannedByMe_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.NotPlannedByMe(childComplexity, args["ancode"].(int)), true

	case "Mutation.online":
		if e.complexity.Mutation.Online == nil {
			break
		}

		args, err := ec.field_Mutation_online_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.Online(childComplexity, args["ancode"].(int)), true

	case "Mutation.placesWithSockets":
		if e.complexity.Mutation.PlacesWithSockets == nil {
			break
		}

		args, err := ec.field_Mutation_placesWithSockets_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.PlacesWithSockets(childComplexity, args["ancode"].(int)), true

	case "Mutation.possibleDays":
		if e.complexity.Mutation.PossibleDays == nil {
			break
		}

		args, err := ec.field_Mutation_possibleDays_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.PossibleDays(childComplexity, args["ancode"].(int), args["days"].([]string)), true

	case "Mutation.prePlanRoom":
		if e.complexity.Mutation.PrePlanRoom == nil {
			break
		}

		args, err := ec.field_Mutation_prePlanRoom_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.PrePlanRoom(childComplexity, args["ancode"].(int), args["roomName"].(string), args["reserve"].(bool), args["mtknr"].(*string)), true

	case "Mutation.rmConstraints":
		if e.complexity.Mutation.RmConstraints == nil {
			break
		}

		args, err := ec.field_Mutation_rmConstraints_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.RmConstraints(childComplexity, args["ancode"].(int)), true

	case "Mutation.rmExamFromSlot":
		if e.complexity.Mutation.RmExamFromSlot == nil {
			break
		}

		args, err := ec.field_Mutation_rmExamFromSlot_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.RmExamFromSlot(childComplexity, args["ancode"].(int)), true

	case "Mutation.rmZpaExamFromPlan":
		if e.complexity.Mutation.RmZpaExamFromPlan == nil {
			break
		}

		args, err := ec.field_Mutation_rmZpaExamFromPlan_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.RmZpaExamFromPlan(childComplexity, args["ancode"].(int)), true

	case "Mutation.sameSlot":
		if e.complexity.Mutation.SameSlot == nil {
			break
		}

		args, err := ec.field_Mutation_sameSlot_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.SameSlot(childComplexity, args["ancode"].(int), args["ancodes"].([]int)), true

	case "Mutation.seb":
		if e.complexity.Mutation.Seb == nil {
			break
		}

		args, err := ec.field_Mutation_seb_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.Seb(childComplexity, args["ancode"].(int)), true

	case "Mutation.zpaExamsToPlan":
		if e.complexity.Mutation.ZpaExamsToPlan == nil {
			break
		}

		args, err := ec.field_Mutation_zpaExamsToPlan_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.ZpaExamsToPlan(childComplexity, args["input"].([]int)), true

	case "NTA.compensation":
		if e.complexity.NTA.Compensation == nil {
			break
		}

		return e.complexity.NTA.Compensation(childComplexity), true

	case "NTA.deactivated":
		if e.complexity.NTA.Deactivated == nil {
			break
		}

		return e.complexity.NTA.Deactivated(childComplexity), true

	case "NTA.deltaDurationPercent":
		if e.complexity.NTA.DeltaDurationPercent == nil {
			break
		}

		return e.complexity.NTA.DeltaDurationPercent(childComplexity), true

	case "NTA.email":
		if e.complexity.NTA.Email == nil {
			break
		}

		return e.complexity.NTA.Email(childComplexity), true

	case "NTA.exams":
		if e.complexity.NTA.Exams == nil {
			break
		}

		return e.complexity.NTA.Exams(childComplexity), true

	case "NTA.from":
		if e.complexity.NTA.From == nil {
			break
		}

		return e.complexity.NTA.From(childComplexity), true

	case "NTA.lastSemester":
		if e.complexity.NTA.LastSemester == nil {
			break
		}

		return e.complexity.NTA.LastSemester(childComplexity), true

	case "NTA.mtknr":
		if e.complexity.NTA.Mtknr == nil {
			break
		}

		return e.complexity.NTA.Mtknr(childComplexity), true

	case "NTA.name":
		if e.complexity.NTA.Name == nil {
			break
		}

		return e.complexity.NTA.Name(childComplexity), true

	case "NTA.needsHardware":
		if e.complexity.NTA.NeedsHardware == nil {
			break
		}

		return e.complexity.NTA.NeedsHardware(childComplexity), true

	case "NTA.needsRoomAlone":
		if e.complexity.NTA.NeedsRoomAlone == nil {
			break
		}

		return e.complexity.NTA.NeedsRoomAlone(childComplexity), true

	case "NTA.program":
		if e.complexity.NTA.Program == nil {
			break
		}

		return e.complexity.NTA.Program(childComplexity), true

	case "NTA.until":
		if e.complexity.NTA.Until == nil {
			break
		}

		return e.complexity.NTA.Until(childComplexity), true

	case "NTAExam.ancode":
		if e.complexity.NTAExam.AnCode == nil {
			break
		}

		return e.complexity.NTAExam.AnCode(childComplexity), true

	case "NTAExam.mainExamer":
		if e.complexity.NTAExam.MainExamer == nil {
			break
		}

		return e.complexity.NTAExam.MainExamer(childComplexity), true

	case "NTAExam.module":
		if e.complexity.NTAExam.Module == nil {
			break
		}

		return e.complexity.NTAExam.Module(childComplexity), true

	case "NTAExam.semester":
		if e.complexity.NTAExam.Semester == nil {
			break
		}

		return e.complexity.NTAExam.Semester(childComplexity), true

	case "NTAWithRegs.nta":
		if e.complexity.NTAWithRegs.Nta == nil {
			break
		}

		return e.complexity.NTAWithRegs.Nta(childComplexity), true

	case "NTAWithRegs.regs":
		if e.complexity.NTAWithRegs.Regs == nil {
			break
		}

		return e.complexity.NTAWithRegs.Regs(childComplexity), true

	case "NTAWithRegsByExam.exam":
		if e.complexity.NTAWithRegsByExam.Exam == nil {
			break
		}

		return e.complexity.NTAWithRegsByExam.Exam(childComplexity), true

	case "NTAWithRegsByExam.ntas":
		if e.complexity.NTAWithRegsByExam.Ntas == nil {
			break
		}

		return e.complexity.NTAWithRegsByExam.Ntas(childComplexity), true

	case "NTAWithRegsByExamAndTeacher.exams":
		if e.complexity.NTAWithRegsByExamAndTeacher.Exams == nil {
			break
		}

		return e.complexity.NTAWithRegsByExamAndTeacher.Exams(childComplexity), true

	case "NTAWithRegsByExamAndTeacher.teacher":
		if e.complexity.NTAWithRegsByExamAndTeacher.Teacher == nil {
			break
		}

		return e.complexity.NTAWithRegsByExamAndTeacher.Teacher(childComplexity), true

	case "PlanEntry.ancode":
		if e.complexity.PlanEntry.Ancode == nil {
			break
		}

		return e.complexity.PlanEntry.Ancode(childComplexity), true

	case "PlanEntry.dayNumber":
		if e.complexity.PlanEntry.DayNumber == nil {
			break
		}

		return e.complexity.PlanEntry.DayNumber(childComplexity), true

	case "PlanEntry.locked":
		if e.complexity.PlanEntry.Locked == nil {
			break
		}

		return e.complexity.PlanEntry.Locked(childComplexity), true

	case "PlanEntry.slotNumber":
		if e.complexity.PlanEntry.SlotNumber == nil {
			break
		}

		return e.complexity.PlanEntry.SlotNumber(childComplexity), true

	case "PlanEntry.starttime":
		if e.complexity.PlanEntry.Starttime == nil {
			break
		}

		return e.complexity.PlanEntry.Starttime(childComplexity), true

	case "PlannedExam.ancode":
		if e.complexity.PlannedExam.Ancode == nil {
			break
		}

		return e.complexity.PlannedExam.Ancode(childComplexity), true

	case "PlannedExam.conflicts":
		if e.complexity.PlannedExam.Conflicts == nil {
			break
		}

		return e.complexity.PlannedExam.Conflicts(childComplexity), true

	case "PlannedExam.constraints":
		if e.complexity.PlannedExam.Constraints == nil {
			break
		}

		return e.complexity.PlannedExam.Constraints(childComplexity), true

	case "PlannedExam.mainExamer":
		if e.complexity.PlannedExam.MainExamer == nil {
			break
		}

		return e.complexity.PlannedExam.MainExamer(childComplexity), true

	case "PlannedExam.maxDuration":
		if e.complexity.PlannedExam.MaxDuration == nil {
			break
		}

		return e.complexity.PlannedExam.MaxDuration(childComplexity), true

	case "PlannedExam.ntas":
		if e.complexity.PlannedExam.Ntas == nil {
			break
		}

		return e.complexity.PlannedExam.Ntas(childComplexity), true

	case "PlannedExam.planEntry":
		if e.complexity.PlannedExam.PlanEntry == nil {
			break
		}

		return e.complexity.PlannedExam.PlanEntry(childComplexity), true

	case "PlannedExam.plannedRooms":
		if e.complexity.PlannedExam.PlannedRooms == nil {
			break
		}

		return e.complexity.PlannedExam.PlannedRooms(childComplexity), true

	case "PlannedExam.primussExams":
		if e.complexity.PlannedExam.PrimussExams == nil {
			break
		}

		return e.complexity.PlannedExam.PrimussExams(childComplexity), true

	case "PlannedExam.studentRegsCount":
		if e.complexity.PlannedExam.StudentRegsCount == nil {
			break
		}

		return e.complexity.PlannedExam.StudentRegsCount(childComplexity), true

	case "PlannedExam.zpaExam":
		if e.complexity.PlannedExam.ZpaExam == nil {
			break
		}

		return e.complexity.PlannedExam.ZpaExam(childComplexity), true

	case "PlannedRoom.ancode":
		if e.complexity.PlannedRoom.Ancode == nil {
			break
		}

		return e.complexity.PlannedRoom.Ancode(childComplexity), true

	case "PlannedRoom.day":
		if e.complexity.PlannedRoom.Day == nil {
			break
		}

		return e.complexity.PlannedRoom.Day(childComplexity), true

	case "PlannedRoom.duration":
		if e.complexity.PlannedRoom.Duration == nil {
			break
		}

		return e.complexity.PlannedRoom.Duration(childComplexity), true

	case "PlannedRoom.handicap":
		if e.complexity.PlannedRoom.Handicap == nil {
			break
		}

		return e.complexity.PlannedRoom.Handicap(childComplexity), true

	case "PlannedRoom.handicapRoomAlone":
		if e.complexity.PlannedRoom.HandicapRoomAlone == nil {
			break
		}

		return e.complexity.PlannedRoom.HandicapRoomAlone(childComplexity), true

	case "PlannedRoom.ntaMtknr":
		if e.complexity.PlannedRoom.NtaMtknr == nil {
			break
		}

		return e.complexity.PlannedRoom.NtaMtknr(childComplexity), true

	case "PlannedRoom.prePlanned":
		if e.complexity.PlannedRoom.PrePlanned == nil {
			break
		}

		return e.complexity.PlannedRoom.PrePlanned(childComplexity), true

	case "PlannedRoom.reserve":
		if e.complexity.PlannedRoom.Reserve == nil {
			break
		}

		return e.complexity.PlannedRoom.Reserve(childComplexity), true

	case "PlannedRoom.room":
		if e.complexity.PlannedRoom.Room == nil {
			break
		}

		return e.complexity.PlannedRoom.Room(childComplexity), true

	case "PlannedRoom.slot":
		if e.complexity.PlannedRoom.Slot == nil {
			break
		}

		return e.complexity.PlannedRoom.Slot(childComplexity), true

	case "PlannedRoom.studentsInRoom":
		if e.complexity.PlannedRoom.StudentsInRoom == nil {
			break
		}

		return e.complexity.PlannedRoom.StudentsInRoom(childComplexity), true

	case "PreExam.constraints":
		if e.complexity.PreExam.Constraints == nil {
			break
		}

		return e.complexity.PreExam.Constraints(childComplexity), true

	case "PreExam.planEntry":
		if e.complexity.PreExam.PlanEntry == nil {
			break
		}

		return e.complexity.PreExam.PlanEntry(childComplexity), true

	case "PreExam.zpaExam":
		if e.complexity.PreExam.ZpaExam == nil {
			break
		}

		return e.complexity.PreExam.ZpaExam(childComplexity), true

	case "PrePlannedRoom.ancode":
		if e.complexity.PrePlannedRoom.Ancode == nil {
			break
		}

		return e.complexity.PrePlannedRoom.Ancode(childComplexity), true

	case "PrePlannedRoom.mtknr":
		if e.complexity.PrePlannedRoom.Mtknr == nil {
			break
		}

		return e.complexity.PrePlannedRoom.Mtknr(childComplexity), true

	case "PrePlannedRoom.reserve":
		if e.complexity.PrePlannedRoom.Reserve == nil {
			break
		}

		return e.complexity.PrePlannedRoom.Reserve(childComplexity), true

	case "PrePlannedRoom.roomName":
		if e.complexity.PrePlannedRoom.RoomName == nil {
			break
		}

		return e.complexity.PrePlannedRoom.RoomName(childComplexity), true

	case "PrimussExam.ancode":
		if e.complexity.PrimussExam.AnCode == nil {
			break
		}

		return e.complexity.PrimussExam.AnCode(childComplexity), true

	case "PrimussExam.examType":
		if e.complexity.PrimussExam.ExamType == nil {
			break
		}

		return e.complexity.PrimussExam.ExamType(childComplexity), true

	case "PrimussExam.mainExamer":
		if e.complexity.PrimussExam.MainExamer == nil {
			break
		}

		return e.complexity.PrimussExam.MainExamer(childComplexity), true

	case "PrimussExam.module":
		if e.complexity.PrimussExam.Module == nil {
			break
		}

		return e.complexity.PrimussExam.Module(childComplexity), true

	case "PrimussExam.presence":
		if e.complexity.PrimussExam.Presence == nil {
			break
		}

		return e.complexity.PrimussExam.Presence(childComplexity), true

	case "PrimussExam.program":
		if e.complexity.PrimussExam.Program == nil {
			break
		}

		return e.complexity.PrimussExam.Program(childComplexity), true

	case "PrimussExamAncode.ancode":
		if e.complexity.PrimussExamAncode.Ancode == nil {
			break
		}

		return e.complexity.PrimussExamAncode.Ancode(childComplexity), true

	case "PrimussExamAncode.numberOfStuds":
		if e.complexity.PrimussExamAncode.NumberOfStuds == nil {
			break
		}

		return e.complexity.PrimussExamAncode.NumberOfStuds(childComplexity), true

	case "PrimussExamAncode.program":
		if e.complexity.PrimussExamAncode.Program == nil {
			break
		}

		return e.complexity.PrimussExamAncode.Program(childComplexity), true

	case "PrimussExamByProgram.exams":
		if e.complexity.PrimussExamByProgram.Exams == nil {
			break
		}

		return e.complexity.PrimussExamByProgram.Exams(childComplexity), true

	case "PrimussExamByProgram.program":
		if e.complexity.PrimussExamByProgram.Program == nil {
			break
		}

		return e.complexity.PrimussExamByProgram.Program(childComplexity), true

	case "PrimussExamWithCount.ancode":
		if e.complexity.PrimussExamWithCount.Ancode == nil {
			break
		}

		return e.complexity.PrimussExamWithCount.Ancode(childComplexity), true

	case "PrimussExamWithCount.examType":
		if e.complexity.PrimussExamWithCount.ExamType == nil {
			break
		}

		return e.complexity.PrimussExamWithCount.ExamType(childComplexity), true

	case "PrimussExamWithCount.mainExamer":
		if e.complexity.PrimussExamWithCount.MainExamer == nil {
			break
		}

		return e.complexity.PrimussExamWithCount.MainExamer(childComplexity), true

	case "PrimussExamWithCount.module":
		if e.complexity.PrimussExamWithCount.Module == nil {
			break
		}

		return e.complexity.PrimussExamWithCount.Module(childComplexity), true

	case "PrimussExamWithCount.presence":
		if e.complexity.PrimussExamWithCount.Presence == nil {
			break
		}

		return e.complexity.PrimussExamWithCount.Presence(childComplexity), true

	case "PrimussExamWithCount.program":
		if e.complexity.PrimussExamWithCount.Program == nil {
			break
		}

		return e.complexity.PrimussExamWithCount.Program(childComplexity), true

	case "PrimussExamWithCount.studentRegsCount":
		if e.complexity.PrimussExamWithCount.StudentRegsCount == nil {
			break
		}

		return e.complexity.PrimussExamWithCount.StudentRegsCount(childComplexity), true

	case "Query.allProgramsInPlan":
		if e.complexity.Query.AllProgramsInPlan == nil {
			break
		}

		return e.complexity.Query.AllProgramsInPlan(childComplexity), true

	case "Query.allSemesterNames":
		if e.complexity.Query.AllSemesterNames == nil {
			break
		}

		return e.complexity.Query.AllSemesterNames(childComplexity), true

	case "Query.allowedSlots":
		if e.complexity.Query.AllowedSlots == nil {
			break
		}

		args, err := ec.field_Query_allowedSlots_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.AllowedSlots(childComplexity, args["ancode"].(int)), true

	case "Query.ancodesInPlan":
		if e.complexity.Query.AncodesInPlan == nil {
			break
		}

		return e.complexity.Query.AncodesInPlan(childComplexity), true

	case "Query.awkwardSlots":
		if e.complexity.Query.AwkwardSlots == nil {
			break
		}

		args, err := ec.field_Query_awkwardSlots_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.AwkwardSlots(childComplexity, args["ancode"].(int)), true

	case "Query.conflictingAncodes":
		if e.complexity.Query.ConflictingAncodes == nil {
			break
		}

		args, err := ec.field_Query_conflictingAncodes_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.ConflictingAncodes(childComplexity, args["ancode"].(int)), true

	case "Query.connectedExam":
		if e.complexity.Query.ConnectedExam == nil {
			break
		}

		args, err := ec.field_Query_connectedExam_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.ConnectedExam(childComplexity, args["ancode"].(int)), true

	case "Query.connectedExams":
		if e.complexity.Query.ConnectedExams == nil {
			break
		}

		return e.complexity.Query.ConnectedExams(childComplexity), true

	case "Query.constraintForAncode":
		if e.complexity.Query.ConstraintForAncode == nil {
			break
		}

		args, err := ec.field_Query_constraintForAncode_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.ConstraintForAncode(childComplexity, args["ancode"].(int)), true

	case "Query.examerInPlan":
		if e.complexity.Query.ExamerInPlan == nil {
			break
		}

		return e.complexity.Query.ExamerInPlan(childComplexity), true

	case "Query.examsInSlot":
		if e.complexity.Query.ExamsInSlot == nil {
			break
		}

		args, err := ec.field_Query_examsInSlot_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.ExamsInSlot(childComplexity, args["day"].(int), args["time"].(int)), true

	case "Query.examsWithoutSlot":
		if e.complexity.Query.ExamsWithoutSlot == nil {
			break
		}

		return e.complexity.Query.ExamsWithoutSlot(childComplexity), true

	case "Query.fk07programs":
		if e.complexity.Query.Fk07programs == nil {
			break
		}

		return e.complexity.Query.Fk07programs(childComplexity), true

	case "Query.generatedExam":
		if e.complexity.Query.GeneratedExam == nil {
			break
		}

		args, err := ec.field_Query_generatedExam_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.GeneratedExam(childComplexity, args["ancode"].(int)), true

	case "Query.generatedExams":
		if e.complexity.Query.GeneratedExams == nil {
			break
		}

		return e.complexity.Query.GeneratedExams(childComplexity), true

	case "Query.invigilatorTodos":
		if e.complexity.Query.InvigilatorTodos == nil {
			break
		}

		return e.complexity.Query.InvigilatorTodos(childComplexity), true

	case "Query.invigilators":
		if e.complexity.Query.Invigilators == nil {
			break
		}

		return e.complexity.Query.Invigilators(childComplexity), true

	case "Query.invigilatorsForDay":
		if e.complexity.Query.InvigilatorsForDay == nil {
			break
		}

		args, err := ec.field_Query_invigilatorsForDay_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.InvigilatorsForDay(childComplexity, args["day"].(int)), true

	case "Query.invigilatorsWithReq":
		if e.complexity.Query.InvigilatorsWithReq == nil {
			break
		}

		return e.complexity.Query.InvigilatorsWithReq(childComplexity), true

	case "Query.mucdaiExams":
		if e.complexity.Query.MucdaiExams == nil {
			break
		}

		return e.complexity.Query.MucdaiExams(childComplexity), true

	case "Query.nta":
		if e.complexity.Query.Nta == nil {
			break
		}

		args, err := ec.field_Query_nta_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Nta(childComplexity, args["mtknr"].(string)), true

	case "Query.ntas":
		if e.complexity.Query.Ntas == nil {
			break
		}

		return e.complexity.Query.Ntas(childComplexity), true

	case "Query.ntasWithRegs":
		if e.complexity.Query.NtasWithRegs == nil {
			break
		}

		return e.complexity.Query.NtasWithRegs(childComplexity), true

	case "Query.plannedExam":
		if e.complexity.Query.PlannedExam == nil {
			break
		}

		args, err := ec.field_Query_plannedExam_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.PlannedExam(childComplexity, args["ancode"].(int)), true

	case "Query.plannedExams":
		if e.complexity.Query.PlannedExams == nil {
			break
		}

		return e.complexity.Query.PlannedExams(childComplexity), true

	case "Query.plannedRoomForStudent":
		if e.complexity.Query.PlannedRoomForStudent == nil {
			break
		}

		args, err := ec.field_Query_plannedRoomForStudent_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.PlannedRoomForStudent(childComplexity, args["ancode"].(int), args["mtknr"].(string)), true

	case "Query.plannedRoomNames":
		if e.complexity.Query.PlannedRoomNames == nil {
			break
		}

		return e.complexity.Query.PlannedRoomNames(childComplexity), true

	case "Query.plannedRoomNamesInSlot":
		if e.complexity.Query.PlannedRoomNamesInSlot == nil {
			break
		}

		args, err := ec.field_Query_plannedRoomNamesInSlot_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.PlannedRoomNamesInSlot(childComplexity, args["day"].(int), args["time"].(int)), true

	case "Query.plannedRooms":
		if e.complexity.Query.PlannedRooms == nil {
			break
		}

		return e.complexity.Query.PlannedRooms(childComplexity), true

	case "Query.plannedRoomsInSlot":
		if e.complexity.Query.PlannedRoomsInSlot == nil {
			break
		}

		args, err := ec.field_Query_plannedRoomsInSlot_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.PlannedRoomsInSlot(childComplexity, args["day"].(int), args["time"].(int)), true

	case "Query.preExamsInSlot":
		if e.complexity.Query.PreExamsInSlot == nil {
			break
		}

		args, err := ec.field_Query_preExamsInSlot_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.PreExamsInSlot(childComplexity, args["day"].(int), args["time"].(int)), true

	case "Query.prePlannedRooms":
		if e.complexity.Query.PrePlannedRooms == nil {
			break
		}

		return e.complexity.Query.PrePlannedRooms(childComplexity), true

	case "Query.primussExam":
		if e.complexity.Query.PrimussExam == nil {
			break
		}

		args, err := ec.field_Query_primussExam_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.PrimussExam(childComplexity, args["program"].(string), args["ancode"].(int)), true

	case "Query.primussExams":
		if e.complexity.Query.PrimussExams == nil {
			break
		}

		return e.complexity.Query.PrimussExams(childComplexity), true

	case "Query.primussExamsForAnCode":
		if e.complexity.Query.PrimussExamsForAnCode == nil {
			break
		}

		args, err := ec.field_Query_primussExamsForAnCode_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.PrimussExamsForAnCode(childComplexity, args["ancode"].(int)), true

	case "Query.rooms":
		if e.complexity.Query.Rooms == nil {
			break
		}

		return e.complexity.Query.Rooms(childComplexity), true

	case "Query.roomsForSlots":
		if e.complexity.Query.RoomsForSlots == nil {
			break
		}

		return e.complexity.Query.RoomsForSlots(childComplexity), true

	case "Query.roomsWithInvigilationsForSlot":
		if e.complexity.Query.RoomsWithInvigilationsForSlot == nil {
			break
		}

		args, err := ec.field_Query_roomsWithInvigilationsForSlot_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.RoomsWithInvigilationsForSlot(childComplexity, args["day"].(int), args["time"].(int)), true

	case "Query.semester":
		if e.complexity.Query.Semester == nil {
			break
		}

		return e.complexity.Query.Semester(childComplexity), true

	case "Query.semesterConfig":
		if e.complexity.Query.SemesterConfig == nil {
			break
		}

		return e.complexity.Query.SemesterConfig(childComplexity), true

	case "Query.studentByMtknr":
		if e.complexity.Query.StudentByMtknr == nil {
			break
		}

		args, err := ec.field_Query_studentByMtknr_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.StudentByMtknr(childComplexity, args["mtknr"].(string)), true

	case "Query.studentRegsForProgram":
		if e.complexity.Query.StudentRegsForProgram == nil {
			break
		}

		args, err := ec.field_Query_studentRegsForProgram_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.StudentRegsForProgram(childComplexity, args["program"].(string)), true

	case "Query.studentRegsImportErrors":
		if e.complexity.Query.StudentRegsImportErrors == nil {
			break
		}

		return e.complexity.Query.StudentRegsImportErrors(childComplexity), true

	case "Query.students":
		if e.complexity.Query.Students == nil {
			break
		}

		return e.complexity.Query.Students(childComplexity), true

	case "Query.studentsByName":
		if e.complexity.Query.StudentsByName == nil {
			break
		}

		args, err := ec.field_Query_studentsByName_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.StudentsByName(childComplexity, args["regex"].(string)), true

	case "Query.teacher":
		if e.complexity.Query.Teacher == nil {
			break
		}

		args, err := ec.field_Query_teacher_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Teacher(childComplexity, args["id"].(int)), true

	case "Query.teachers":
		if e.complexity.Query.Teachers == nil {
			break
		}

		args, err := ec.field_Query_teachers_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Teachers(childComplexity, args["fromZPA"].(*bool)), true

	case "Query.zpaAnCodes":
		if e.complexity.Query.ZpaAnCodes == nil {
			break
		}

		return e.complexity.Query.ZpaAnCodes(childComplexity), true

	case "Query.zpaExam":
		if e.complexity.Query.ZpaExam == nil {
			break
		}

		args, err := ec.field_Query_zpaExam_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.ZpaExam(childComplexity, args["ancode"].(int)), true

	case "Query.zpaExams":
		if e.complexity.Query.ZpaExams == nil {
			break
		}

		args, err := ec.field_Query_zpaExams_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.ZpaExams(childComplexity, args["fromZPA"].(*bool)), true

	case "Query.zpaExamsByType":
		if e.complexity.Query.ZpaExamsByType == nil {
			break
		}

		return e.complexity.Query.ZpaExamsByType(childComplexity), true

	case "Query.zpaExamsNotToPlan":
		if e.complexity.Query.ZpaExamsNotToPlan == nil {
			break
		}

		return e.complexity.Query.ZpaExamsNotToPlan(childComplexity), true

	case "Query.zpaExamsPlaningStatusUnknown":
		if e.complexity.Query.ZpaExamsPlaningStatusUnknown == nil {
			break
		}

		return e.complexity.Query.ZpaExamsPlaningStatusUnknown(childComplexity), true

	case "Query.zpaExamsToPlan":
		if e.complexity.Query.ZpaExamsToPlan == nil {
			break
		}

		return e.complexity.Query.ZpaExamsToPlan(childComplexity), true

	case "Query.zpaExamsToPlanWithConstraints":
		if e.complexity.Query.ZpaExamsToPlanWithConstraints == nil {
			break
		}

		return e.complexity.Query.ZpaExamsToPlanWithConstraints(childComplexity), true

	case "RegWithError.error":
		if e.complexity.RegWithError.Error == nil {
			break
		}

		return e.complexity.RegWithError.Error(childComplexity), true

	case "RegWithError.registration":
		if e.complexity.RegWithError.Registration == nil {
			break
		}

		return e.complexity.RegWithError.Registration(childComplexity), true

	case "RegWithProgram.program":
		if e.complexity.RegWithProgram.Program == nil {
			break
		}

		return e.complexity.RegWithProgram.Program(childComplexity), true

	case "RegWithProgram.reg":
		if e.complexity.RegWithProgram.Reg == nil {
			break
		}

		return e.complexity.RegWithProgram.Reg(childComplexity), true

	case "Room.exahm":
		if e.complexity.Room.Exahm == nil {
			break
		}

		return e.complexity.Room.Exahm(childComplexity), true

	case "Room.handicap":
		if e.complexity.Room.Handicap == nil {
			break
		}

		return e.complexity.Room.Handicap(childComplexity), true

	case "Room.hmebSeats":
		if e.complexity.Room.HmebSeats == nil {
			break
		}

		return e.complexity.Room.HmebSeats(childComplexity), true

	case "Room.lab":
		if e.complexity.Room.Lab == nil {
			break
		}

		return e.complexity.Room.Lab(childComplexity), true

	case "Room.name":
		if e.complexity.Room.Name == nil {
			break
		}

		return e.complexity.Room.Name(childComplexity), true

	case "Room.needsRequest":
		if e.complexity.Room.NeedsRequest == nil {
			break
		}

		return e.complexity.Room.NeedsRequest(childComplexity), true

	case "Room.placesWithSocket":
		if e.complexity.Room.PlacesWithSocket == nil {
			break
		}

		return e.complexity.Room.PlacesWithSocket(childComplexity), true

	case "Room.seats":
		if e.complexity.Room.Seats == nil {
			break
		}

		return e.complexity.Room.Seats(childComplexity), true

	case "Room.seb":
		if e.complexity.Room.Seb == nil {
			break
		}

		return e.complexity.Room.Seb(childComplexity), true

	case "Room.sebSeats":
		if e.complexity.Room.SebSeats == nil {
			break
		}

		return e.complexity.Room.SebSeats(childComplexity), true

	case "RoomAndExam.exam":
		if e.complexity.RoomAndExam.Exam == nil {
			break
		}

		return e.complexity.RoomAndExam.Exam(childComplexity), true

	case "RoomAndExam.room":
		if e.complexity.RoomAndExam.Room == nil {
			break
		}

		return e.complexity.RoomAndExam.Room(childComplexity), true

	case "RoomConstraints.allowedRooms":
		if e.complexity.RoomConstraints.AllowedRooms == nil {
			break
		}

		return e.complexity.RoomConstraints.AllowedRooms(childComplexity), true

	case "RoomConstraints.comments":
		if e.complexity.RoomConstraints.Comments == nil {
			break
		}

		return e.complexity.RoomConstraints.Comments(childComplexity), true

	case "RoomConstraints.exahm":
		if e.complexity.RoomConstraints.Exahm == nil {
			break
		}

		return e.complexity.RoomConstraints.Exahm(childComplexity), true

	case "RoomConstraints.kdpJiraURL":
		if e.complexity.RoomConstraints.KdpJiraURL == nil {
			break
		}

		return e.complexity.RoomConstraints.KdpJiraURL(childComplexity), true

	case "RoomConstraints.lab":
		if e.complexity.RoomConstraints.Lab == nil {
			break
		}

		return e.complexity.RoomConstraints.Lab(childComplexity), true

	case "RoomConstraints.maxStudents":
		if e.complexity.RoomConstraints.MaxStudents == nil {
			break
		}

		return e.complexity.RoomConstraints.MaxStudents(childComplexity), true

	case "RoomConstraints.placesWithSocket":
		if e.complexity.RoomConstraints.PlacesWithSocket == nil {
			break
		}

		return e.complexity.RoomConstraints.PlacesWithSocket(childComplexity), true

	case "RoomConstraints.seb":
		if e.complexity.RoomConstraints.Seb == nil {
			break
		}

		return e.complexity.RoomConstraints.Seb(childComplexity), true

	case "RoomWithInvigilator.invigilator":
		if e.complexity.RoomWithInvigilator.Invigilator == nil {
			break
		}

		return e.complexity.RoomWithInvigilator.Invigilator(childComplexity), true

	case "RoomWithInvigilator.maxDuration":
		if e.complexity.RoomWithInvigilator.MaxDuration == nil {
			break
		}

		return e.complexity.RoomWithInvigilator.MaxDuration(childComplexity), true

	case "RoomWithInvigilator.name":
		if e.complexity.RoomWithInvigilator.Name == nil {
			break
		}

		return e.complexity.RoomWithInvigilator.Name(childComplexity), true

	case "RoomWithInvigilator.roomAndExams":
		if e.complexity.RoomWithInvigilator.RoomAndExams == nil {
			break
		}

		return e.complexity.RoomWithInvigilator.RoomAndExams(childComplexity), true

	case "RoomWithInvigilator.studentCount":
		if e.complexity.RoomWithInvigilator.StudentCount == nil {
			break
		}

		return e.complexity.RoomWithInvigilator.StudentCount(childComplexity), true

	case "RoomsForSlot.day":
		if e.complexity.RoomsForSlot.Day == nil {
			break
		}

		return e.complexity.RoomsForSlot.Day(childComplexity), true

	case "RoomsForSlot.rooms":
		if e.complexity.RoomsForSlot.Rooms == nil {
			break
		}

		return e.complexity.RoomsForSlot.Rooms(childComplexity), true

	case "RoomsForSlot.slot":
		if e.complexity.RoomsForSlot.Slot == nil {
			break
		}

		return e.complexity.RoomsForSlot.Slot(childComplexity), true

	case "Semester.id":
		if e.complexity.Semester.ID == nil {
			break
		}

		return e.complexity.Semester.ID(childComplexity), true

	case "SemesterConfig.days":
		if e.complexity.SemesterConfig.Days == nil {
			break
		}

		return e.complexity.SemesterConfig.Days(childComplexity), true

	case "SemesterConfig.emails":
		if e.complexity.SemesterConfig.Emails == nil {
			break
		}

		return e.complexity.SemesterConfig.Emails(childComplexity), true

	case "SemesterConfig.forbiddenSlots":
		if e.complexity.SemesterConfig.ForbiddenSlots == nil {
			break
		}

		return e.complexity.SemesterConfig.ForbiddenSlots(childComplexity), true

	case "SemesterConfig.from":
		if e.complexity.SemesterConfig.From == nil {
			break
		}

		return e.complexity.SemesterConfig.From(childComplexity), true

	case "SemesterConfig.fromFK07":
		if e.complexity.SemesterConfig.FromFk07 == nil {
			break
		}

		return e.complexity.SemesterConfig.FromFk07(childComplexity), true

	case "SemesterConfig.goDay0":
		if e.complexity.SemesterConfig.GoDay0 == nil {
			break
		}

		return e.complexity.SemesterConfig.GoDay0(childComplexity), true

	case "SemesterConfig.goSlots":
		if e.complexity.SemesterConfig.GoSlots == nil {
			break
		}

		return e.complexity.SemesterConfig.GoSlots(childComplexity), true

	case "SemesterConfig.goSlotsRaw":
		if e.complexity.SemesterConfig.GoSlotsRaw == nil {
			break
		}

		return e.complexity.SemesterConfig.GoSlotsRaw(childComplexity), true

	case "SemesterConfig.slots":
		if e.complexity.SemesterConfig.Slots == nil {
			break
		}

		return e.complexity.SemesterConfig.Slots(childComplexity), true

	case "SemesterConfig.starttimes":
		if e.complexity.SemesterConfig.Starttimes == nil {
			break
		}

		return e.complexity.SemesterConfig.Starttimes(childComplexity), true

	case "SemesterConfig.until":
		if e.complexity.SemesterConfig.Until == nil {
			break
		}

		return e.complexity.SemesterConfig.Until(childComplexity), true

	case "Slot.dayNumber":
		if e.complexity.Slot.DayNumber == nil {
			break
		}

		return e.complexity.Slot.DayNumber(childComplexity), true

	case "Slot.slotNumber":
		if e.complexity.Slot.SlotNumber == nil {
			break
		}

		return e.complexity.Slot.SlotNumber(childComplexity), true

	case "Slot.starttime":
		if e.complexity.Slot.Starttime == nil {
			break
		}

		return e.complexity.Slot.Starttime(childComplexity), true

	case "Starttime.number":
		if e.complexity.Starttime.Number == nil {
			break
		}

		return e.complexity.Starttime.Number(childComplexity), true

	case "Starttime.start":
		if e.complexity.Starttime.Start == nil {
			break
		}

		return e.complexity.Starttime.Start(childComplexity), true

	case "Student.group":
		if e.complexity.Student.Group == nil {
			break
		}

		return e.complexity.Student.Group(childComplexity), true

	case "Student.mtknr":
		if e.complexity.Student.Mtknr == nil {
			break
		}

		return e.complexity.Student.Mtknr(childComplexity), true

	case "Student.name":
		if e.complexity.Student.Name == nil {
			break
		}

		return e.complexity.Student.Name(childComplexity), true

	case "Student.nta":
		if e.complexity.Student.Nta == nil {
			break
		}

		return e.complexity.Student.Nta(childComplexity), true

	case "Student.program":
		if e.complexity.Student.Program == nil {
			break
		}

		return e.complexity.Student.Program(childComplexity), true

	case "Student.regs":
		if e.complexity.Student.Regs == nil {
			break
		}

		return e.complexity.Student.Regs(childComplexity), true

	case "Student.regsWithProgram":
		if e.complexity.Student.RegsWithProgram == nil {
			break
		}

		return e.complexity.Student.RegsWithProgram(childComplexity), true

	case "Student.zpaStudent":
		if e.complexity.Student.ZpaStudent == nil {
			break
		}

		return e.complexity.Student.ZpaStudent(childComplexity), true

	case "StudentReg.ancode":
		if e.complexity.StudentReg.AnCode == nil {
			break
		}

		return e.complexity.StudentReg.AnCode(childComplexity), true

	case "StudentReg.group":
		if e.complexity.StudentReg.Group == nil {
			break
		}

		return e.complexity.StudentReg.Group(childComplexity), true

	case "StudentReg.mtknr":
		if e.complexity.StudentReg.Mtknr == nil {
			break
		}

		return e.complexity.StudentReg.Mtknr(childComplexity), true

	case "StudentReg.name":
		if e.complexity.StudentReg.Name == nil {
			break
		}

		return e.complexity.StudentReg.Name(childComplexity), true

	case "StudentReg.presence":
		if e.complexity.StudentReg.Presence == nil {
			break
		}

		return e.complexity.StudentReg.Presence(childComplexity), true

	case "StudentReg.program":
		if e.complexity.StudentReg.Program == nil {
			break
		}

		return e.complexity.StudentReg.Program(childComplexity), true

	case "StudentRegsPerAncode.ancode":
		if e.complexity.StudentRegsPerAncode.Ancode == nil {
			break
		}

		return e.complexity.StudentRegsPerAncode.Ancode(childComplexity), true

	case "StudentRegsPerAncode.perProgram":
		if e.complexity.StudentRegsPerAncode.PerProgram == nil {
			break
		}

		return e.complexity.StudentRegsPerAncode.PerProgram(childComplexity), true

	case "StudentRegsPerAncodeAndProgram.ancode":
		if e.complexity.StudentRegsPerAncodeAndProgram.Ancode == nil {
			break
		}

		return e.complexity.StudentRegsPerAncodeAndProgram.Ancode(childComplexity), true

	case "StudentRegsPerAncodeAndProgram.program":
		if e.complexity.StudentRegsPerAncodeAndProgram.Program == nil {
			break
		}

		return e.complexity.StudentRegsPerAncodeAndProgram.Program(childComplexity), true

	case "StudentRegsPerAncodeAndProgram.studentRegs":
		if e.complexity.StudentRegsPerAncodeAndProgram.StudentRegs == nil {
			break
		}

		return e.complexity.StudentRegsPerAncodeAndProgram.StudentRegs(childComplexity), true

	case "StudentRegsPerStudent.ancodes":
		if e.complexity.StudentRegsPerStudent.Ancodes == nil {
			break
		}

		return e.complexity.StudentRegsPerStudent.Ancodes(childComplexity), true

	case "StudentRegsPerStudent.student":
		if e.complexity.StudentRegsPerStudent.Student == nil {
			break
		}

		return e.complexity.StudentRegsPerStudent.Student(childComplexity), true

	case "Teacher.email":
		if e.complexity.Teacher.Email == nil {
			break
		}

		return e.complexity.Teacher.Email(childComplexity), true

	case "Teacher.fk":
		if e.complexity.Teacher.FK == nil {
			break
		}

		return e.complexity.Teacher.FK(childComplexity), true

	case "Teacher.fullname":
		if e.complexity.Teacher.Fullname == nil {
			break
		}

		return e.complexity.Teacher.Fullname(childComplexity), true

	case "Teacher.id":
		if e.complexity.Teacher.ID == nil {
			break
		}

		return e.complexity.Teacher.ID(childComplexity), true

	case "Teacher.isActive":
		if e.complexity.Teacher.IsActive == nil {
			break
		}

		return e.complexity.Teacher.IsActive(childComplexity), true

	case "Teacher.isLBA":
		if e.complexity.Teacher.IsLBA == nil {
			break
		}

		return e.complexity.Teacher.IsLBA(childComplexity), true

	case "Teacher.isProf":
		if e.complexity.Teacher.IsProf == nil {
			break
		}

		return e.complexity.Teacher.IsProf(childComplexity), true

	case "Teacher.isProfHC":
		if e.complexity.Teacher.IsProfHC == nil {
			break
		}

		return e.complexity.Teacher.IsProfHC(childComplexity), true

	case "Teacher.isStaff":
		if e.complexity.Teacher.IsStaff == nil {
			break
		}

		return e.complexity.Teacher.IsStaff(childComplexity), true

	case "Teacher.lastSemester":
		if e.complexity.Teacher.LastSemester == nil {
			break
		}

		return e.complexity.Teacher.LastSemester(childComplexity), true

	case "Teacher.shortname":
		if e.complexity.Teacher.Shortname == nil {
			break
		}

		return e.complexity.Teacher.Shortname(childComplexity), true

	case "ZPAConflict.ancode":
		if e.complexity.ZPAConflict.Ancode == nil {
			break
		}

		return e.complexity.ZPAConflict.Ancode(childComplexity), true

	case "ZPAConflict.numberOfStuds":
		if e.complexity.ZPAConflict.NumberOfStuds == nil {
			break
		}

		return e.complexity.ZPAConflict.NumberOfStuds(childComplexity), true

	case "ZPAConflict.primussAncodes":
		if e.complexity.ZPAConflict.PrimussAncodes == nil {
			break
		}

		return e.complexity.ZPAConflict.PrimussAncodes(childComplexity), true

	case "ZPAExam.ancode":
		if e.complexity.ZPAExam.AnCode == nil {
			break
		}

		return e.complexity.ZPAExam.AnCode(childComplexity), true

	case "ZPAExam.duration":
		if e.complexity.ZPAExam.Duration == nil {
			break
		}

		return e.complexity.ZPAExam.Duration(childComplexity), true

	case "ZPAExam.examType":
		if e.complexity.ZPAExam.ExamType == nil {
			break
		}

		return e.complexity.ZPAExam.ExamType(childComplexity), true

	case "ZPAExam.examTypeFull":
		if e.complexity.ZPAExam.ExamTypeFull == nil {
			break
		}

		return e.complexity.ZPAExam.ExamTypeFull(childComplexity), true

	case "ZPAExam.groups":
		if e.complexity.ZPAExam.Groups == nil {
			break
		}

		return e.complexity.ZPAExam.Groups(childComplexity), true

	case "ZPAExam.isRepeaterExam":
		if e.complexity.ZPAExam.IsRepeaterExam == nil {
			break
		}

		return e.complexity.ZPAExam.IsRepeaterExam(childComplexity), true

	case "ZPAExam.mainExamer":
		if e.complexity.ZPAExam.MainExamer == nil {
			break
		}

		return e.complexity.ZPAExam.MainExamer(childComplexity), true

	case "ZPAExam.mainExamerID":
		if e.complexity.ZPAExam.MainExamerID == nil {
			break
		}

		return e.complexity.ZPAExam.MainExamerID(childComplexity), true

	case "ZPAExam.module":
		if e.complexity.ZPAExam.Module == nil {
			break
		}

		return e.complexity.ZPAExam.Module(childComplexity), true

	case "ZPAExam.primussAncodes":
		if e.complexity.ZPAExam.PrimussAncodes == nil {
			break
		}

		return e.complexity.ZPAExam.PrimussAncodes(childComplexity), true

	case "ZPAExam.semester":
		if e.complexity.ZPAExam.Semester == nil {
			break
		}

		return e.complexity.ZPAExam.Semester(childComplexity), true

	case "ZPAExam.zpaID":
		if e.complexity.ZPAExam.ZpaID == nil {
			break
		}

		return e.complexity.ZPAExam.ZpaID(childComplexity), true

	case "ZPAExamWithConstraints.constraints":
		if e.complexity.ZPAExamWithConstraints.Constraints == nil {
			break
		}

		return e.complexity.ZPAExamWithConstraints.Constraints(childComplexity), true

	case "ZPAExamWithConstraints.planEntry":
		if e.complexity.ZPAExamWithConstraints.PlanEntry == nil {
			break
		}

		return e.complexity.ZPAExamWithConstraints.PlanEntry(childComplexity), true

	case "ZPAExamWithConstraints.zpaExam":
		if e.complexity.ZPAExamWithConstraints.ZpaExam == nil {
			break
		}

		return e.complexity.ZPAExamWithConstraints.ZpaExam(childComplexity), true

	case "ZPAExamsForType.exams":
		if e.complexity.ZPAExamsForType.Exams == nil {
			break
		}

		return e.complexity.ZPAExamsForType.Exams(childComplexity), true

	case "ZPAExamsForType.type":
		if e.complexity.ZPAExamsForType.Type == nil {
			break
		}

		return e.complexity.ZPAExamsForType.Type(childComplexity), true

	case "ZPAInvigilator.hasSubmittedRequirements":
		if e.complexity.ZPAInvigilator.HasSubmittedRequirements == nil {
			break
		}

		return e.complexity.ZPAInvigilator.HasSubmittedRequirements(childComplexity), true

	case "ZPAInvigilator.teacher":
		if e.complexity.ZPAInvigilator.Teacher == nil {
			break
		}

		return e.complexity.ZPAInvigilator.Teacher(childComplexity), true

	case "ZPAPrimussAncodes.ancode":
		if e.complexity.ZPAPrimussAncodes.Ancode == nil {
			break
		}

		return e.complexity.ZPAPrimussAncodes.Ancode(childComplexity), true

	case "ZPAPrimussAncodes.program":
		if e.complexity.ZPAPrimussAncodes.Program == nil {
			break
		}

		return e.complexity.ZPAPrimussAncodes.Program(childComplexity), true

	case "ZPAStudent.Email":
		if e.complexity.ZPAStudent.Email == nil {
			break
		}

		return e.complexity.ZPAStudent.Email(childComplexity), true

	case "ZPAStudent.FirstName":
		if e.complexity.ZPAStudent.FirstName == nil {
			break
		}

		return e.complexity.ZPAStudent.FirstName(childComplexity), true

	case "ZPAStudent.Gender":
		if e.complexity.ZPAStudent.Gender == nil {
			break
		}

		return e.complexity.ZPAStudent.Gender(childComplexity), true

	case "ZPAStudent.Greeting":
		if e.complexity.ZPAStudent.Greeting == nil {
			break
		}

		return e.complexity.ZPAStudent.Greeting(childComplexity), true

	case "ZPAStudent.Group":
		if e.complexity.ZPAStudent.Group == nil {
			break
		}

		return e.complexity.ZPAStudent.Group(childComplexity), true

	case "ZPAStudent.LastName":
		if e.complexity.ZPAStudent.LastName == nil {
			break
		}

		return e.complexity.ZPAStudent.LastName(childComplexity), true

	case "ZPAStudentReg.ancode":
		if e.complexity.ZPAStudentReg.AnCode == nil {
			break
		}

		return e.complexity.ZPAStudentReg.AnCode(childComplexity), true

	case "ZPAStudentReg.mtknr":
		if e.complexity.ZPAStudentReg.Mtknr == nil {
			break
		}

		return e.complexity.ZPAStudentReg.Mtknr(childComplexity), true

	case "ZPAStudentReg.program":
		if e.complexity.ZPAStudentReg.Program == nil {
			break
		}

		return e.complexity.ZPAStudentReg.Program(childComplexity), true

	case "ZPAStudentRegError.ancode":
		if e.complexity.ZPAStudentRegError.AnCode == nil {
			break
		}

		return e.complexity.ZPAStudentRegError.AnCode(childComplexity), true

	case "ZPAStudentRegError.exam":
		if e.complexity.ZPAStudentRegError.Exam == nil {
			break
		}

		return e.complexity.ZPAStudentRegError.Exam(childComplexity), true

	case "ZPAStudentRegError.mtknr":
		if e.complexity.ZPAStudentRegError.Mtknr == nil {
			break
		}

		return e.complexity.ZPAStudentRegError.Mtknr(childComplexity), true

	case "ZPAStudentRegError.program":
		if e.complexity.ZPAStudentRegError.Program == nil {
			break
		}

		return e.complexity.ZPAStudentRegError.Program(childComplexity), true

	case "ZPAStudentRegError.semester":
		if e.complexity.ZPAStudentRegError.Semester == nil {
			break
		}

		return e.complexity.ZPAStudentRegError.Semester(childComplexity), true

	}
	return 0, false
}

func (e *executableSchema) Exec(ctx context.Context) graphql.ResponseHandler {
	opCtx := graphql.GetOperationContext(ctx)
	ec := executionContext{opCtx, e, 0, 0, make(chan graphql.DeferredResult)}
	inputUnmarshalMap := graphql.BuildUnmarshalerMap(
		ec.unmarshalInputConstraintsInput,
		ec.unmarshalInputNTAInput,
		ec.unmarshalInputPrimussExamInput,
	)
	first := true

	switch opCtx.Operation.Operation {
	case ast.Query:
		return func(ctx context.Context) *graphql.Response {
			var response graphql.Response
			var data graphql.Marshaler
			if first {
				first = false
				ctx = graphql.WithUnmarshalerMap(ctx, inputUnmarshalMap)
				data = ec._Query(ctx, opCtx.Operation.SelectionSet)
			} else {
				if atomic.LoadInt32(&ec.pendingDeferred) > 0 {
					result := <-ec.deferredResults
					atomic.AddInt32(&ec.pendingDeferred, -1)
					data = result.Result
					response.Path = result.Path
					response.Label = result.Label
					response.Errors = result.Errors
				} else {
					return nil
				}
			}
			var buf bytes.Buffer
			data.MarshalGQL(&buf)
			response.Data = buf.Bytes()
			if atomic.LoadInt32(&ec.deferred) > 0 {
				hasNext := atomic.LoadInt32(&ec.pendingDeferred) > 0
				response.HasNext = &hasNext
			}

			return &response
		}
	case ast.Mutation:
		return func(ctx context.Context) *graphql.Response {
			if !first {
				return nil
			}
			first = false
			ctx = graphql.WithUnmarshalerMap(ctx, inputUnmarshalMap)
			data := ec._Mutation(ctx, opCtx.Operation.SelectionSet)
			var buf bytes.Buffer
			data.MarshalGQL(&buf)

			return &graphql.Response{
				Data: buf.Bytes(),
			}
		}

	default:
		return graphql.OneShot(graphql.ErrorResponse(ctx, "unsupported GraphQL operation"))
	}
}

type executionContext struct {
	*graphql.OperationContext
	*executableSchema
	deferred        int32
	pendingDeferred int32
	deferredResults chan graphql.DeferredResult
}

func (ec *executionContext) processDeferredGroup(dg graphql.DeferredGroup) {
	atomic.AddInt32(&ec.pendingDeferred, 1)
	go func() {
		ctx := graphql.WithFreshResponseContext(dg.Context)
		dg.FieldSet.Dispatch(ctx)
		ds := graphql.DeferredResult{
			Path:   dg.Path,
			Label:  dg.Label,
			Result: dg.FieldSet,
			Errors: graphql.GetErrors(ctx),
		}
		// null fields should bubble up
		if dg.FieldSet.Invalids > 0 {
			ds.Result = graphql.Null
		}
		ec.deferredResults <- ds
	}()
}

func (ec *executionContext) introspectSchema() (*introspection.Schema, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapSchema(ec.Schema()), nil
}

func (ec *executionContext) introspectType(name string) (*introspection.Type, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapTypeFromDef(ec.Schema(), ec.Schema().Types[name]), nil
}

var sources = []*ast.Source{
	{Name: "../constraints.graphqls", Input: `scalar Time

extend type Query {
  constraintForAncode(ancode: Int!): Constraints
  zpaExamsToPlanWithConstraints: [ZPAExamWithConstraints!]!
}

extend type Mutation {
  notPlannedByMe(ancode: Int!): Boolean!
  excludeDays(ancode: Int!, days: [String!]!): Boolean!
  possibleDays(ancode: Int!, days: [String!]!): Boolean!
  sameSlot(ancode: Int!, ancodes: [Int!]!): Boolean!
  placesWithSockets(ancode: Int!): Boolean!
  lab(ancode: Int!): Boolean!
  exahm(ancode: Int!): Boolean!
  seb(ancode: Int!): Boolean!
  online(ancode: Int!): Boolean!

  addConstraints(ancode: Int!, constraints: ConstraintsInput!): Constraints!
  rmConstraints(ancode: Int!): Boolean!
}

type Constraints {
  ancode: Int!
  notPlannedByMe: Boolean!
  excludeDays: [Time!]
  possibleDays: [Time!]
  fixedDay: Time
  fixedTime: Time
  sameSlot: [Int!]
  online: Boolean!
  roomConstraints: RoomConstraints
}

type RoomConstraints {
  allowedRooms: [String!]
  placesWithSocket: Boolean!
  lab: Boolean!
  exahm: Boolean!
  seb: Boolean!
  kdpJiraURL: String
  maxStudents: Int
  comments: String
}

input ConstraintsInput {
  allowedRooms: [String!]
  notPlannedByMe: Boolean
  excludeDays: [Time!]
  possibleDays: [Time!]
  fixedDay: Time
  fixedTime: Time
  sameSlot: [Int!]
  online: Boolean
  placesWithSocket: Boolean
  lab: Boolean
  exahm: Boolean
  seb: Boolean
  kdpJiraURL: String
  maxStudents: Int
  comments: String
}
`, BuiltIn: false},
	{Name: "../exam.graphqls", Input: `extend type Query {
  connectedExam(ancode: Int!): ConnectedExam
  connectedExams: [ConnectedExam!]!

  generatedExams: [GeneratedExam!]!
  generatedExam(ancode: Int!): GeneratedExam

  plannedExams: [PlannedExam!]!
  plannedExam(ancode: Int!): PlannedExam

  mucdaiExams: [MucDaiExam!]!

  conflictingAncodes(ancode: Int!): [Conflict!]
}

type ExamWithRegsAndRooms {
  exam: PlannedExam!
  normalRegsMtknr: [String!]!
  ntasInNormalRooms: [NTA!]!
  ntasInAloneRooms: [NTA!]!
  rooms: [PlannedRoom!]!
}

type ConnectedExam {
  zpaExam: ZPAExam!
  primussExams: [PrimussExam!]!
  otherPrimussExams: [PrimussExam!]!
  errors: [String!]!
}

type GeneratedExam {
  ancode: Int!
  zpaExam: ZPAExam!
  mainExamer: Teacher!
  primussExams: [EnhancedPrimussExam!]!
  constraints: Constraints
  conflicts: [ZPAConflict!]!
  studentRegsCount: Int!
  ntas: [NTA!]!
  maxDuration: Int!
}

type ZPAConflict {
  ancode: Int!
  numberOfStuds: Int!
  primussAncodes: [PrimussExamAncode!]!
}

type PlannedExam {
  ancode: Int!
  zpaExam: ZPAExam!
  mainExamer: Teacher!
  primussExams: [EnhancedPrimussExam!]!
  constraints: Constraints
  conflicts: [ZPAConflict!]!
  studentRegsCount: Int!
  ntas: [NTA!]!
  maxDuration: Int!
  planEntry: PlanEntry
  plannedRooms: [PlannedRoom!]
}

type MucDaiExam {
  primussAncode: Int!
  module: String!
  mainExamer: String!
  mainExamerID: Int
  examType: String!
  duration: Int!
  isRepeaterExam: Boolean!
  program: String!
  plannedBy: String!
}
`, BuiltIn: false},
	{Name: "../invigilation.graphqls", Input: `extend type Query {
  invigilatorTodos: InvigilationTodos
  invigilatorsWithReq: [Invigilator!]!
  roomsWithInvigilationsForSlot(day: Int!, time: Int!): InvigilationSlot
  invigilatorsForDay(day: Int!): InvigilatorsForDay
}

type Invigilation {
  roomName: String
  duration: Int!
  invigilatorID: Int!
  slot: Slot!
  isReserve: Boolean!
  isSelfInvigilation: Boolean!
}

type InvigilationTodos {
  sumExamRooms: Int! # without self invigilations
  sumReserve: Int!
  sumOtherContributions: Int!
  sumOtherContributionsOvertimeCutted: Int!
  invigilatorCount: Int!
  todoPerInvigilator: Int!
  todoPerInvigilatorOvertimeCutted: Int!
  invigilators: [Invigilator!]!
}

type InvigilationSlot {
  reserve: Teacher
  roomsWithInvigilators: [RoomWithInvigilator!]!
}

type InvigilatorsForDay {
  want: [Invigilator!]!
  can: [Invigilator!]!
}

type ZPAInvigilator {
  teacher: Teacher!
  hasSubmittedRequirements: Boolean!
}

type Invigilator {
  teacher: Teacher!
  requirements: InvigilatorRequirements
  todos: InvigilatorTodos
}

type InvigilatorRequirements {
  excludedDates: [Time!]!
  excludedDays: [Int!]!
  examDateTimes: [Time!]!
  examDays: [Int!]!
  partTime: Float!
  oralExamsContribution: Int!
  liveCodingContribution: Int!
  masterContribution: Int!
  freeSemester: Float!
  overtimeLastSemester: Float!
  overtimeThisSemester: Float!
  allContributions: Int!
  factor: Float!
  onlyInSlots: [Slot!]!
}

type InvigilatorTodos {
  totalMinutes: Int!
  doingMinutes: Int!
  enough: Boolean!
  invigilationDays: [Int!]
  invigilations: [Invigilation!]
}

type RoomWithInvigilator {
  name: String!
  maxDuration: Int!
  studentCount: Int!
  roomAndExams: [RoomAndExam!]!
  invigilator: Teacher
}
`, BuiltIn: false},
	{Name: "../nta.graphqls", Input: `extend type Query {
  ntas: [NTA!]
  ntasWithRegs: [Student!]
  nta(mtknr: String!): NTAWithRegs
}

extend type Mutation {
  addNTA(input: NTAInput!): NTA!
}

type NTAExam {
  semester: String!
  ancode: String!
  module: String!
  mainExamer: String!
}

type NTA {
  name: String!
  email: String
  mtknr: String!
  compensation: String!
  deltaDurationPercent: Int!
  needsRoomAlone: Boolean!
  needsHardware: Boolean!
  program: String!
  from: String!
  until: String!
  lastSemester: String
  exams: [NTAExam!]!
  deactivated: Boolean!
}

input NTAInput {
  name: String!
  email: String
  mtknr: String!
  compensation: String!
  deltaDurationPercent: Int!
  needsRoomAlone: Boolean!
  needsHardware: Boolean!
  program: String!
  from: String!
  until: String!
}

type NTAWithRegs {
  nta: NTA!
  regs: StudentRegsPerStudent
}

type NTAWithRegsByExamAndTeacher {
  teacher: Teacher!
  exams: [NTAWithRegsByExam!]
}

type NTAWithRegsByExam {
  exam: ZPAExam!
  ntas: [NTAWithRegs!]
}
`, BuiltIn: false},
	{Name: "../plan.graphqls", Input: `extend type Query {
  allProgramsInPlan: [String!]
  ancodesInPlan: [Int!]
  examerInPlan: [ExamerInPlan!]

  preExamsInSlot(day: Int!, time: Int!): [PreExam!]

  examsInSlot(day: Int!, time: Int!): [PlannedExam!]
  examsWithoutSlot: [PlannedExam!]!

  allowedSlots(ancode: Int!): [Slot!]
  awkwardSlots(ancode: Int!): [Slot!]! # slots before or after a conflict
}

extend type Mutation {
  addExamToSlot(day: Int!, time: Int!, ancode: Int!): Boolean!
  rmExamFromSlot(ancode: Int!): Boolean!
}

type Emails {
  profs: String!
  lbas: String!
  lbasLastSemester: String!
  additionalExamer: [String!]!
  fs: String!
  sekr: String!
}

type ExamDay {
  number: Int!
  date: Time!
}

type Starttime {
  number: Int!
  start: String!
}

type Slot {
  dayNumber: Int!
  slotNumber: Int!
  starttime: Time!
}

type ExamerInPlan {
  mainExamer: String!
  mainExamerID: Int!
}

type PreExam {
  zpaExam: ZPAExam!
  constraints: Constraints
  planEntry: PlanEntry
}

type PlanEntry {
  dayNumber: Int!
  slotNumber: Int!
  starttime: Time!
  ancode: Int!
  locked: Boolean!
}
`, BuiltIn: false},
	{Name: "../primuss.graphqls", Input: `extend type Query {
  primussExams: [PrimussExamByProgram]
  primussExam(program: String!, ancode: Int!): PrimussExam!
  primussExamsForAnCode(ancode: Int!): [PrimussExam!]
  studentRegsForProgram(program: String!): [StudentReg!]
}

type PrimussExam {
  ancode: Int!
  module: String!
  mainExamer: String!
  program: String!
  examType: String!
  presence: String!
}

type EnhancedPrimussExam {
  exam: PrimussExam!
  studentRegs: [StudentReg!]!
  conflicts: [Conflict!]!
  ntas: [NTA!]!
}

type PrimussExamWithCount {
  ancode: Int!
  module: String!
  mainExamer: String!
  program: String!
  examType: String!
  presence: String!
  studentRegsCount: Int!
}

type PrimussExamByProgram {
  program: String!
  exams: [PrimussExamWithCount!]!
}

type PrimussExamAncode {
  ancode: Int!
  program: String!
  numberOfStuds: Int!
}

input PrimussExamInput {
  ancode: Int!
  program: String!
}

type StudentReg {
  mtknr: String!
  ancode: Int!
  program: String!
  group: String!
  name: String!
  presence: String!
}

type Conflicts {
  ancode: Int!
  module: String!
  mainExamer: String!
  conflicts: [Conflict!]!
}

type Conflict {
  ancode: Int!
  numberOfStuds: Int!
}

type ConflictPerProgram {
  program: String!
  conflicts: [Conflict!]!
}

type ConflictsPerProgramAncode {
  program: String!
  ancode: Int!
  conflicts: Conflicts
}
`, BuiltIn: false},
	{Name: "../room.graphqls", Input: `extend type Query {
  rooms: [Room!]!
  prePlannedRooms: [PrePlannedRoom!]!
  roomsForSlots: [RoomsForSlot!]!
  plannedRooms: [PlannedRoom!]!
  plannedRoomNames: [String!]
  plannedRoomNamesInSlot(day: Int!, time: Int!): [String!]
  plannedRoomsInSlot(day: Int!, time: Int!): [PlannedRoom!]
  plannedRoomForStudent(ancode: Int!, mtknr: String!): PlannedRoom
}

extend type Mutation {
  prePlanRoom(
    ancode: Int!
    roomName: String!
    reserve: Boolean!
    mtknr: String
  ): Boolean!
}

type Room {
  name: String!
  seats: Int!
  handicap: Boolean!
  lab: Boolean!
  placesWithSocket: Boolean!
  needsRequest: Boolean!
  exahm: Boolean!
  seb: Boolean!
  sebSeats: Int
  hmebSeats: Int
}

type RoomsForSlot {
  day: Int!
  slot: Int!
  rooms: [Room!]!
}

type PlannedRoom {
  day: Int!
  slot: Int!
  room: Room!
  ancode: Int!
  duration: Int!
  handicap: Boolean!
  handicapRoomAlone: Boolean!
  reserve: Boolean!
  studentsInRoom: [String!]!
  ntaMtknr: String
  prePlanned: Boolean!
}

type PrePlannedRoom {
  ancode: Int!
  roomName: String!
  mtknr: String
  reserve: Boolean!
}

type RoomAndExam {
  room: PlannedRoom!
  exam: ZPAExam!
}
`, BuiltIn: false},
	{Name: "../semesterconfig.graphqls", Input: `type Query {
  allSemesterNames: [Semester!]!
  semester: Semester!
  semesterConfig: SemesterConfig!
}

type Semester {
  id: String!
}

type AnCode {
  ancode: Int!
}

type SemesterConfig {
  days: [ExamDay!]!
  starttimes: [Starttime!]!
  slots: [Slot!]!
  goSlotsRaw: [[Int!]!]
  goSlots: [Slot!]!
  goDay0: Time!
  forbiddenSlots: [Slot!]
  from: Time!
  fromFK07: Time!
  until: Time!
  emails: Emails!
}
`, BuiltIn: false},
	{Name: "../studentregs.graphqls", Input: `extend type Query {
  studentByMtknr(mtknr: String!): Student
  studentsByName(regex: String!): [Student!]!
  students: [Student!]!
}

type StudentRegsPerStudent {
  student: Student!
  ancodes: [Int!]!
}

type StudentRegsPerAncode {
  ancode: Int!
  perProgram: [StudentRegsPerAncodeAndProgram!]!
}

type StudentRegsPerAncodeAndProgram {
  program: String!
  ancode: Int!
  studentRegs: [StudentReg!]!
}

type RegWithProgram {
  program: String!
  reg: Int!
}

type Student {
  mtknr: String!
  program: String!
  group: String!
  name: String!
  regs: [Int!]!
  regsWithProgram: [RegWithProgram!]!
  zpaStudent: ZPAStudent
  nta: NTA
}
`, BuiltIn: false},
	{Name: "../zpa.graphqls", Input: `extend type Query {
  teacher(id: Int!): Teacher
  teachers(fromZPA: Boolean): [Teacher!]!
  invigilators: [ZPAInvigilator!]!
  fk07programs: [FK07Program!]!
  zpaExams(fromZPA: Boolean): [ZPAExam!]!
  zpaExamsByType: [ZPAExamsForType!]!
  zpaExamsToPlan: [ZPAExam!]!
  zpaExamsNotToPlan: [ZPAExam!]!
  zpaExamsPlaningStatusUnknown: [ZPAExam!]!
  zpaExam(ancode: Int!): ZPAExam
  zpaAnCodes: [AnCode]
  studentRegsImportErrors: [RegWithError!]!
}

extend type Mutation {
  zpaExamsToPlan(input: [Int!]!): [ZPAExam!]!
  addZpaExamToPlan(ancode: Int!): Boolean!
  rmZpaExamFromPlan(ancode: Int!): Boolean!
}

type ZPAExam {
  zpaID: Int!
  semester: String!
  ancode: Int!
  module: String!
  mainExamer: String!
  mainExamerID: Int!
  examType: String!
  examTypeFull: String!
  duration: Int!
  isRepeaterExam: Boolean!
  groups: [String!]!
  primussAncodes: [ZPAPrimussAncodes!]!
}

type ZPAPrimussAncodes {
  program: String!
  ancode: Int!
}

type ZPAExamsForType {
  type: String!
  exams: [ZPAExam!]!
}

type ZPAStudentReg {
  ancode: Int!
  mtknr: String!
  program: String!
}

type ZPAStudentRegError {
  semester: String!
  ancode: String!
  exam: String!
  mtknr: String!
  program: String!
}

type RegWithError {
  registration: ZPAStudentReg!
  error: ZPAStudentRegError!
}

type FK07Program {
  name: String!
}

type ZPAExamWithConstraints {
  zpaExam: ZPAExam!
  constraints: Constraints # == nil if no constraint
  planEntry: PlanEntry # == nil if no plan entry
}

type Teacher {
  shortname: String!
  fullname: String!
  isProf: Boolean!
  isLBA: Boolean!
  isProfHC: Boolean!
  isStaff: Boolean!
  lastSemester: String!
  fk: String!
  id: Int!
  email: String!
  isActive: Boolean!
}

type ZPAStudent {
  Greeting: String!
  FirstName: String!
  LastName: String!
  Email: String!
  Gender: String!
  Group: String!
}`, BuiltIn: false},
}
var parsedSchema = gqlparser.MustLoadSchema(sources...)

// endregion ************************** generated!.gotpl **************************

// region    ***************************** args.gotpl *****************************

func (ec *executionContext) field_Mutation_addConstraints_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_addConstraints_argsAncode(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["ancode"] = arg0
	arg1, err := ec.field_Mutation_addConstraints_argsConstraints(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["constraints"] = arg1
	return args, nil
}
func (ec *executionContext) field_Mutation_addConstraints_argsAncode(
	ctx context.Context,
	rawArgs map[string]any,
) (int, error) {
	if _, ok := rawArgs["ancode"]; !ok {
		var zeroVal int
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("ancode"))
	if tmp, ok := rawArgs["ancode"]; ok {
		return ec.unmarshalNInt2int(ctx, tmp)
	}

	var zeroVal int
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_addConstraints_argsConstraints(
	ctx context.Context,
	rawArgs map[string]any,
) (model.ConstraintsInput, error) {
	if _, ok := rawArgs["constraints"]; !ok {
		var zeroVal model.ConstraintsInput
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("constraints"))
	if tmp, ok := rawArgs["constraints"]; ok {
		return ec.unmarshalNConstraintsInput2githubcomobcodeplexamsgographmodelConstraintsInput(ctx, tmp)
	}

	var zeroVal model.ConstraintsInput
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_addExamToSlot_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_addExamToSlot_argsDay(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["day"] = arg0
	arg1, err := ec.field_Mutation_addExamToSlot_argsTime(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["time"] = arg1
	arg2, err := ec.field_Mutation_addExamToSlot_argsAncode(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["ancode"] = arg2
	return args, nil
}
func (ec *executionContext) field_Mutation_addExamToSlot_argsDay(
	ctx context.Context,
	rawArgs map[string]any,
) (int, error) {
	if _, ok := rawArgs["day"]; !ok {
		var zeroVal int
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("day"))
	if tmp, ok := rawArgs["day"]; ok {
		return ec.unmarshalNInt2int(ctx, tmp)
	}

	var zeroVal int
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_addExamToSlot_argsTime(
	ctx context.Context,
	rawArgs map[string]any,
) (int, error) {
	if _, ok := rawArgs["time"]; !ok {
		var zeroVal int
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("time"))
	if tmp, ok := rawArgs["time"]; ok {
		return ec.unmarshalNInt2int(ctx, tmp)
	}

	var zeroVal int
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_addExamToSlot_argsAncode(
	ctx context.Context,
	rawArgs map[string]any,
) (int, error) {
	if _, ok := rawArgs["ancode"]; !ok {
		var zeroVal int
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("ancode"))
	if tmp, ok := rawArgs["ancode"]; ok {
		return ec.unmarshalNInt2int(ctx, tmp)
	}

	var zeroVal int
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_addNTA_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_addNTA_argsInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_addNTA_argsInput(
	ctx context.Context,
	rawArgs map[string]any,
) (model.NTAInput, error) {
	if _, ok := rawArgs["input"]; !ok {
		var zeroVal model.NTAInput
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
	if tmp, ok := rawArgs["input"]; ok {
		return ec.unmarshalNNTAInput2githubcomobcodeplexamsgographmodelNTAInput(ctx, tmp)
	}

	var zeroVal model.NTAInput
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_addZpaExamToPlan_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_addZpaExamToPlan_argsAncode(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["ancode"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_addZpaExamToPlan_argsAncode(
	ctx context.Context,
	rawArgs map[string]any,
) (int, error) {
	if _, ok := rawArgs["ancode"]; !ok {
		var zeroVal int
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("ancode"))
	if tmp, ok := rawArgs["ancode"]; ok {
		return ec.unmarshalNInt2int(ctx, tmp)
	}

	var zeroVal int
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_exahm_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_exahm_argsAncode(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["ancode"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_exahm_argsAncode(
	ctx context.Context,
	rawArgs map[string]any,
) (int, error) {
	if _, ok := rawArgs["ancode"]; !ok {
		var zeroVal int
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("ancode"))
	if tmp, ok := rawArgs["ancode"]; ok {
		return ec.unmarshalNInt2int(ctx, tmp)
	}

	var zeroVal int
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_excludeDays_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_excludeDays_argsAncode(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["ancode"] = arg0
	arg1, err := ec.field_Mutation_excludeDays_argsDays(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["days"] = arg1
	return args, nil
}
func (ec *executionContext) field_Mutation_excludeDays_argsAncode(
	ctx context.Context,
	rawArgs map[string]any,
) (int, error) {
	if _, ok := rawArgs["ancode"]; !ok {
		var zeroVal int
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("ancode"))
	if tmp, ok := rawArgs["ancode"]; ok {
		return ec.unmarshalNInt2int(ctx, tmp)
	}

	var zeroVal int
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_excludeDays_argsDays(
	ctx context.Context,
	rawArgs map[string]any,
) ([]string, error) {
	if _, ok := rawArgs["days"]; !ok {
		var zeroVal []string
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("days"))
	if tmp, ok := rawArgs["days"]; ok {
		return ec.unmarshalNString2string(ctx, tmp)
	}

	var zeroVal []string
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_lab_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_lab_argsAncode(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["ancode"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_lab_argsAncode(
	ctx context.Context,
	rawArgs map[string]any,
) (int, error) {
	if _, ok := rawArgs["ancode"]; !ok {
		var zeroVal int
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("ancode"))
	if tmp, ok := rawArgs["ancode"]; ok {
		return ec.unmarshalNInt2int(ctx, tmp)
	}

	var zeroVal int
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_notPlannedByMe_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_notPlannedByMe_argsAncode(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["ancode"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_notPlannedByMe_argsAncode(
	ctx context.Context,
	rawArgs map[string]any,
) (int, error) {
	if _, ok := rawArgs["ancode"]; !ok {
		var zeroVal int
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("ancode"))
	if tmp, ok := rawArgs["ancode"]; ok {
		return ec.unmarshalNInt2int(ctx, tmp)
	}

	var zeroVal int
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_online_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_online_argsAncode(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["ancode"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_online_argsAncode(
	ctx context.Context,
	rawArgs map[string]any,
) (int, error) {
	if _, ok := rawArgs["ancode"]; !ok {
		var zeroVal int
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("ancode"))
	if tmp, ok := rawArgs["ancode"]; ok {
		return ec.unmarshalNInt2int(ctx, tmp)
	}

	var zeroVal int
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_placesWithSockets_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_placesWithSockets_argsAncode(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["ancode"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_placesWithSockets_argsAncode(
	ctx context.Context,
	rawArgs map[string]any,
) (int, error) {
	if _, ok := rawArgs["ancode"]; !ok {
		var zeroVal int
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("ancode"))
	if tmp, ok := rawArgs["ancode"]; ok {
		return ec.unmarshalNInt2int(ctx, tmp)
	}

	var zeroVal int
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_possibleDays_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_possibleDays_argsAncode(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["ancode"] = arg0
	arg1, err := ec.field_Mutation_possibleDays_argsDays(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["days"] = arg1
	return args, nil
}
func (ec *executionContext) field_Mutation_possibleDays_argsAncode(
	ctx context.Context,
	rawArgs map[string]any,
) (int, error) {
	if _, ok := rawArgs["ancode"]; !ok {
		var zeroVal int
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("ancode"))
	if tmp, ok := rawArgs["ancode"]; ok {
		return ec.unmarshalNInt2int(ctx, tmp)
	}

	var zeroVal int
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_possibleDays_argsDays(
	ctx context.Context,
	rawArgs map[string]any,
) ([]string, error) {
	if _, ok := rawArgs["days"]; !ok {
		var zeroVal []string
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("days"))
	if tmp, ok := rawArgs["days"]; ok {
		return ec.unmarshalNString2string(ctx, tmp)
	}

	var zeroVal []string
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_prePlanRoom_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_prePlanRoom_argsAncode(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["ancode"] = arg0
	arg1, err := ec.field_Mutation_prePlanRoom_argsRoomName(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["roomName"] = arg1
	arg2, err := ec.field_Mutation_prePlanRoom_argsReserve(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["reserve"] = arg2
	arg3, err := ec.field_Mutation_prePlanRoom_argsMtknr(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["mtknr"] = arg3
	return args, nil
}
func (ec *executionContext) field_Mutation_prePlanRoom_argsAncode(
	ctx context.Context,
	rawArgs map[string]any,
) (int, error) {
	if _, ok := rawArgs["ancode"]; !ok {
		var zeroVal int
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("ancode"))
	if tmp, ok := rawArgs["ancode"]; ok {
		return ec.unmarshalNInt2int(ctx, tmp)
	}

	var zeroVal int
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_prePlanRoom_argsRoomName(
	ctx context.Context,
	rawArgs map[string]any,
) (string, error) {
	if _, ok := rawArgs["roomName"]; !ok {
		var zeroVal string
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("roomName"))
	if tmp, ok := rawArgs["roomName"]; ok {
		return ec.unmarshalNString2string(ctx, tmp)
	}

	var zeroVal string
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_prePlanRoom_argsReserve(
	ctx context.Context,
	rawArgs map[string]any,
) (bool, error) {
	if _, ok := rawArgs["reserve"]; !ok {
		var zeroVal bool
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("reserve"))
	if tmp, ok := rawArgs["reserve"]; ok {
		return ec.unmarshalNBoolean2bool(ctx, tmp)
	}

	var zeroVal bool
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_prePlanRoom_argsMtknr(
	ctx context.Context,
	rawArgs map[string]any,
) (*string, error) {
	if _, ok := rawArgs["mtknr"]; !ok {
		var zeroVal *string
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("mtknr"))
	if tmp, ok := rawArgs["mtknr"]; ok {
		return ec.unmarshalOString2string(ctx, tmp)
	}

	var zeroVal *string
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_rmConstraints_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_rmConstraints_argsAncode(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["ancode"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_rmConstraints_argsAncode(
	ctx context.Context,
	rawArgs map[string]any,
) (int, error) {
	if _, ok := rawArgs["ancode"]; !ok {
		var zeroVal int
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("ancode"))
	if tmp, ok := rawArgs["ancode"]; ok {
		return ec.unmarshalNInt2int(ctx, tmp)
	}

	var zeroVal int
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_rmExamFromSlot_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_rmExamFromSlot_argsAncode(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["ancode"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_rmExamFromSlot_argsAncode(
	ctx context.Context,
	rawArgs map[string]any,
) (int, error) {
	if _, ok := rawArgs["ancode"]; !ok {
		var zeroVal int
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("ancode"))
	if tmp, ok := rawArgs["ancode"]; ok {
		return ec.unmarshalNInt2int(ctx, tmp)
	}

	var zeroVal int
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_rmZpaExamFromPlan_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_rmZpaExamFromPlan_argsAncode(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["ancode"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_rmZpaExamFromPlan_argsAncode(
	ctx context.Context,
	rawArgs map[string]any,
) (int, error) {
	if _, ok := rawArgs["ancode"]; !ok {
		var zeroVal int
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("ancode"))
	if tmp, ok := rawArgs["ancode"]; ok {
		return ec.unmarshalNInt2int(ctx, tmp)
	}

	var zeroVal int
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_sameSlot_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_sameSlot_argsAncode(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["ancode"] = arg0
	arg1, err := ec.field_Mutation_sameSlot_argsAncodes(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["ancodes"] = arg1
	return args, nil
}
func (ec *executionContext) field_Mutation_sameSlot_argsAncode(
	ctx context.Context,
	rawArgs map[string]any,
) (int, error) {
	if _, ok := rawArgs["ancode"]; !ok {
		var zeroVal int
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("ancode"))
	if tmp, ok := rawArgs["ancode"]; ok {
		return ec.unmarshalNInt2int(ctx, tmp)
	}

	var zeroVal int
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_sameSlot_argsAncodes(
	ctx context.Context,
	rawArgs map[string]any,
) ([]int, error) {
	if _, ok := rawArgs["ancodes"]; !ok {
		var zeroVal []int
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("ancodes"))
	if tmp, ok := rawArgs["ancodes"]; ok {
		return ec.unmarshalNInt2int(ctx, tmp)
	}

	var zeroVal []int
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_seb_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_seb_argsAncode(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["ancode"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_seb_argsAncode(
	ctx context.Context,
	rawArgs map[string]any,
) (int, error) {
	if _, ok := rawArgs["ancode"]; !ok {
		var zeroVal int
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("ancode"))
	if tmp, ok := rawArgs["ancode"]; ok {
		return ec.unmarshalNInt2int(ctx, tmp)
	}

	var zeroVal int
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_zpaExamsToPlan_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_zpaExamsToPlan_argsInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["input"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_zpaExamsToPlan_argsInput(
	ctx context.Context,
	rawArgs map[string]any,
) ([]int, error) {
	if _, ok := rawArgs["input"]; !ok {
		var zeroVal []int
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("input"))
	if tmp, ok := rawArgs["input"]; ok {
		return ec.unmarshalNInt2int(ctx, tmp)
	}

	var zeroVal []int
	return zeroVal, nil
}

func (ec *executionContext) field_Query___type_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Query___type_argsName(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["name"] = arg0
	return args, nil
}
func (ec *executionContext) field_Query___type_argsName(
	ctx context.Context,
	rawArgs map[string]any,
) (string, error) {
	if _, ok := rawArgs["name"]; !ok {
		var zeroVal string
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
	if tmp, ok := rawArgs["name"]; ok {
		return ec.unmarshalNString2string(ctx, tmp)
	}

	var zeroVal string
	return zeroVal, nil
}

func (ec *executionContext) field_Query_allowedSlots_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Query_allowedSlots_argsAncode(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["ancode"] = arg0
	return args, nil
}
func (ec *executionContext) field_Query_allowedSlots_argsAncode(
	ctx context.Context,
	rawArgs map[string]any,
) (int, error) {
	if _, ok := rawArgs["ancode"]; !ok {
		var zeroVal int
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("ancode"))
	if tmp, ok := rawArgs["ancode"]; ok {
		return ec.unmarshalNInt2int(ctx, tmp)
	}

	var zeroVal int
	return zeroVal, nil
}

func (ec *executionContext) field_Query_awkwardSlots_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Query_awkwardSlots_argsAncode(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["ancode"] = arg0
	return args, nil
}
func (ec *executionContext) field_Query_awkwardSlots_argsAncode(
	ctx context.Context,
	rawArgs map[string]any,
) (int, error) {
	if _, ok := rawArgs["ancode"]; !ok {
		var zeroVal int
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("ancode"))
	if tmp, ok := rawArgs["ancode"]; ok {
		return ec.unmarshalNInt2int(ctx, tmp)
	}

	var zeroVal int
	return zeroVal, nil
}

func (ec *executionContext) field_Query_conflictingAncodes_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Query_conflictingAncodes_argsAncode(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["ancode"] = arg0
	return args, nil
}
func (ec *executionContext) field_Query_conflictingAncodes_argsAncode(
	ctx context.Context,
	rawArgs map[string]any,
) (int, error) {
	if _, ok := rawArgs["ancode"]; !ok {
		var zeroVal int
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("ancode"))
	if tmp, ok := rawArgs["ancode"]; ok {
		return ec.unmarshalNInt2int(ctx, tmp)
	}

	var zeroVal int
	return zeroVal, nil
}

func (ec *executionContext) field_Query_connectedExam_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Query_connectedExam_argsAncode(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["ancode"] = arg0
	return args, nil
}
func (ec *executionContext) field_Query_connectedExam_argsAncode(
	ctx context.Context,
	rawArgs map[string]any,
) (int, error) {
	if _, ok := rawArgs["ancode"]; !ok {
		var zeroVal int
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("ancode"))
	if tmp, ok := rawArgs["ancode"]; ok {
		return ec.unmarshalNInt2int(ctx, tmp)
	}

	var zeroVal int
	return zeroVal, nil
}

func (ec *executionContext) field_Query_constraintForAncode_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Query_constraintForAncode_argsAncode(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["ancode"] = arg0
	return args, nil
}
func (ec *executionContext) field_Query_constraintForAncode_argsAncode(
	ctx context.Context,
	rawArgs map[string]any,
) (int, error) {
	if _, ok := rawArgs["ancode"]; !ok {
		var zeroVal int
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("ancode"))
	if tmp, ok := rawArgs["ancode"]; ok {
		return ec.unmarshalNInt2int(ctx, tmp)
	}

	var zeroVal int
	return zeroVal, nil
}

func (ec *executionContext) field_Query_examsInSlot_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Query_examsInSlot_argsDay(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["day"] = arg0
	arg1, err := ec.field_Query_examsInSlot_argsTime(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["time"] = arg1
	return args, nil
}
func (ec *executionContext) field_Query_examsInSlot_argsDay(
	ctx context.Context,
	rawArgs map[string]any,
) (int, error) {
	if _, ok := rawArgs["day"]; !ok {
		var zeroVal int
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("day"))
	if tmp, ok := rawArgs["day"]; ok {
		return ec.unmarshalNInt2int(ctx, tmp)
	}

	var zeroVal int
	return zeroVal, nil
}

func (ec *executionContext) field_Query_examsInSlot_argsTime(
	ctx context.Context,
	rawArgs map[string]any,
) (int, error) {
	if _, ok := rawArgs["time"]; !ok {
		var zeroVal int
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("time"))
	if tmp, ok := rawArgs["time"]; ok {
		return ec.unmarshalNInt2int(ctx, tmp)
	}

	var zeroVal int
	return zeroVal, nil
}

func (ec *executionContext) field_Query_generatedExam_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Query_generatedExam_argsAncode(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["ancode"] = arg0
	return args, nil
}
func (ec *executionContext) field_Query_generatedExam_argsAncode(
	ctx context.Context,
	rawArgs map[string]any,
) (int, error) {
	if _, ok := rawArgs["ancode"]; !ok {
		var zeroVal int
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("ancode"))
	if tmp, ok := rawArgs["ancode"]; ok {
		return ec.unmarshalNInt2int(ctx, tmp)
	}

	var zeroVal int
	return zeroVal, nil
}

func (ec *executionContext) field_Query_invigilatorsForDay_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Query_invigilatorsForDay_argsDay(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["day"] = arg0
	return args, nil
}
func (ec *executionContext) field_Query_invigilatorsForDay_argsDay(
	ctx context.Context,
	rawArgs map[string]any,
) (int, error) {
	if _, ok := rawArgs["day"]; !ok {
		var zeroVal int
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("day"))
	if tmp, ok := rawArgs["day"]; ok {
		return ec.unmarshalNInt2int(ctx, tmp)
	}

	var zeroVal int
	return zeroVal, nil
}

func (ec *executionContext) field_Query_nta_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Query_nta_argsMtknr(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["mtknr"] = arg0
	return args, nil
}
func (ec *executionContext) field_Query_nta_argsMtknr(
	ctx context.Context,
	rawArgs map[string]any,
) (string, error) {
	if _, ok := rawArgs["mtknr"]; !ok {
		var zeroVal string
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("mtknr"))
	if tmp, ok := rawArgs["mtknr"]; ok {
		return ec.unmarshalNString2string(ctx, tmp)
	}

	var zeroVal string
	return zeroVal, nil
}

func (ec *executionContext) field_Query_plannedExam_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Query_plannedExam_argsAncode(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["ancode"] = arg0
	return args, nil
}
func (ec *executionContext) field_Query_plannedExam_argsAncode(
	ctx context.Context,
	rawArgs map[string]any,
) (int, error) {
	if _, ok := rawArgs["ancode"]; !ok {
		var zeroVal int
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("ancode"))
	if tmp, ok := rawArgs["ancode"]; ok {
		return ec.unmarshalNInt2int(ctx, tmp)
	}

	var zeroVal int
	return zeroVal, nil
}

func (ec *executionContext) field_Query_plannedRoomForStudent_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Query_plannedRoomForStudent_argsAncode(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["ancode"] = arg0
	arg1, err := ec.field_Query_plannedRoomForStudent_argsMtknr(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["mtknr"] = arg1
	return args, nil
}
func (ec *executionContext) field_Query_plannedRoomForStudent_argsAncode(
	ctx context.Context,
	rawArgs map[string]any,
) (int, error) {
	if _, ok := rawArgs["ancode"]; !ok {
		var zeroVal int
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("ancode"))
	if tmp, ok := rawArgs["ancode"]; ok {
		return ec.unmarshalNInt2int(ctx, tmp)
	}

	var zeroVal int
	return zeroVal, nil
}

func (ec *executionContext) field_Query_plannedRoomForStudent_argsMtknr(
	ctx context.Context,
	rawArgs map[string]any,
) (string, error) {
	if _, ok := rawArgs["mtknr"]; !ok {
		var zeroVal string
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("mtknr"))
	if tmp, ok := rawArgs["mtknr"]; ok {
		return ec.unmarshalNString2string(ctx, tmp)
	}

	var zeroVal string
	return zeroVal, nil
}

func (ec *executionContext) field_Query_plannedRoomNamesInSlot_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Query_plannedRoomNamesInSlot_argsDay(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["day"] = arg0
	arg1, err := ec.field_Query_plannedRoomNamesInSlot_argsTime(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["time"] = arg1
	return args, nil
}
func (ec *executionContext) field_Query_plannedRoomNamesInSlot_argsDay(
	ctx context.Context,
	rawArgs map[string]any,
) (int, error) {
	if _, ok := rawArgs["day"]; !ok {
		var zeroVal int
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("day"))
	if tmp, ok := rawArgs["day"]; ok {
		return ec.unmarshalNInt2int(ctx, tmp)
	}

	var zeroVal int
	return zeroVal, nil
}

func (ec *executionContext) field_Query_plannedRoomNamesInSlot_argsTime(
	ctx context.Context,
	rawArgs map[string]any,
) (int, error) {
	if _, ok := rawArgs["time"]; !ok {
		var zeroVal int
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("time"))
	if tmp, ok := rawArgs["time"]; ok {
		return ec.unmarshalNInt2int(ctx, tmp)
	}

	var zeroVal int
	return zeroVal, nil
}

func (ec *executionContext) field_Query_plannedRoomsInSlot_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Query_plannedRoomsInSlot_argsDay(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["day"] = arg0
	arg1, err := ec.field_Query_plannedRoomsInSlot_argsTime(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["time"] = arg1
	return args, nil
}
func (ec *executionContext) field_Query_plannedRoomsInSlot_argsDay(
	ctx context.Context,
	rawArgs map[string]any,
) (int, error) {
	if _, ok := rawArgs["day"]; !ok {
		var zeroVal int
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("day"))
	if tmp, ok := rawArgs["day"]; ok {
		return ec.unmarshalNInt2int(ctx, tmp)
	}

	var zeroVal int
	return zeroVal, nil
}

func (ec *executionContext) field_Query_plannedRoomsInSlot_argsTime(
	ctx context.Context,
	rawArgs map[string]any,
) (int, error) {
	if _, ok := rawArgs["time"]; !ok {
		var zeroVal int
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("time"))
	if tmp, ok := rawArgs["time"]; ok {
		return ec.unmarshalNInt2int(ctx, tmp)
	}

	var zeroVal int
	return zeroVal, nil
}

func (ec *executionContext) field_Query_preExamsInSlot_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Query_preExamsInSlot_argsDay(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["day"] = arg0
	arg1, err := ec.field_Query_preExamsInSlot_argsTime(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["time"] = arg1
	return args, nil
}
func (ec *executionContext) field_Query_preExamsInSlot_argsDay(
	ctx context.Context,
	rawArgs map[string]any,
) (int, error) {
	if _, ok := rawArgs["day"]; !ok {
		var zeroVal int
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("day"))
	if tmp, ok := rawArgs["day"]; ok {
		return ec.unmarshalNInt2int(ctx, tmp)
	}

	var zeroVal int
	return zeroVal, nil
}

func (ec *executionContext) field_Query_preExamsInSlot_argsTime(
	ctx context.Context,
	rawArgs map[string]any,
) (int, error) {
	if _, ok := rawArgs["time"]; !ok {
		var zeroVal int
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("time"))
	if tmp, ok := rawArgs["time"]; ok {
		return ec.unmarshalNInt2int(ctx, tmp)
	}

	var zeroVal int
	return zeroVal, nil
}

func (ec *executionContext) field_Query_primussExam_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Query_primussExam_argsProgram(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["program"] = arg0
	arg1, err := ec.field_Query_primussExam_argsAncode(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["ancode"] = arg1
	return args, nil
}
func (ec *executionContext) field_Query_primussExam_argsProgram(
	ctx context.Context,
	rawArgs map[string]any,
) (string, error) {
	if _, ok := rawArgs["program"]; !ok {
		var zeroVal string
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("program"))
	if tmp, ok := rawArgs["program"]; ok {
		return ec.unmarshalNString2string(ctx, tmp)
	}

	var zeroVal string
	return zeroVal, nil
}

func (ec *executionContext) field_Query_primussExam_argsAncode(
	ctx context.Context,
	rawArgs map[string]any,
) (int, error) {
	if _, ok := rawArgs["ancode"]; !ok {
		var zeroVal int
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("ancode"))
	if tmp, ok := rawArgs["ancode"]; ok {
		return ec.unmarshalNInt2int(ctx, tmp)
	}

	var zeroVal int
	return zeroVal, nil
}

func (ec *executionContext) field_Query_primussExamsForAnCode_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Query_primussExamsForAnCode_argsAncode(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["ancode"] = arg0
	return args, nil
}
func (ec *executionContext) field_Query_primussExamsForAnCode_argsAncode(
	ctx context.Context,
	rawArgs map[string]any,
) (int, error) {
	if _, ok := rawArgs["ancode"]; !ok {
		var zeroVal int
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("ancode"))
	if tmp, ok := rawArgs["ancode"]; ok {
		return ec.unmarshalNInt2int(ctx, tmp)
	}

	var zeroVal int
	return zeroVal, nil
}

func (ec *executionContext) field_Query_roomsWithInvigilationsForSlot_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Query_roomsWithInvigilationsForSlot_argsDay(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["day"] = arg0
	arg1, err := ec.field_Query_roomsWithInvigilationsForSlot_argsTime(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["time"] = arg1
	return args, nil
}
func (ec *executionContext) field_Query_roomsWithInvigilationsForSlot_argsDay(
	ctx context.Context,
	rawArgs map[string]any,
) (int, error) {
	if _, ok := rawArgs["day"]; !ok {
		var zeroVal int
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("day"))
	if tmp, ok := rawArgs["day"]; ok {
		return ec.unmarshalNInt2int(ctx, tmp)
	}

	var zeroVal int
	return zeroVal, nil
}

func (ec *executionContext) field_Query_roomsWithInvigilationsForSlot_argsTime(
	ctx context.Context,
	rawArgs map[string]any,
) (int, error) {
	if _, ok := rawArgs["time"]; !ok {
		var zeroVal int
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("time"))
	if tmp, ok := rawArgs["time"]; ok {
		return ec.unmarshalNInt2int(ctx, tmp)
	}

	var zeroVal int
	return zeroVal, nil
}

func (ec *executionContext) field_Query_studentByMtknr_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Query_studentByMtknr_argsMtknr(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["mtknr"] = arg0
	return args, nil
}
func (ec *executionContext) field_Query_studentByMtknr_argsMtknr(
	ctx context.Context,
	rawArgs map[string]any,
) (string, error) {
	if _, ok := rawArgs["mtknr"]; !ok {
		var zeroVal string
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("mtknr"))
	if tmp, ok := rawArgs["mtknr"]; ok {
		return ec.unmarshalNString2string(ctx, tmp)
	}

	var zeroVal string
	return zeroVal, nil
}

func (ec *executionContext) field_Query_studentRegsForProgram_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Query_studentRegsForProgram_argsProgram(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["program"] = arg0
	return args, nil
}
func (ec *executionContext) field_Query_studentRegsForProgram_argsProgram(
	ctx context.Context,
	rawArgs map[string]any,
) (string, error) {
	if _, ok := rawArgs["program"]; !ok {
		var zeroVal string
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("program"))
	if tmp, ok := rawArgs["program"]; ok {
		return ec.unmarshalNString2string(ctx, tmp)
	}

	var zeroVal string
	return zeroVal, nil
}

func (ec *executionContext) field_Query_studentsByName_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Query_studentsByName_argsRegex(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["regex"] = arg0
	return args, nil
}
func (ec *executionContext) field_Query_studentsByName_argsRegex(
	ctx context.Context,
	rawArgs map[string]any,
) (string, error) {
	if _, ok := rawArgs["regex"]; !ok {
		var zeroVal string
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("regex"))
	if tmp, ok := rawArgs["regex"]; ok {
		return ec.unmarshalNString2string(ctx, tmp)
	}

	var zeroVal string
	return zeroVal, nil
}

func (ec *executionContext) field_Query_teacher_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Query_teacher_argsID(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["id"] = arg0
	return args, nil
}
func (ec *executionContext) field_Query_teacher_argsID(
	ctx context.Context,
	rawArgs map[string]any,
) (int, error) {
	if _, ok := rawArgs["id"]; !ok {
		var zeroVal int
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
	if tmp, ok := rawArgs["id"]; ok {
		return ec.unmarshalNInt2int(ctx, tmp)
	}

	var zeroVal int
	return zeroVal, nil
}

func (ec *executionContext) field_Query_teachers_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Query_teachers_argsFromZpa(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["fromZPA"] = arg0
	return args, nil
}
func (ec *executionContext) field_Query_teachers_argsFromZpa(
	ctx context.Context,
	rawArgs map[string]any,
) (*bool, error) {
	if _, ok := rawArgs["fromZPA"]; !ok {
		var zeroVal *bool
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("fromZPA"))
	if tmp, ok := rawArgs["fromZPA"]; ok {
		return ec.unmarshalOBoolean2bool(ctx, tmp)
	}

	var zeroVal *bool
	return zeroVal, nil
}

func (ec *executionContext) field_Query_zpaExam_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Query_zpaExam_argsAncode(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["ancode"] = arg0
	return args, nil
}
func (ec *executionContext) field_Query_zpaExam_argsAncode(
	ctx context.Context,
	rawArgs map[string]any,
) (int, error) {
	if _, ok := rawArgs["ancode"]; !ok {
		var zeroVal int
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("ancode"))
	if tmp, ok := rawArgs["ancode"]; ok {
		return ec.unmarshalNInt2int(ctx, tmp)
	}

	var zeroVal int
	return zeroVal, nil
}

func (ec *executionContext) field_Query_zpaExams_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Query_zpaExams_argsFromZpa(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["fromZPA"] = arg0
	return args, nil
}
func (ec *executionContext) field_Query_zpaExams_argsFromZpa(
	ctx context.Context,
	rawArgs map[string]any,
) (*bool, error) {
	if _, ok := rawArgs["fromZPA"]; !ok {
		var zeroVal *bool
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("fromZPA"))
	if tmp, ok := rawArgs["fromZPA"]; ok {
		return ec.unmarshalOBoolean2bool(ctx, tmp)
	}

	var zeroVal *bool
	return zeroVal, nil
}

func (ec *executionContext) field___Directive_args_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field___Directive_args_argsIncludeDeprecated(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["includeDeprecated"] = arg0
	return args, nil
}
func (ec *executionContext) field___Directive_args_argsIncludeDeprecated(
	ctx context.Context,
	rawArgs map[string]any,
) (*bool, error) {
	if _, ok := rawArgs["includeDeprecated"]; !ok {
		var zeroVal *bool
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("includeDeprecated"))
	if tmp, ok := rawArgs["includeDeprecated"]; ok {
		return ec.unmarshalOBoolean2bool(ctx, tmp)
	}

	var zeroVal *bool
	return zeroVal, nil
}

func (ec *executionContext) field___Field_args_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field___Field_args_argsIncludeDeprecated(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["includeDeprecated"] = arg0
	return args, nil
}
func (ec *executionContext) field___Field_args_argsIncludeDeprecated(
	ctx context.Context,
	rawArgs map[string]any,
) (*bool, error) {
	if _, ok := rawArgs["includeDeprecated"]; !ok {
		var zeroVal *bool
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("includeDeprecated"))
	if tmp, ok := rawArgs["includeDeprecated"]; ok {
		return ec.unmarshalOBoolean2bool(ctx, tmp)
	}

	var zeroVal *bool
	return zeroVal, nil
}

func (ec *executionContext) field___Type_enumValues_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field___Type_enumValues_argsIncludeDeprecated(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["includeDeprecated"] = arg0
	return args, nil
}
func (ec *executionContext) field___Type_enumValues_argsIncludeDeprecated(
	ctx context.Context,
	rawArgs map[string]any,
) (bool, error) {
	if _, ok := rawArgs["includeDeprecated"]; !ok {
		var zeroVal bool
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("includeDeprecated"))
	if tmp, ok := rawArgs["includeDeprecated"]; ok {
		return ec.unmarshalOBoolean2bool(ctx, tmp)
	}

	var zeroVal bool
	return zeroVal, nil
}

func (ec *executionContext) field___Type_fields_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field___Type_fields_argsIncludeDeprecated(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["includeDeprecated"] = arg0
	return args, nil
}
func (ec *executionContext) field___Type_fields_argsIncludeDeprecated(
	ctx context.Context,
	rawArgs map[string]any,
) (bool, error) {
	if _, ok := rawArgs["includeDeprecated"]; !ok {
		var zeroVal bool
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("includeDeprecated"))
	if tmp, ok := rawArgs["includeDeprecated"]; ok {
		return ec.unmarshalOBoolean2bool(ctx, tmp)
	}

	var zeroVal bool
	return zeroVal, nil
}

// endregion ***************************** args.gotpl *****************************

// region    ************************** directives.gotpl **************************

// endregion ************************** directives.gotpl **************************

// region    **************************** field.gotpl *****************************

func (ec *executionContext) _AnCode_ancode(ctx context.Context, field graphql.CollectedField, obj *model.AnCode) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AnCode_ancode(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Ancode, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AnCode_ancode(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AnCode",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Conflict_ancode(ctx context.Context, field graphql.CollectedField, obj *model.Conflict) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Conflict_ancode(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AnCode, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Conflict_ancode(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Conflict",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Conflict_numberOfStuds(ctx context.Context, field graphql.CollectedField, obj *model.Conflict) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Conflict_numberOfStuds(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.NumberOfStuds, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Conflict_numberOfStuds(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Conflict",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ConflictPerProgram_program(ctx context.Context, field graphql.CollectedField, obj *model.ConflictPerProgram) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ConflictPerProgram_program(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Program, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ConflictPerProgram_program(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ConflictPerProgram",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ConflictPerProgram_conflicts(ctx context.Context, field graphql.CollectedField, obj *model.ConflictPerProgram) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ConflictPerProgram_conflicts(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Conflicts, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.Conflict)
	fc.Result = res
	return ec.marshalNConflict2githubcomobcodeplexamsgographmodelConflict(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ConflictPerProgram_conflicts(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ConflictPerProgram",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "ancode":
				return ec.fieldContext_Conflict_ancode(ctx, field)
			case "numberOfStuds":
				return ec.fieldContext_Conflict_numberOfStuds(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Conflict", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Conflicts_ancode(ctx context.Context, field graphql.CollectedField, obj *model.Conflicts) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Conflicts_ancode(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AnCode, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Conflicts_ancode(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Conflicts",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Conflicts_module(ctx context.Context, field graphql.CollectedField, obj *model.Conflicts) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Conflicts_module(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Module, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Conflicts_module(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Conflicts",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Conflicts_mainExamer(ctx context.Context, field graphql.CollectedField, obj *model.Conflicts) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Conflicts_mainExamer(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MainExamer, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Conflicts_mainExamer(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Conflicts",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Conflicts_conflicts(ctx context.Context, field graphql.CollectedField, obj *model.Conflicts) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Conflicts_conflicts(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Conflicts, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.Conflict)
	fc.Result = res
	return ec.marshalNConflict2githubcomobcodeplexamsgographmodelConflict(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Conflicts_conflicts(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Conflicts",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "ancode":
				return ec.fieldContext_Conflict_ancode(ctx, field)
			case "numberOfStuds":
				return ec.fieldContext_Conflict_numberOfStuds(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Conflict", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ConflictsPerProgramAncode_program(ctx context.Context, field graphql.CollectedField, obj *model.ConflictsPerProgramAncode) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ConflictsPerProgramAncode_program(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Program, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ConflictsPerProgramAncode_program(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ConflictsPerProgramAncode",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ConflictsPerProgramAncode_ancode(ctx context.Context, field graphql.CollectedField, obj *model.ConflictsPerProgramAncode) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ConflictsPerProgramAncode_ancode(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Ancode, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ConflictsPerProgramAncode_ancode(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ConflictsPerProgramAncode",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ConflictsPerProgramAncode_conflicts(ctx context.Context, field graphql.CollectedField, obj *model.ConflictsPerProgramAncode) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ConflictsPerProgramAncode_conflicts(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Conflicts, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.Conflicts)
	fc.Result = res
	return ec.marshalOConflicts2githubcomobcodeplexamsgographmodelConflicts(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ConflictsPerProgramAncode_conflicts(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ConflictsPerProgramAncode",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "ancode":
				return ec.fieldContext_Conflicts_ancode(ctx, field)
			case "module":
				return ec.fieldContext_Conflicts_module(ctx, field)
			case "mainExamer":
				return ec.fieldContext_Conflicts_mainExamer(ctx, field)
			case "conflicts":
				return ec.fieldContext_Conflicts_conflicts(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Conflicts", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ConnectedExam_zpaExam(ctx context.Context, field graphql.CollectedField, obj *model.ConnectedExam) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ConnectedExam_zpaExam(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ZpaExam, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.ZPAExam)
	fc.Result = res
	return ec.marshalNZPAExam2githubcomobcodeplexamsgographmodelZPAExam(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ConnectedExam_zpaExam(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ConnectedExam",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "zpaID":
				return ec.fieldContext_ZPAExam_zpaID(ctx, field)
			case "semester":
				return ec.fieldContext_ZPAExam_semester(ctx, field)
			case "ancode":
				return ec.fieldContext_ZPAExam_ancode(ctx, field)
			case "module":
				return ec.fieldContext_ZPAExam_module(ctx, field)
			case "mainExamer":
				return ec.fieldContext_ZPAExam_mainExamer(ctx, field)
			case "mainExamerID":
				return ec.fieldContext_ZPAExam_mainExamerID(ctx, field)
			case "examType":
				return ec.fieldContext_ZPAExam_examType(ctx, field)
			case "examTypeFull":
				return ec.fieldContext_ZPAExam_examTypeFull(ctx, field)
			case "duration":
				return ec.fieldContext_ZPAExam_duration(ctx, field)
			case "isRepeaterExam":
				return ec.fieldContext_ZPAExam_isRepeaterExam(ctx, field)
			case "groups":
				return ec.fieldContext_ZPAExam_groups(ctx, field)
			case "primussAncodes":
				return ec.fieldContext_ZPAExam_primussAncodes(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ZPAExam", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ConnectedExam_primussExams(ctx context.Context, field graphql.CollectedField, obj *model.ConnectedExam) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ConnectedExam_primussExams(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PrimussExams, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.PrimussExam)
	fc.Result = res
	return ec.marshalNPrimussExam2githubcomobcodeplexamsgographmodelPrimussExam(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ConnectedExam_primussExams(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ConnectedExam",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "ancode":
				return ec.fieldContext_PrimussExam_ancode(ctx, field)
			case "module":
				return ec.fieldContext_PrimussExam_module(ctx, field)
			case "mainExamer":
				return ec.fieldContext_PrimussExam_mainExamer(ctx, field)
			case "program":
				return ec.fieldContext_PrimussExam_program(ctx, field)
			case "examType":
				return ec.fieldContext_PrimussExam_examType(ctx, field)
			case "presence":
				return ec.fieldContext_PrimussExam_presence(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PrimussExam", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ConnectedExam_otherPrimussExams(ctx context.Context, field graphql.CollectedField, obj *model.ConnectedExam) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ConnectedExam_otherPrimussExams(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.OtherPrimussExams, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.PrimussExam)
	fc.Result = res
	return ec.marshalNPrimussExam2githubcomobcodeplexamsgographmodelPrimussExam(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ConnectedExam_otherPrimussExams(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ConnectedExam",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "ancode":
				return ec.fieldContext_PrimussExam_ancode(ctx, field)
			case "module":
				return ec.fieldContext_PrimussExam_module(ctx, field)
			case "mainExamer":
				return ec.fieldContext_PrimussExam_mainExamer(ctx, field)
			case "program":
				return ec.fieldContext_PrimussExam_program(ctx, field)
			case "examType":
				return ec.fieldContext_PrimussExam_examType(ctx, field)
			case "presence":
				return ec.fieldContext_PrimussExam_presence(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PrimussExam", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ConnectedExam_errors(ctx context.Context, field graphql.CollectedField, obj *model.ConnectedExam) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ConnectedExam_errors(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Errors, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ConnectedExam_errors(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ConnectedExam",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Constraints_ancode(ctx context.Context, field graphql.CollectedField, obj *model.Constraints) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Constraints_ancode(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Ancode, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Constraints_ancode(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Constraints",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Constraints_notPlannedByMe(ctx context.Context, field graphql.CollectedField, obj *model.Constraints) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Constraints_notPlannedByMe(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.NotPlannedByMe, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Constraints_notPlannedByMe(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Constraints",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Constraints_excludeDays(ctx context.Context, field graphql.CollectedField, obj *model.Constraints) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Constraints_excludeDays(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ExcludeDays, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*time.Time)
	fc.Result = res
	return ec.marshalOTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Constraints_excludeDays(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Constraints",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Constraints_possibleDays(ctx context.Context, field graphql.CollectedField, obj *model.Constraints) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Constraints_possibleDays(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PossibleDays, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*time.Time)
	fc.Result = res
	return ec.marshalOTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Constraints_possibleDays(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Constraints",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Constraints_fixedDay(ctx context.Context, field graphql.CollectedField, obj *model.Constraints) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Constraints_fixedDay(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FixedDay, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalOTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Constraints_fixedDay(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Constraints",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Constraints_fixedTime(ctx context.Context, field graphql.CollectedField, obj *model.Constraints) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Constraints_fixedTime(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FixedTime, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalOTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Constraints_fixedTime(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Constraints",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Constraints_sameSlot(ctx context.Context, field graphql.CollectedField, obj *model.Constraints) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Constraints_sameSlot(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SameSlot, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Constraints_sameSlot(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Constraints",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Constraints_online(ctx context.Context, field graphql.CollectedField, obj *model.Constraints) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Constraints_online(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Online, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Constraints_online(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Constraints",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Constraints_roomConstraints(ctx context.Context, field graphql.CollectedField, obj *model.Constraints) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Constraints_roomConstraints(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RoomConstraints, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.RoomConstraints)
	fc.Result = res
	return ec.marshalORoomConstraints2githubcomobcodeplexamsgographmodelRoomConstraints(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Constraints_roomConstraints(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Constraints",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "allowedRooms":
				return ec.fieldContext_RoomConstraints_allowedRooms(ctx, field)
			case "placesWithSocket":
				return ec.fieldContext_RoomConstraints_placesWithSocket(ctx, field)
			case "lab":
				return ec.fieldContext_RoomConstraints_lab(ctx, field)
			case "exahm":
				return ec.fieldContext_RoomConstraints_exahm(ctx, field)
			case "seb":
				return ec.fieldContext_RoomConstraints_seb(ctx, field)
			case "kdpJiraURL":
				return ec.fieldContext_RoomConstraints_kdpJiraURL(ctx, field)
			case "maxStudents":
				return ec.fieldContext_RoomConstraints_maxStudents(ctx, field)
			case "comments":
				return ec.fieldContext_RoomConstraints_comments(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type RoomConstraints", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Emails_profs(ctx context.Context, field graphql.CollectedField, obj *model.Emails) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Emails_profs(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Profs, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Emails_profs(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Emails",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Emails_lbas(ctx context.Context, field graphql.CollectedField, obj *model.Emails) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Emails_lbas(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Lbas, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Emails_lbas(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Emails",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Emails_lbasLastSemester(ctx context.Context, field graphql.CollectedField, obj *model.Emails) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Emails_lbasLastSemester(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.LbasLastSemester, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Emails_lbasLastSemester(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Emails",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Emails_additionalExamer(ctx context.Context, field graphql.CollectedField, obj *model.Emails) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Emails_additionalExamer(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AdditionalExamer, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Emails_additionalExamer(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Emails",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Emails_fs(ctx context.Context, field graphql.CollectedField, obj *model.Emails) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Emails_fs(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Fs, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Emails_fs(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Emails",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Emails_sekr(ctx context.Context, field graphql.CollectedField, obj *model.Emails) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Emails_sekr(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Sekr, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Emails_sekr(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Emails",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _EnhancedPrimussExam_exam(ctx context.Context, field graphql.CollectedField, obj *model.EnhancedPrimussExam) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_EnhancedPrimussExam_exam(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Exam, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.PrimussExam)
	fc.Result = res
	return ec.marshalNPrimussExam2githubcomobcodeplexamsgographmodelPrimussExam(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_EnhancedPrimussExam_exam(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "EnhancedPrimussExam",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "ancode":
				return ec.fieldContext_PrimussExam_ancode(ctx, field)
			case "module":
				return ec.fieldContext_PrimussExam_module(ctx, field)
			case "mainExamer":
				return ec.fieldContext_PrimussExam_mainExamer(ctx, field)
			case "program":
				return ec.fieldContext_PrimussExam_program(ctx, field)
			case "examType":
				return ec.fieldContext_PrimussExam_examType(ctx, field)
			case "presence":
				return ec.fieldContext_PrimussExam_presence(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PrimussExam", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _EnhancedPrimussExam_studentRegs(ctx context.Context, field graphql.CollectedField, obj *model.EnhancedPrimussExam) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_EnhancedPrimussExam_studentRegs(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.StudentRegs, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.StudentReg)
	fc.Result = res
	return ec.marshalNStudentReg2githubcomobcodeplexamsgographmodelStudentReg(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_EnhancedPrimussExam_studentRegs(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "EnhancedPrimussExam",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "mtknr":
				return ec.fieldContext_StudentReg_mtknr(ctx, field)
			case "ancode":
				return ec.fieldContext_StudentReg_ancode(ctx, field)
			case "program":
				return ec.fieldContext_StudentReg_program(ctx, field)
			case "group":
				return ec.fieldContext_StudentReg_group(ctx, field)
			case "name":
				return ec.fieldContext_StudentReg_name(ctx, field)
			case "presence":
				return ec.fieldContext_StudentReg_presence(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type StudentReg", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _EnhancedPrimussExam_conflicts(ctx context.Context, field graphql.CollectedField, obj *model.EnhancedPrimussExam) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_EnhancedPrimussExam_conflicts(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Conflicts, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.Conflict)
	fc.Result = res
	return ec.marshalNConflict2githubcomobcodeplexamsgographmodelConflict(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_EnhancedPrimussExam_conflicts(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "EnhancedPrimussExam",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "ancode":
				return ec.fieldContext_Conflict_ancode(ctx, field)
			case "numberOfStuds":
				return ec.fieldContext_Conflict_numberOfStuds(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Conflict", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _EnhancedPrimussExam_ntas(ctx context.Context, field graphql.CollectedField, obj *model.EnhancedPrimussExam) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_EnhancedPrimussExam_ntas(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Ntas, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.NTA)
	fc.Result = res
	return ec.marshalNNTA2githubcomobcodeplexamsgographmodelNTA(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_EnhancedPrimussExam_ntas(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "EnhancedPrimussExam",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext_NTA_name(ctx, field)
			case "email":
				return ec.fieldContext_NTA_email(ctx, field)
			case "mtknr":
				return ec.fieldContext_NTA_mtknr(ctx, field)
			case "compensation":
				return ec.fieldContext_NTA_compensation(ctx, field)
			case "deltaDurationPercent":
				return ec.fieldContext_NTA_deltaDurationPercent(ctx, field)
			case "needsRoomAlone":
				return ec.fieldContext_NTA_needsRoomAlone(ctx, field)
			case "needsHardware":
				return ec.fieldContext_NTA_needsHardware(ctx, field)
			case "program":
				return ec.fieldContext_NTA_program(ctx, field)
			case "from":
				return ec.fieldContext_NTA_from(ctx, field)
			case "until":
				return ec.fieldContext_NTA_until(ctx, field)
			case "lastSemester":
				return ec.fieldContext_NTA_lastSemester(ctx, field)
			case "exams":
				return ec.fieldContext_NTA_exams(ctx, field)
			case "deactivated":
				return ec.fieldContext_NTA_deactivated(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type NTA", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ExamDay_number(ctx context.Context, field graphql.CollectedField, obj *model.ExamDay) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ExamDay_number(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Number, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ExamDay_number(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ExamDay",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ExamDay_date(ctx context.Context, field graphql.CollectedField, obj *model.ExamDay) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ExamDay_date(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Date, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ExamDay_date(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ExamDay",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ExamWithRegsAndRooms_exam(ctx context.Context, field graphql.CollectedField, obj *model.ExamWithRegsAndRooms) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ExamWithRegsAndRooms_exam(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Exam, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.PlannedExam)
	fc.Result = res
	return ec.marshalNPlannedExam2githubcomobcodeplexamsgographmodelPlannedExam(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ExamWithRegsAndRooms_exam(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ExamWithRegsAndRooms",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "ancode":
				return ec.fieldContext_PlannedExam_ancode(ctx, field)
			case "zpaExam":
				return ec.fieldContext_PlannedExam_zpaExam(ctx, field)
			case "mainExamer":
				return ec.fieldContext_PlannedExam_mainExamer(ctx, field)
			case "primussExams":
				return ec.fieldContext_PlannedExam_primussExams(ctx, field)
			case "constraints":
				return ec.fieldContext_PlannedExam_constraints(ctx, field)
			case "conflicts":
				return ec.fieldContext_PlannedExam_conflicts(ctx, field)
			case "studentRegsCount":
				return ec.fieldContext_PlannedExam_studentRegsCount(ctx, field)
			case "ntas":
				return ec.fieldContext_PlannedExam_ntas(ctx, field)
			case "maxDuration":
				return ec.fieldContext_PlannedExam_maxDuration(ctx, field)
			case "planEntry":
				return ec.fieldContext_PlannedExam_planEntry(ctx, field)
			case "plannedRooms":
				return ec.fieldContext_PlannedExam_plannedRooms(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PlannedExam", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ExamWithRegsAndRooms_normalRegsMtknr(ctx context.Context, field graphql.CollectedField, obj *model.ExamWithRegsAndRooms) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ExamWithRegsAndRooms_normalRegsMtknr(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.NormalRegsMtknr, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ExamWithRegsAndRooms_normalRegsMtknr(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ExamWithRegsAndRooms",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ExamWithRegsAndRooms_ntasInNormalRooms(ctx context.Context, field graphql.CollectedField, obj *model.ExamWithRegsAndRooms) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ExamWithRegsAndRooms_ntasInNormalRooms(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.NtasInNormalRooms, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.NTA)
	fc.Result = res
	return ec.marshalNNTA2githubcomobcodeplexamsgographmodelNTA(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ExamWithRegsAndRooms_ntasInNormalRooms(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ExamWithRegsAndRooms",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext_NTA_name(ctx, field)
			case "email":
				return ec.fieldContext_NTA_email(ctx, field)
			case "mtknr":
				return ec.fieldContext_NTA_mtknr(ctx, field)
			case "compensation":
				return ec.fieldContext_NTA_compensation(ctx, field)
			case "deltaDurationPercent":
				return ec.fieldContext_NTA_deltaDurationPercent(ctx, field)
			case "needsRoomAlone":
				return ec.fieldContext_NTA_needsRoomAlone(ctx, field)
			case "needsHardware":
				return ec.fieldContext_NTA_needsHardware(ctx, field)
			case "program":
				return ec.fieldContext_NTA_program(ctx, field)
			case "from":
				return ec.fieldContext_NTA_from(ctx, field)
			case "until":
				return ec.fieldContext_NTA_until(ctx, field)
			case "lastSemester":
				return ec.fieldContext_NTA_lastSemester(ctx, field)
			case "exams":
				return ec.fieldContext_NTA_exams(ctx, field)
			case "deactivated":
				return ec.fieldContext_NTA_deactivated(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type NTA", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ExamWithRegsAndRooms_ntasInAloneRooms(ctx context.Context, field graphql.CollectedField, obj *model.ExamWithRegsAndRooms) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ExamWithRegsAndRooms_ntasInAloneRooms(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.NtasInAloneRooms, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.NTA)
	fc.Result = res
	return ec.marshalNNTA2githubcomobcodeplexamsgographmodelNTA(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ExamWithRegsAndRooms_ntasInAloneRooms(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ExamWithRegsAndRooms",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext_NTA_name(ctx, field)
			case "email":
				return ec.fieldContext_NTA_email(ctx, field)
			case "mtknr":
				return ec.fieldContext_NTA_mtknr(ctx, field)
			case "compensation":
				return ec.fieldContext_NTA_compensation(ctx, field)
			case "deltaDurationPercent":
				return ec.fieldContext_NTA_deltaDurationPercent(ctx, field)
			case "needsRoomAlone":
				return ec.fieldContext_NTA_needsRoomAlone(ctx, field)
			case "needsHardware":
				return ec.fieldContext_NTA_needsHardware(ctx, field)
			case "program":
				return ec.fieldContext_NTA_program(ctx, field)
			case "from":
				return ec.fieldContext_NTA_from(ctx, field)
			case "until":
				return ec.fieldContext_NTA_until(ctx, field)
			case "lastSemester":
				return ec.fieldContext_NTA_lastSemester(ctx, field)
			case "exams":
				return ec.fieldContext_NTA_exams(ctx, field)
			case "deactivated":
				return ec.fieldContext_NTA_deactivated(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type NTA", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ExamWithRegsAndRooms_rooms(ctx context.Context, field graphql.CollectedField, obj *model.ExamWithRegsAndRooms) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ExamWithRegsAndRooms_rooms(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Rooms, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.PlannedRoom)
	fc.Result = res
	return ec.marshalNPlannedRoom2githubcomobcodeplexamsgographmodelPlannedRoom(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ExamWithRegsAndRooms_rooms(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ExamWithRegsAndRooms",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "day":
				return ec.fieldContext_PlannedRoom_day(ctx, field)
			case "slot":
				return ec.fieldContext_PlannedRoom_slot(ctx, field)
			case "room":
				return ec.fieldContext_PlannedRoom_room(ctx, field)
			case "ancode":
				return ec.fieldContext_PlannedRoom_ancode(ctx, field)
			case "duration":
				return ec.fieldContext_PlannedRoom_duration(ctx, field)
			case "handicap":
				return ec.fieldContext_PlannedRoom_handicap(ctx, field)
			case "handicapRoomAlone":
				return ec.fieldContext_PlannedRoom_handicapRoomAlone(ctx, field)
			case "reserve":
				return ec.fieldContext_PlannedRoom_reserve(ctx, field)
			case "studentsInRoom":
				return ec.fieldContext_PlannedRoom_studentsInRoom(ctx, field)
			case "ntaMtknr":
				return ec.fieldContext_PlannedRoom_ntaMtknr(ctx, field)
			case "prePlanned":
				return ec.fieldContext_PlannedRoom_prePlanned(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PlannedRoom", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ExamerInPlan_mainExamer(ctx context.Context, field graphql.CollectedField, obj *model.ExamerInPlan) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ExamerInPlan_mainExamer(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MainExamer, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ExamerInPlan_mainExamer(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ExamerInPlan",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ExamerInPlan_mainExamerID(ctx context.Context, field graphql.CollectedField, obj *model.ExamerInPlan) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ExamerInPlan_mainExamerID(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MainExamerID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ExamerInPlan_mainExamerID(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ExamerInPlan",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FK07Program_name(ctx context.Context, field graphql.CollectedField, obj *model.FK07Program) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FK07Program_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FK07Program_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FK07Program",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GeneratedExam_ancode(ctx context.Context, field graphql.CollectedField, obj *model.GeneratedExam) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GeneratedExam_ancode(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Ancode, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GeneratedExam_ancode(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GeneratedExam",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GeneratedExam_zpaExam(ctx context.Context, field graphql.CollectedField, obj *model.GeneratedExam) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GeneratedExam_zpaExam(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ZpaExam, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.ZPAExam)
	fc.Result = res
	return ec.marshalNZPAExam2githubcomobcodeplexamsgographmodelZPAExam(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GeneratedExam_zpaExam(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GeneratedExam",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "zpaID":
				return ec.fieldContext_ZPAExam_zpaID(ctx, field)
			case "semester":
				return ec.fieldContext_ZPAExam_semester(ctx, field)
			case "ancode":
				return ec.fieldContext_ZPAExam_ancode(ctx, field)
			case "module":
				return ec.fieldContext_ZPAExam_module(ctx, field)
			case "mainExamer":
				return ec.fieldContext_ZPAExam_mainExamer(ctx, field)
			case "mainExamerID":
				return ec.fieldContext_ZPAExam_mainExamerID(ctx, field)
			case "examType":
				return ec.fieldContext_ZPAExam_examType(ctx, field)
			case "examTypeFull":
				return ec.fieldContext_ZPAExam_examTypeFull(ctx, field)
			case "duration":
				return ec.fieldContext_ZPAExam_duration(ctx, field)
			case "isRepeaterExam":
				return ec.fieldContext_ZPAExam_isRepeaterExam(ctx, field)
			case "groups":
				return ec.fieldContext_ZPAExam_groups(ctx, field)
			case "primussAncodes":
				return ec.fieldContext_ZPAExam_primussAncodes(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ZPAExam", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _GeneratedExam_mainExamer(ctx context.Context, field graphql.CollectedField, obj *model.GeneratedExam) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GeneratedExam_mainExamer(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.GeneratedExam().MainExamer(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Teacher)
	fc.Result = res
	return ec.marshalNTeacher2githubcomobcodeplexamsgographmodelTeacher(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GeneratedExam_mainExamer(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GeneratedExam",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "shortname":
				return ec.fieldContext_Teacher_shortname(ctx, field)
			case "fullname":
				return ec.fieldContext_Teacher_fullname(ctx, field)
			case "isProf":
				return ec.fieldContext_Teacher_isProf(ctx, field)
			case "isLBA":
				return ec.fieldContext_Teacher_isLBA(ctx, field)
			case "isProfHC":
				return ec.fieldContext_Teacher_isProfHC(ctx, field)
			case "isStaff":
				return ec.fieldContext_Teacher_isStaff(ctx, field)
			case "lastSemester":
				return ec.fieldContext_Teacher_lastSemester(ctx, field)
			case "fk":
				return ec.fieldContext_Teacher_fk(ctx, field)
			case "id":
				return ec.fieldContext_Teacher_id(ctx, field)
			case "email":
				return ec.fieldContext_Teacher_email(ctx, field)
			case "isActive":
				return ec.fieldContext_Teacher_isActive(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Teacher", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _GeneratedExam_primussExams(ctx context.Context, field graphql.CollectedField, obj *model.GeneratedExam) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GeneratedExam_primussExams(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PrimussExams, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.EnhancedPrimussExam)
	fc.Result = res
	return ec.marshalNEnhancedPrimussExam2githubcomobcodeplexamsgographmodelEnhancedPrimussExam(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GeneratedExam_primussExams(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GeneratedExam",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "exam":
				return ec.fieldContext_EnhancedPrimussExam_exam(ctx, field)
			case "studentRegs":
				return ec.fieldContext_EnhancedPrimussExam_studentRegs(ctx, field)
			case "conflicts":
				return ec.fieldContext_EnhancedPrimussExam_conflicts(ctx, field)
			case "ntas":
				return ec.fieldContext_EnhancedPrimussExam_ntas(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type EnhancedPrimussExam", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _GeneratedExam_constraints(ctx context.Context, field graphql.CollectedField, obj *model.GeneratedExam) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GeneratedExam_constraints(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Constraints, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.Constraints)
	fc.Result = res
	return ec.marshalOConstraints2githubcomobcodeplexamsgographmodelConstraints(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GeneratedExam_constraints(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GeneratedExam",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "ancode":
				return ec.fieldContext_Constraints_ancode(ctx, field)
			case "notPlannedByMe":
				return ec.fieldContext_Constraints_notPlannedByMe(ctx, field)
			case "excludeDays":
				return ec.fieldContext_Constraints_excludeDays(ctx, field)
			case "possibleDays":
				return ec.fieldContext_Constraints_possibleDays(ctx, field)
			case "fixedDay":
				return ec.fieldContext_Constraints_fixedDay(ctx, field)
			case "fixedTime":
				return ec.fieldContext_Constraints_fixedTime(ctx, field)
			case "sameSlot":
				return ec.fieldContext_Constraints_sameSlot(ctx, field)
			case "online":
				return ec.fieldContext_Constraints_online(ctx, field)
			case "roomConstraints":
				return ec.fieldContext_Constraints_roomConstraints(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Constraints", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _GeneratedExam_conflicts(ctx context.Context, field graphql.CollectedField, obj *model.GeneratedExam) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GeneratedExam_conflicts(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Conflicts, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.ZPAConflict)
	fc.Result = res
	return ec.marshalNZPAConflict2githubcomobcodeplexamsgographmodelZPAConflict(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GeneratedExam_conflicts(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GeneratedExam",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "ancode":
				return ec.fieldContext_ZPAConflict_ancode(ctx, field)
			case "numberOfStuds":
				return ec.fieldContext_ZPAConflict_numberOfStuds(ctx, field)
			case "primussAncodes":
				return ec.fieldContext_ZPAConflict_primussAncodes(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ZPAConflict", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _GeneratedExam_studentRegsCount(ctx context.Context, field graphql.CollectedField, obj *model.GeneratedExam) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GeneratedExam_studentRegsCount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.StudentRegsCount, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GeneratedExam_studentRegsCount(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GeneratedExam",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GeneratedExam_ntas(ctx context.Context, field graphql.CollectedField, obj *model.GeneratedExam) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GeneratedExam_ntas(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Ntas, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.NTA)
	fc.Result = res
	return ec.marshalNNTA2githubcomobcodeplexamsgographmodelNTA(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GeneratedExam_ntas(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GeneratedExam",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext_NTA_name(ctx, field)
			case "email":
				return ec.fieldContext_NTA_email(ctx, field)
			case "mtknr":
				return ec.fieldContext_NTA_mtknr(ctx, field)
			case "compensation":
				return ec.fieldContext_NTA_compensation(ctx, field)
			case "deltaDurationPercent":
				return ec.fieldContext_NTA_deltaDurationPercent(ctx, field)
			case "needsRoomAlone":
				return ec.fieldContext_NTA_needsRoomAlone(ctx, field)
			case "needsHardware":
				return ec.fieldContext_NTA_needsHardware(ctx, field)
			case "program":
				return ec.fieldContext_NTA_program(ctx, field)
			case "from":
				return ec.fieldContext_NTA_from(ctx, field)
			case "until":
				return ec.fieldContext_NTA_until(ctx, field)
			case "lastSemester":
				return ec.fieldContext_NTA_lastSemester(ctx, field)
			case "exams":
				return ec.fieldContext_NTA_exams(ctx, field)
			case "deactivated":
				return ec.fieldContext_NTA_deactivated(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type NTA", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _GeneratedExam_maxDuration(ctx context.Context, field graphql.CollectedField, obj *model.GeneratedExam) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GeneratedExam_maxDuration(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MaxDuration, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GeneratedExam_maxDuration(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GeneratedExam",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Invigilation_roomName(ctx context.Context, field graphql.CollectedField, obj *model.Invigilation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Invigilation_roomName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RoomName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Invigilation_roomName(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Invigilation",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Invigilation_duration(ctx context.Context, field graphql.CollectedField, obj *model.Invigilation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Invigilation_duration(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Duration, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Invigilation_duration(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Invigilation",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Invigilation_invigilatorID(ctx context.Context, field graphql.CollectedField, obj *model.Invigilation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Invigilation_invigilatorID(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.InvigilatorID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Invigilation_invigilatorID(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Invigilation",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Invigilation_slot(ctx context.Context, field graphql.CollectedField, obj *model.Invigilation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Invigilation_slot(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Slot, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Slot)
	fc.Result = res
	return ec.marshalNSlot2githubcomobcodeplexamsgographmodelSlot(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Invigilation_slot(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Invigilation",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "dayNumber":
				return ec.fieldContext_Slot_dayNumber(ctx, field)
			case "slotNumber":
				return ec.fieldContext_Slot_slotNumber(ctx, field)
			case "starttime":
				return ec.fieldContext_Slot_starttime(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Slot", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Invigilation_isReserve(ctx context.Context, field graphql.CollectedField, obj *model.Invigilation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Invigilation_isReserve(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsReserve, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Invigilation_isReserve(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Invigilation",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Invigilation_isSelfInvigilation(ctx context.Context, field graphql.CollectedField, obj *model.Invigilation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Invigilation_isSelfInvigilation(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsSelfInvigilation, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Invigilation_isSelfInvigilation(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Invigilation",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _InvigilationSlot_reserve(ctx context.Context, field graphql.CollectedField, obj *model.InvigilationSlot) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_InvigilationSlot_reserve(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Reserve, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.Teacher)
	fc.Result = res
	return ec.marshalOTeacher2githubcomobcodeplexamsgographmodelTeacher(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_InvigilationSlot_reserve(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "InvigilationSlot",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "shortname":
				return ec.fieldContext_Teacher_shortname(ctx, field)
			case "fullname":
				return ec.fieldContext_Teacher_fullname(ctx, field)
			case "isProf":
				return ec.fieldContext_Teacher_isProf(ctx, field)
			case "isLBA":
				return ec.fieldContext_Teacher_isLBA(ctx, field)
			case "isProfHC":
				return ec.fieldContext_Teacher_isProfHC(ctx, field)
			case "isStaff":
				return ec.fieldContext_Teacher_isStaff(ctx, field)
			case "lastSemester":
				return ec.fieldContext_Teacher_lastSemester(ctx, field)
			case "fk":
				return ec.fieldContext_Teacher_fk(ctx, field)
			case "id":
				return ec.fieldContext_Teacher_id(ctx, field)
			case "email":
				return ec.fieldContext_Teacher_email(ctx, field)
			case "isActive":
				return ec.fieldContext_Teacher_isActive(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Teacher", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _InvigilationSlot_roomsWithInvigilators(ctx context.Context, field graphql.CollectedField, obj *model.InvigilationSlot) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_InvigilationSlot_roomsWithInvigilators(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RoomsWithInvigilators, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.RoomWithInvigilator)
	fc.Result = res
	return ec.marshalNRoomWithInvigilator2githubcomobcodeplexamsgographmodelRoomWithInvigilator(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_InvigilationSlot_roomsWithInvigilators(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "InvigilationSlot",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext_RoomWithInvigilator_name(ctx, field)
			case "maxDuration":
				return ec.fieldContext_RoomWithInvigilator_maxDuration(ctx, field)
			case "studentCount":
				return ec.fieldContext_RoomWithInvigilator_studentCount(ctx, field)
			case "roomAndExams":
				return ec.fieldContext_RoomWithInvigilator_roomAndExams(ctx, field)
			case "invigilator":
				return ec.fieldContext_RoomWithInvigilator_invigilator(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type RoomWithInvigilator", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _InvigilationTodos_sumExamRooms(ctx context.Context, field graphql.CollectedField, obj *model.InvigilationTodos) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_InvigilationTodos_sumExamRooms(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SumExamRooms, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_InvigilationTodos_sumExamRooms(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "InvigilationTodos",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _InvigilationTodos_sumReserve(ctx context.Context, field graphql.CollectedField, obj *model.InvigilationTodos) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_InvigilationTodos_sumReserve(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SumReserve, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_InvigilationTodos_sumReserve(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "InvigilationTodos",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _InvigilationTodos_sumOtherContributions(ctx context.Context, field graphql.CollectedField, obj *model.InvigilationTodos) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_InvigilationTodos_sumOtherContributions(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SumOtherContributions, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_InvigilationTodos_sumOtherContributions(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "InvigilationTodos",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _InvigilationTodos_sumOtherContributionsOvertimeCutted(ctx context.Context, field graphql.CollectedField, obj *model.InvigilationTodos) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_InvigilationTodos_sumOtherContributionsOvertimeCutted(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SumOtherContributionsOvertimeCutted, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_InvigilationTodos_sumOtherContributionsOvertimeCutted(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "InvigilationTodos",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _InvigilationTodos_invigilatorCount(ctx context.Context, field graphql.CollectedField, obj *model.InvigilationTodos) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_InvigilationTodos_invigilatorCount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.InvigilatorCount, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_InvigilationTodos_invigilatorCount(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "InvigilationTodos",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _InvigilationTodos_todoPerInvigilator(ctx context.Context, field graphql.CollectedField, obj *model.InvigilationTodos) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_InvigilationTodos_todoPerInvigilator(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TodoPerInvigilator, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_InvigilationTodos_todoPerInvigilator(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "InvigilationTodos",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _InvigilationTodos_todoPerInvigilatorOvertimeCutted(ctx context.Context, field graphql.CollectedField, obj *model.InvigilationTodos) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_InvigilationTodos_todoPerInvigilatorOvertimeCutted(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TodoPerInvigilatorOvertimeCutted, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_InvigilationTodos_todoPerInvigilatorOvertimeCutted(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "InvigilationTodos",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _InvigilationTodos_invigilators(ctx context.Context, field graphql.CollectedField, obj *model.InvigilationTodos) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_InvigilationTodos_invigilators(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Invigilators, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.Invigilator)
	fc.Result = res
	return ec.marshalNInvigilator2githubcomobcodeplexamsgographmodelInvigilator(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_InvigilationTodos_invigilators(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "InvigilationTodos",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "teacher":
				return ec.fieldContext_Invigilator_teacher(ctx, field)
			case "requirements":
				return ec.fieldContext_Invigilator_requirements(ctx, field)
			case "todos":
				return ec.fieldContext_Invigilator_todos(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Invigilator", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Invigilator_teacher(ctx context.Context, field graphql.CollectedField, obj *model.Invigilator) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Invigilator_teacher(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Teacher, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Teacher)
	fc.Result = res
	return ec.marshalNTeacher2githubcomobcodeplexamsgographmodelTeacher(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Invigilator_teacher(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Invigilator",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "shortname":
				return ec.fieldContext_Teacher_shortname(ctx, field)
			case "fullname":
				return ec.fieldContext_Teacher_fullname(ctx, field)
			case "isProf":
				return ec.fieldContext_Teacher_isProf(ctx, field)
			case "isLBA":
				return ec.fieldContext_Teacher_isLBA(ctx, field)
			case "isProfHC":
				return ec.fieldContext_Teacher_isProfHC(ctx, field)
			case "isStaff":
				return ec.fieldContext_Teacher_isStaff(ctx, field)
			case "lastSemester":
				return ec.fieldContext_Teacher_lastSemester(ctx, field)
			case "fk":
				return ec.fieldContext_Teacher_fk(ctx, field)
			case "id":
				return ec.fieldContext_Teacher_id(ctx, field)
			case "email":
				return ec.fieldContext_Teacher_email(ctx, field)
			case "isActive":
				return ec.fieldContext_Teacher_isActive(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Teacher", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Invigilator_requirements(ctx context.Context, field graphql.CollectedField, obj *model.Invigilator) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Invigilator_requirements(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Requirements, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.InvigilatorRequirements)
	fc.Result = res
	return ec.marshalOInvigilatorRequirements2githubcomobcodeplexamsgographmodelInvigilatorRequirements(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Invigilator_requirements(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Invigilator",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "excludedDates":
				return ec.fieldContext_InvigilatorRequirements_excludedDates(ctx, field)
			case "excludedDays":
				return ec.fieldContext_InvigilatorRequirements_excludedDays(ctx, field)
			case "examDateTimes":
				return ec.fieldContext_InvigilatorRequirements_examDateTimes(ctx, field)
			case "examDays":
				return ec.fieldContext_InvigilatorRequirements_examDays(ctx, field)
			case "partTime":
				return ec.fieldContext_InvigilatorRequirements_partTime(ctx, field)
			case "oralExamsContribution":
				return ec.fieldContext_InvigilatorRequirements_oralExamsContribution(ctx, field)
			case "liveCodingContribution":
				return ec.fieldContext_InvigilatorRequirements_liveCodingContribution(ctx, field)
			case "masterContribution":
				return ec.fieldContext_InvigilatorRequirements_masterContribution(ctx, field)
			case "freeSemester":
				return ec.fieldContext_InvigilatorRequirements_freeSemester(ctx, field)
			case "overtimeLastSemester":
				return ec.fieldContext_InvigilatorRequirements_overtimeLastSemester(ctx, field)
			case "overtimeThisSemester":
				return ec.fieldContext_InvigilatorRequirements_overtimeThisSemester(ctx, field)
			case "allContributions":
				return ec.fieldContext_InvigilatorRequirements_allContributions(ctx, field)
			case "factor":
				return ec.fieldContext_InvigilatorRequirements_factor(ctx, field)
			case "onlyInSlots":
				return ec.fieldContext_InvigilatorRequirements_onlyInSlots(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type InvigilatorRequirements", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Invigilator_todos(ctx context.Context, field graphql.CollectedField, obj *model.Invigilator) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Invigilator_todos(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Todos, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.InvigilatorTodos)
	fc.Result = res
	return ec.marshalOInvigilatorTodos2githubcomobcodeplexamsgographmodelInvigilatorTodos(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Invigilator_todos(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Invigilator",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "totalMinutes":
				return ec.fieldContext_InvigilatorTodos_totalMinutes(ctx, field)
			case "doingMinutes":
				return ec.fieldContext_InvigilatorTodos_doingMinutes(ctx, field)
			case "enough":
				return ec.fieldContext_InvigilatorTodos_enough(ctx, field)
			case "invigilationDays":
				return ec.fieldContext_InvigilatorTodos_invigilationDays(ctx, field)
			case "invigilations":
				return ec.fieldContext_InvigilatorTodos_invigilations(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type InvigilatorTodos", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _InvigilatorRequirements_excludedDates(ctx context.Context, field graphql.CollectedField, obj *model.InvigilatorRequirements) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_InvigilatorRequirements_excludedDates(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ExcludedDates, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*time.Time)
	fc.Result = res
	return ec.marshalNTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_InvigilatorRequirements_excludedDates(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "InvigilatorRequirements",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _InvigilatorRequirements_excludedDays(ctx context.Context, field graphql.CollectedField, obj *model.InvigilatorRequirements) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_InvigilatorRequirements_excludedDays(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ExcludedDays, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_InvigilatorRequirements_excludedDays(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "InvigilatorRequirements",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _InvigilatorRequirements_examDateTimes(ctx context.Context, field graphql.CollectedField, obj *model.InvigilatorRequirements) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_InvigilatorRequirements_examDateTimes(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ExamDateTimes, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*time.Time)
	fc.Result = res
	return ec.marshalNTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_InvigilatorRequirements_examDateTimes(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "InvigilatorRequirements",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _InvigilatorRequirements_examDays(ctx context.Context, field graphql.CollectedField, obj *model.InvigilatorRequirements) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_InvigilatorRequirements_examDays(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ExamDays, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_InvigilatorRequirements_examDays(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "InvigilatorRequirements",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _InvigilatorRequirements_partTime(ctx context.Context, field graphql.CollectedField, obj *model.InvigilatorRequirements) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_InvigilatorRequirements_partTime(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PartTime, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalNFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_InvigilatorRequirements_partTime(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "InvigilatorRequirements",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _InvigilatorRequirements_oralExamsContribution(ctx context.Context, field graphql.CollectedField, obj *model.InvigilatorRequirements) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_InvigilatorRequirements_oralExamsContribution(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.OralExamsContribution, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_InvigilatorRequirements_oralExamsContribution(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "InvigilatorRequirements",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _InvigilatorRequirements_liveCodingContribution(ctx context.Context, field graphql.CollectedField, obj *model.InvigilatorRequirements) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_InvigilatorRequirements_liveCodingContribution(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.LiveCodingContribution, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_InvigilatorRequirements_liveCodingContribution(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "InvigilatorRequirements",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _InvigilatorRequirements_masterContribution(ctx context.Context, field graphql.CollectedField, obj *model.InvigilatorRequirements) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_InvigilatorRequirements_masterContribution(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MasterContribution, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_InvigilatorRequirements_masterContribution(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "InvigilatorRequirements",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _InvigilatorRequirements_freeSemester(ctx context.Context, field graphql.CollectedField, obj *model.InvigilatorRequirements) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_InvigilatorRequirements_freeSemester(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FreeSemester, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalNFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_InvigilatorRequirements_freeSemester(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "InvigilatorRequirements",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _InvigilatorRequirements_overtimeLastSemester(ctx context.Context, field graphql.CollectedField, obj *model.InvigilatorRequirements) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_InvigilatorRequirements_overtimeLastSemester(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.OvertimeLastSemester, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalNFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_InvigilatorRequirements_overtimeLastSemester(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "InvigilatorRequirements",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _InvigilatorRequirements_overtimeThisSemester(ctx context.Context, field graphql.CollectedField, obj *model.InvigilatorRequirements) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_InvigilatorRequirements_overtimeThisSemester(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.OvertimeThisSemester, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalNFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_InvigilatorRequirements_overtimeThisSemester(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "InvigilatorRequirements",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _InvigilatorRequirements_allContributions(ctx context.Context, field graphql.CollectedField, obj *model.InvigilatorRequirements) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_InvigilatorRequirements_allContributions(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AllContributions, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_InvigilatorRequirements_allContributions(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "InvigilatorRequirements",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _InvigilatorRequirements_factor(ctx context.Context, field graphql.CollectedField, obj *model.InvigilatorRequirements) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_InvigilatorRequirements_factor(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Factor, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalNFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_InvigilatorRequirements_factor(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "InvigilatorRequirements",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _InvigilatorRequirements_onlyInSlots(ctx context.Context, field graphql.CollectedField, obj *model.InvigilatorRequirements) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_InvigilatorRequirements_onlyInSlots(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.OnlyInSlots, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.Slot)
	fc.Result = res
	return ec.marshalNSlot2githubcomobcodeplexamsgographmodelSlot(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_InvigilatorRequirements_onlyInSlots(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "InvigilatorRequirements",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "dayNumber":
				return ec.fieldContext_Slot_dayNumber(ctx, field)
			case "slotNumber":
				return ec.fieldContext_Slot_slotNumber(ctx, field)
			case "starttime":
				return ec.fieldContext_Slot_starttime(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Slot", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _InvigilatorTodos_totalMinutes(ctx context.Context, field graphql.CollectedField, obj *model.InvigilatorTodos) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_InvigilatorTodos_totalMinutes(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TotalMinutes, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_InvigilatorTodos_totalMinutes(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "InvigilatorTodos",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _InvigilatorTodos_doingMinutes(ctx context.Context, field graphql.CollectedField, obj *model.InvigilatorTodos) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_InvigilatorTodos_doingMinutes(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DoingMinutes, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_InvigilatorTodos_doingMinutes(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "InvigilatorTodos",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _InvigilatorTodos_enough(ctx context.Context, field graphql.CollectedField, obj *model.InvigilatorTodos) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_InvigilatorTodos_enough(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Enough, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_InvigilatorTodos_enough(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "InvigilatorTodos",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _InvigilatorTodos_invigilationDays(ctx context.Context, field graphql.CollectedField, obj *model.InvigilatorTodos) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_InvigilatorTodos_invigilationDays(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.InvigilationDays, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_InvigilatorTodos_invigilationDays(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "InvigilatorTodos",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _InvigilatorTodos_invigilations(ctx context.Context, field graphql.CollectedField, obj *model.InvigilatorTodos) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_InvigilatorTodos_invigilations(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Invigilations, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.Invigilation)
	fc.Result = res
	return ec.marshalOInvigilation2githubcomobcodeplexamsgographmodelInvigilation(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_InvigilatorTodos_invigilations(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "InvigilatorTodos",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "roomName":
				return ec.fieldContext_Invigilation_roomName(ctx, field)
			case "duration":
				return ec.fieldContext_Invigilation_duration(ctx, field)
			case "invigilatorID":
				return ec.fieldContext_Invigilation_invigilatorID(ctx, field)
			case "slot":
				return ec.fieldContext_Invigilation_slot(ctx, field)
			case "isReserve":
				return ec.fieldContext_Invigilation_isReserve(ctx, field)
			case "isSelfInvigilation":
				return ec.fieldContext_Invigilation_isSelfInvigilation(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Invigilation", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _InvigilatorsForDay_want(ctx context.Context, field graphql.CollectedField, obj *model.InvigilatorsForDay) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_InvigilatorsForDay_want(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Want, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.Invigilator)
	fc.Result = res
	return ec.marshalNInvigilator2githubcomobcodeplexamsgographmodelInvigilator(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_InvigilatorsForDay_want(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "InvigilatorsForDay",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "teacher":
				return ec.fieldContext_Invigilator_teacher(ctx, field)
			case "requirements":
				return ec.fieldContext_Invigilator_requirements(ctx, field)
			case "todos":
				return ec.fieldContext_Invigilator_todos(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Invigilator", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _InvigilatorsForDay_can(ctx context.Context, field graphql.CollectedField, obj *model.InvigilatorsForDay) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_InvigilatorsForDay_can(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Can, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.Invigilator)
	fc.Result = res
	return ec.marshalNInvigilator2githubcomobcodeplexamsgographmodelInvigilator(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_InvigilatorsForDay_can(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "InvigilatorsForDay",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "teacher":
				return ec.fieldContext_Invigilator_teacher(ctx, field)
			case "requirements":
				return ec.fieldContext_Invigilator_requirements(ctx, field)
			case "todos":
				return ec.fieldContext_Invigilator_todos(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Invigilator", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _MucDaiExam_primussAncode(ctx context.Context, field graphql.CollectedField, obj *model.MucDaiExam) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MucDaiExam_primussAncode(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PrimussAncode, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MucDaiExam_primussAncode(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MucDaiExam",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MucDaiExam_module(ctx context.Context, field graphql.CollectedField, obj *model.MucDaiExam) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MucDaiExam_module(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Module, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MucDaiExam_module(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MucDaiExam",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MucDaiExam_mainExamer(ctx context.Context, field graphql.CollectedField, obj *model.MucDaiExam) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MucDaiExam_mainExamer(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MainExamer, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MucDaiExam_mainExamer(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MucDaiExam",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MucDaiExam_mainExamerID(ctx context.Context, field graphql.CollectedField, obj *model.MucDaiExam) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MucDaiExam_mainExamerID(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MainExamerID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MucDaiExam_mainExamerID(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MucDaiExam",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MucDaiExam_examType(ctx context.Context, field graphql.CollectedField, obj *model.MucDaiExam) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MucDaiExam_examType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ExamType, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MucDaiExam_examType(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MucDaiExam",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MucDaiExam_duration(ctx context.Context, field graphql.CollectedField, obj *model.MucDaiExam) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MucDaiExam_duration(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Duration, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MucDaiExam_duration(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MucDaiExam",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MucDaiExam_isRepeaterExam(ctx context.Context, field graphql.CollectedField, obj *model.MucDaiExam) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MucDaiExam_isRepeaterExam(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsRepeaterExam, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MucDaiExam_isRepeaterExam(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MucDaiExam",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MucDaiExam_program(ctx context.Context, field graphql.CollectedField, obj *model.MucDaiExam) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MucDaiExam_program(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Program, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MucDaiExam_program(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MucDaiExam",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MucDaiExam_plannedBy(ctx context.Context, field graphql.CollectedField, obj *model.MucDaiExam) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MucDaiExam_plannedBy(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PlannedBy, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MucDaiExam_plannedBy(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MucDaiExam",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_notPlannedByMe(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_notPlannedByMe(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().NotPlannedByMe(rctx, fc.Args["ancode"].(int))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_notPlannedByMe(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_notPlannedByMe_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_excludeDays(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_excludeDays(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().ExcludeDays(rctx, fc.Args["ancode"].(int), fc.Args["days"].([]string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_excludeDays(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_excludeDays_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_possibleDays(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_possibleDays(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().PossibleDays(rctx, fc.Args["ancode"].(int), fc.Args["days"].([]string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_possibleDays(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_possibleDays_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_sameSlot(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_sameSlot(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().SameSlot(rctx, fc.Args["ancode"].(int), fc.Args["ancodes"].([]int))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_sameSlot(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_sameSlot_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_placesWithSockets(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_placesWithSockets(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().PlacesWithSockets(rctx, fc.Args["ancode"].(int))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_placesWithSockets(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_placesWithSockets_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_lab(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_lab(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().Lab(rctx, fc.Args["ancode"].(int))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_lab(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_lab_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_exahm(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_exahm(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().Exahm(rctx, fc.Args["ancode"].(int))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_exahm(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_exahm_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_seb(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_seb(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().Seb(rctx, fc.Args["ancode"].(int))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_seb(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_seb_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_online(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_online(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().Online(rctx, fc.Args["ancode"].(int))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_online(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_online_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_addConstraints(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_addConstraints(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().AddConstraints(rctx, fc.Args["ancode"].(int), fc.Args["constraints"].(model.ConstraintsInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Constraints)
	fc.Result = res
	return ec.marshalNConstraints2githubcomobcodeplexamsgographmodelConstraints(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_addConstraints(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "ancode":
				return ec.fieldContext_Constraints_ancode(ctx, field)
			case "notPlannedByMe":
				return ec.fieldContext_Constraints_notPlannedByMe(ctx, field)
			case "excludeDays":
				return ec.fieldContext_Constraints_excludeDays(ctx, field)
			case "possibleDays":
				return ec.fieldContext_Constraints_possibleDays(ctx, field)
			case "fixedDay":
				return ec.fieldContext_Constraints_fixedDay(ctx, field)
			case "fixedTime":
				return ec.fieldContext_Constraints_fixedTime(ctx, field)
			case "sameSlot":
				return ec.fieldContext_Constraints_sameSlot(ctx, field)
			case "online":
				return ec.fieldContext_Constraints_online(ctx, field)
			case "roomConstraints":
				return ec.fieldContext_Constraints_roomConstraints(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Constraints", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_addConstraints_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_rmConstraints(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_rmConstraints(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().RmConstraints(rctx, fc.Args["ancode"].(int))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_rmConstraints(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_rmConstraints_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_addNTA(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_addNTA(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().AddNta(rctx, fc.Args["input"].(model.NTAInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.NTA)
	fc.Result = res
	return ec.marshalNNTA2githubcomobcodeplexamsgographmodelNTA(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_addNTA(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext_NTA_name(ctx, field)
			case "email":
				return ec.fieldContext_NTA_email(ctx, field)
			case "mtknr":
				return ec.fieldContext_NTA_mtknr(ctx, field)
			case "compensation":
				return ec.fieldContext_NTA_compensation(ctx, field)
			case "deltaDurationPercent":
				return ec.fieldContext_NTA_deltaDurationPercent(ctx, field)
			case "needsRoomAlone":
				return ec.fieldContext_NTA_needsRoomAlone(ctx, field)
			case "needsHardware":
				return ec.fieldContext_NTA_needsHardware(ctx, field)
			case "program":
				return ec.fieldContext_NTA_program(ctx, field)
			case "from":
				return ec.fieldContext_NTA_from(ctx, field)
			case "until":
				return ec.fieldContext_NTA_until(ctx, field)
			case "lastSemester":
				return ec.fieldContext_NTA_lastSemester(ctx, field)
			case "exams":
				return ec.fieldContext_NTA_exams(ctx, field)
			case "deactivated":
				return ec.fieldContext_NTA_deactivated(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type NTA", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_addNTA_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_addExamToSlot(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_addExamToSlot(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().AddExamToSlot(rctx, fc.Args["day"].(int), fc.Args["time"].(int), fc.Args["ancode"].(int))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_addExamToSlot(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_addExamToSlot_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_rmExamFromSlot(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_rmExamFromSlot(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().RmExamFromSlot(rctx, fc.Args["ancode"].(int))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_rmExamFromSlot(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_rmExamFromSlot_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_prePlanRoom(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_prePlanRoom(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().PrePlanRoom(rctx, fc.Args["ancode"].(int), fc.Args["roomName"].(string), fc.Args["reserve"].(bool), fc.Args["mtknr"].(*string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_prePlanRoom(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_prePlanRoom_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_zpaExamsToPlan(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_zpaExamsToPlan(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().ZpaExamsToPlan(rctx, fc.Args["input"].([]int))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.ZPAExam)
	fc.Result = res
	return ec.marshalNZPAExam2githubcomobcodeplexamsgographmodelZPAExam(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_zpaExamsToPlan(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "zpaID":
				return ec.fieldContext_ZPAExam_zpaID(ctx, field)
			case "semester":
				return ec.fieldContext_ZPAExam_semester(ctx, field)
			case "ancode":
				return ec.fieldContext_ZPAExam_ancode(ctx, field)
			case "module":
				return ec.fieldContext_ZPAExam_module(ctx, field)
			case "mainExamer":
				return ec.fieldContext_ZPAExam_mainExamer(ctx, field)
			case "mainExamerID":
				return ec.fieldContext_ZPAExam_mainExamerID(ctx, field)
			case "examType":
				return ec.fieldContext_ZPAExam_examType(ctx, field)
			case "examTypeFull":
				return ec.fieldContext_ZPAExam_examTypeFull(ctx, field)
			case "duration":
				return ec.fieldContext_ZPAExam_duration(ctx, field)
			case "isRepeaterExam":
				return ec.fieldContext_ZPAExam_isRepeaterExam(ctx, field)
			case "groups":
				return ec.fieldContext_ZPAExam_groups(ctx, field)
			case "primussAncodes":
				return ec.fieldContext_ZPAExam_primussAncodes(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ZPAExam", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_zpaExamsToPlan_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_addZpaExamToPlan(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_addZpaExamToPlan(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().AddZpaExamToPlan(rctx, fc.Args["ancode"].(int))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_addZpaExamToPlan(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_addZpaExamToPlan_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_rmZpaExamFromPlan(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_rmZpaExamFromPlan(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().RmZpaExamFromPlan(rctx, fc.Args["ancode"].(int))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_rmZpaExamFromPlan(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_rmZpaExamFromPlan_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _NTA_name(ctx context.Context, field graphql.CollectedField, obj *model.NTA) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_NTA_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_NTA_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "NTA",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _NTA_email(ctx context.Context, field graphql.CollectedField, obj *model.NTA) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_NTA_email(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Email, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_NTA_email(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "NTA",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _NTA_mtknr(ctx context.Context, field graphql.CollectedField, obj *model.NTA) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_NTA_mtknr(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Mtknr, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_NTA_mtknr(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "NTA",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _NTA_compensation(ctx context.Context, field graphql.CollectedField, obj *model.NTA) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_NTA_compensation(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Compensation, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_NTA_compensation(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "NTA",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _NTA_deltaDurationPercent(ctx context.Context, field graphql.CollectedField, obj *model.NTA) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_NTA_deltaDurationPercent(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeltaDurationPercent, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_NTA_deltaDurationPercent(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "NTA",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _NTA_needsRoomAlone(ctx context.Context, field graphql.CollectedField, obj *model.NTA) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_NTA_needsRoomAlone(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.NeedsRoomAlone, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_NTA_needsRoomAlone(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "NTA",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _NTA_needsHardware(ctx context.Context, field graphql.CollectedField, obj *model.NTA) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_NTA_needsHardware(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.NeedsHardware, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_NTA_needsHardware(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "NTA",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _NTA_program(ctx context.Context, field graphql.CollectedField, obj *model.NTA) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_NTA_program(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Program, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_NTA_program(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "NTA",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _NTA_from(ctx context.Context, field graphql.CollectedField, obj *model.NTA) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_NTA_from(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.From, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_NTA_from(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "NTA",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _NTA_until(ctx context.Context, field graphql.CollectedField, obj *model.NTA) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_NTA_until(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Until, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_NTA_until(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "NTA",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _NTA_lastSemester(ctx context.Context, field graphql.CollectedField, obj *model.NTA) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_NTA_lastSemester(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.LastSemester, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_NTA_lastSemester(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "NTA",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _NTA_exams(ctx context.Context, field graphql.CollectedField, obj *model.NTA) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_NTA_exams(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Exams, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.NTAExam)
	fc.Result = res
	return ec.marshalNNTAExam2githubcomobcodeplexamsgographmodelNTAExam(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_NTA_exams(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "NTA",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "semester":
				return ec.fieldContext_NTAExam_semester(ctx, field)
			case "ancode":
				return ec.fieldContext_NTAExam_ancode(ctx, field)
			case "module":
				return ec.fieldContext_NTAExam_module(ctx, field)
			case "mainExamer":
				return ec.fieldContext_NTAExam_mainExamer(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type NTAExam", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _NTA_deactivated(ctx context.Context, field graphql.CollectedField, obj *model.NTA) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_NTA_deactivated(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Deactivated, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_NTA_deactivated(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "NTA",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _NTAExam_semester(ctx context.Context, field graphql.CollectedField, obj *model.NTAExam) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_NTAExam_semester(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Semester, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_NTAExam_semester(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "NTAExam",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _NTAExam_ancode(ctx context.Context, field graphql.CollectedField, obj *model.NTAExam) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_NTAExam_ancode(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AnCode, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_NTAExam_ancode(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "NTAExam",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _NTAExam_module(ctx context.Context, field graphql.CollectedField, obj *model.NTAExam) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_NTAExam_module(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Module, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_NTAExam_module(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "NTAExam",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _NTAExam_mainExamer(ctx context.Context, field graphql.CollectedField, obj *model.NTAExam) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_NTAExam_mainExamer(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MainExamer, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_NTAExam_mainExamer(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "NTAExam",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _NTAWithRegs_nta(ctx context.Context, field graphql.CollectedField, obj *model.NTAWithRegs) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_NTAWithRegs_nta(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Nta, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.NTA)
	fc.Result = res
	return ec.marshalNNTA2githubcomobcodeplexamsgographmodelNTA(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_NTAWithRegs_nta(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "NTAWithRegs",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext_NTA_name(ctx, field)
			case "email":
				return ec.fieldContext_NTA_email(ctx, field)
			case "mtknr":
				return ec.fieldContext_NTA_mtknr(ctx, field)
			case "compensation":
				return ec.fieldContext_NTA_compensation(ctx, field)
			case "deltaDurationPercent":
				return ec.fieldContext_NTA_deltaDurationPercent(ctx, field)
			case "needsRoomAlone":
				return ec.fieldContext_NTA_needsRoomAlone(ctx, field)
			case "needsHardware":
				return ec.fieldContext_NTA_needsHardware(ctx, field)
			case "program":
				return ec.fieldContext_NTA_program(ctx, field)
			case "from":
				return ec.fieldContext_NTA_from(ctx, field)
			case "until":
				return ec.fieldContext_NTA_until(ctx, field)
			case "lastSemester":
				return ec.fieldContext_NTA_lastSemester(ctx, field)
			case "exams":
				return ec.fieldContext_NTA_exams(ctx, field)
			case "deactivated":
				return ec.fieldContext_NTA_deactivated(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type NTA", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _NTAWithRegs_regs(ctx context.Context, field graphql.CollectedField, obj *model.NTAWithRegs) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_NTAWithRegs_regs(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Regs, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.StudentRegsPerStudent)
	fc.Result = res
	return ec.marshalOStudentRegsPerStudent2githubcomobcodeplexamsgographmodelStudentRegsPerStudent(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_NTAWithRegs_regs(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "NTAWithRegs",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "student":
				return ec.fieldContext_StudentRegsPerStudent_student(ctx, field)
			case "ancodes":
				return ec.fieldContext_StudentRegsPerStudent_ancodes(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type StudentRegsPerStudent", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _NTAWithRegsByExam_exam(ctx context.Context, field graphql.CollectedField, obj *model.NTAWithRegsByExam) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_NTAWithRegsByExam_exam(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Exam, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.ZPAExam)
	fc.Result = res
	return ec.marshalNZPAExam2githubcomobcodeplexamsgographmodelZPAExam(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_NTAWithRegsByExam_exam(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "NTAWithRegsByExam",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "zpaID":
				return ec.fieldContext_ZPAExam_zpaID(ctx, field)
			case "semester":
				return ec.fieldContext_ZPAExam_semester(ctx, field)
			case "ancode":
				return ec.fieldContext_ZPAExam_ancode(ctx, field)
			case "module":
				return ec.fieldContext_ZPAExam_module(ctx, field)
			case "mainExamer":
				return ec.fieldContext_ZPAExam_mainExamer(ctx, field)
			case "mainExamerID":
				return ec.fieldContext_ZPAExam_mainExamerID(ctx, field)
			case "examType":
				return ec.fieldContext_ZPAExam_examType(ctx, field)
			case "examTypeFull":
				return ec.fieldContext_ZPAExam_examTypeFull(ctx, field)
			case "duration":
				return ec.fieldContext_ZPAExam_duration(ctx, field)
			case "isRepeaterExam":
				return ec.fieldContext_ZPAExam_isRepeaterExam(ctx, field)
			case "groups":
				return ec.fieldContext_ZPAExam_groups(ctx, field)
			case "primussAncodes":
				return ec.fieldContext_ZPAExam_primussAncodes(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ZPAExam", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _NTAWithRegsByExam_ntas(ctx context.Context, field graphql.CollectedField, obj *model.NTAWithRegsByExam) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_NTAWithRegsByExam_ntas(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Ntas, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.NTAWithRegs)
	fc.Result = res
	return ec.marshalONTAWithRegs2githubcomobcodeplexamsgographmodelNTAWithRegs(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_NTAWithRegsByExam_ntas(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "NTAWithRegsByExam",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "nta":
				return ec.fieldContext_NTAWithRegs_nta(ctx, field)
			case "regs":
				return ec.fieldContext_NTAWithRegs_regs(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type NTAWithRegs", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _NTAWithRegsByExamAndTeacher_teacher(ctx context.Context, field graphql.CollectedField, obj *model.NTAWithRegsByExamAndTeacher) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_NTAWithRegsByExamAndTeacher_teacher(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Teacher, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Teacher)
	fc.Result = res
	return ec.marshalNTeacher2githubcomobcodeplexamsgographmodelTeacher(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_NTAWithRegsByExamAndTeacher_teacher(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "NTAWithRegsByExamAndTeacher",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "shortname":
				return ec.fieldContext_Teacher_shortname(ctx, field)
			case "fullname":
				return ec.fieldContext_Teacher_fullname(ctx, field)
			case "isProf":
				return ec.fieldContext_Teacher_isProf(ctx, field)
			case "isLBA":
				return ec.fieldContext_Teacher_isLBA(ctx, field)
			case "isProfHC":
				return ec.fieldContext_Teacher_isProfHC(ctx, field)
			case "isStaff":
				return ec.fieldContext_Teacher_isStaff(ctx, field)
			case "lastSemester":
				return ec.fieldContext_Teacher_lastSemester(ctx, field)
			case "fk":
				return ec.fieldContext_Teacher_fk(ctx, field)
			case "id":
				return ec.fieldContext_Teacher_id(ctx, field)
			case "email":
				return ec.fieldContext_Teacher_email(ctx, field)
			case "isActive":
				return ec.fieldContext_Teacher_isActive(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Teacher", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _NTAWithRegsByExamAndTeacher_exams(ctx context.Context, field graphql.CollectedField, obj *model.NTAWithRegsByExamAndTeacher) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_NTAWithRegsByExamAndTeacher_exams(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Exams, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.NTAWithRegsByExam)
	fc.Result = res
	return ec.marshalONTAWithRegsByExam2githubcomobcodeplexamsgographmodelNTAWithRegsByExam(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_NTAWithRegsByExamAndTeacher_exams(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "NTAWithRegsByExamAndTeacher",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "exam":
				return ec.fieldContext_NTAWithRegsByExam_exam(ctx, field)
			case "ntas":
				return ec.fieldContext_NTAWithRegsByExam_ntas(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type NTAWithRegsByExam", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _PlanEntry_dayNumber(ctx context.Context, field graphql.CollectedField, obj *model.PlanEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PlanEntry_dayNumber(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DayNumber, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PlanEntry_dayNumber(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PlanEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PlanEntry_slotNumber(ctx context.Context, field graphql.CollectedField, obj *model.PlanEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PlanEntry_slotNumber(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SlotNumber, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PlanEntry_slotNumber(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PlanEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PlanEntry_starttime(ctx context.Context, field graphql.CollectedField, obj *model.PlanEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PlanEntry_starttime(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.PlanEntry().Starttime(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalNTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PlanEntry_starttime(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PlanEntry",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PlanEntry_ancode(ctx context.Context, field graphql.CollectedField, obj *model.PlanEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PlanEntry_ancode(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Ancode, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PlanEntry_ancode(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PlanEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PlanEntry_locked(ctx context.Context, field graphql.CollectedField, obj *model.PlanEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PlanEntry_locked(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Locked, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PlanEntry_locked(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PlanEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PlannedExam_ancode(ctx context.Context, field graphql.CollectedField, obj *model.PlannedExam) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PlannedExam_ancode(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Ancode, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PlannedExam_ancode(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PlannedExam",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PlannedExam_zpaExam(ctx context.Context, field graphql.CollectedField, obj *model.PlannedExam) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PlannedExam_zpaExam(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ZpaExam, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.ZPAExam)
	fc.Result = res
	return ec.marshalNZPAExam2githubcomobcodeplexamsgographmodelZPAExam(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PlannedExam_zpaExam(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PlannedExam",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "zpaID":
				return ec.fieldContext_ZPAExam_zpaID(ctx, field)
			case "semester":
				return ec.fieldContext_ZPAExam_semester(ctx, field)
			case "ancode":
				return ec.fieldContext_ZPAExam_ancode(ctx, field)
			case "module":
				return ec.fieldContext_ZPAExam_module(ctx, field)
			case "mainExamer":
				return ec.fieldContext_ZPAExam_mainExamer(ctx, field)
			case "mainExamerID":
				return ec.fieldContext_ZPAExam_mainExamerID(ctx, field)
			case "examType":
				return ec.fieldContext_ZPAExam_examType(ctx, field)
			case "examTypeFull":
				return ec.fieldContext_ZPAExam_examTypeFull(ctx, field)
			case "duration":
				return ec.fieldContext_ZPAExam_duration(ctx, field)
			case "isRepeaterExam":
				return ec.fieldContext_ZPAExam_isRepeaterExam(ctx, field)
			case "groups":
				return ec.fieldContext_ZPAExam_groups(ctx, field)
			case "primussAncodes":
				return ec.fieldContext_ZPAExam_primussAncodes(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ZPAExam", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _PlannedExam_mainExamer(ctx context.Context, field graphql.CollectedField, obj *model.PlannedExam) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PlannedExam_mainExamer(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.PlannedExam().MainExamer(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Teacher)
	fc.Result = res
	return ec.marshalNTeacher2githubcomobcodeplexamsgographmodelTeacher(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PlannedExam_mainExamer(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PlannedExam",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "shortname":
				return ec.fieldContext_Teacher_shortname(ctx, field)
			case "fullname":
				return ec.fieldContext_Teacher_fullname(ctx, field)
			case "isProf":
				return ec.fieldContext_Teacher_isProf(ctx, field)
			case "isLBA":
				return ec.fieldContext_Teacher_isLBA(ctx, field)
			case "isProfHC":
				return ec.fieldContext_Teacher_isProfHC(ctx, field)
			case "isStaff":
				return ec.fieldContext_Teacher_isStaff(ctx, field)
			case "lastSemester":
				return ec.fieldContext_Teacher_lastSemester(ctx, field)
			case "fk":
				return ec.fieldContext_Teacher_fk(ctx, field)
			case "id":
				return ec.fieldContext_Teacher_id(ctx, field)
			case "email":
				return ec.fieldContext_Teacher_email(ctx, field)
			case "isActive":
				return ec.fieldContext_Teacher_isActive(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Teacher", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _PlannedExam_primussExams(ctx context.Context, field graphql.CollectedField, obj *model.PlannedExam) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PlannedExam_primussExams(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PrimussExams, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.EnhancedPrimussExam)
	fc.Result = res
	return ec.marshalNEnhancedPrimussExam2githubcomobcodeplexamsgographmodelEnhancedPrimussExam(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PlannedExam_primussExams(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PlannedExam",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "exam":
				return ec.fieldContext_EnhancedPrimussExam_exam(ctx, field)
			case "studentRegs":
				return ec.fieldContext_EnhancedPrimussExam_studentRegs(ctx, field)
			case "conflicts":
				return ec.fieldContext_EnhancedPrimussExam_conflicts(ctx, field)
			case "ntas":
				return ec.fieldContext_EnhancedPrimussExam_ntas(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type EnhancedPrimussExam", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _PlannedExam_constraints(ctx context.Context, field graphql.CollectedField, obj *model.PlannedExam) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PlannedExam_constraints(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Constraints, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.Constraints)
	fc.Result = res
	return ec.marshalOConstraints2githubcomobcodeplexamsgographmodelConstraints(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PlannedExam_constraints(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PlannedExam",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "ancode":
				return ec.fieldContext_Constraints_ancode(ctx, field)
			case "notPlannedByMe":
				return ec.fieldContext_Constraints_notPlannedByMe(ctx, field)
			case "excludeDays":
				return ec.fieldContext_Constraints_excludeDays(ctx, field)
			case "possibleDays":
				return ec.fieldContext_Constraints_possibleDays(ctx, field)
			case "fixedDay":
				return ec.fieldContext_Constraints_fixedDay(ctx, field)
			case "fixedTime":
				return ec.fieldContext_Constraints_fixedTime(ctx, field)
			case "sameSlot":
				return ec.fieldContext_Constraints_sameSlot(ctx, field)
			case "online":
				return ec.fieldContext_Constraints_online(ctx, field)
			case "roomConstraints":
				return ec.fieldContext_Constraints_roomConstraints(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Constraints", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _PlannedExam_conflicts(ctx context.Context, field graphql.CollectedField, obj *model.PlannedExam) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PlannedExam_conflicts(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Conflicts, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.ZPAConflict)
	fc.Result = res
	return ec.marshalNZPAConflict2githubcomobcodeplexamsgographmodelZPAConflict(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PlannedExam_conflicts(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PlannedExam",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "ancode":
				return ec.fieldContext_ZPAConflict_ancode(ctx, field)
			case "numberOfStuds":
				return ec.fieldContext_ZPAConflict_numberOfStuds(ctx, field)
			case "primussAncodes":
				return ec.fieldContext_ZPAConflict_primussAncodes(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ZPAConflict", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _PlannedExam_studentRegsCount(ctx context.Context, field graphql.CollectedField, obj *model.PlannedExam) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PlannedExam_studentRegsCount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.StudentRegsCount, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PlannedExam_studentRegsCount(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PlannedExam",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PlannedExam_ntas(ctx context.Context, field graphql.CollectedField, obj *model.PlannedExam) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PlannedExam_ntas(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Ntas, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.NTA)
	fc.Result = res
	return ec.marshalNNTA2githubcomobcodeplexamsgographmodelNTA(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PlannedExam_ntas(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PlannedExam",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext_NTA_name(ctx, field)
			case "email":
				return ec.fieldContext_NTA_email(ctx, field)
			case "mtknr":
				return ec.fieldContext_NTA_mtknr(ctx, field)
			case "compensation":
				return ec.fieldContext_NTA_compensation(ctx, field)
			case "deltaDurationPercent":
				return ec.fieldContext_NTA_deltaDurationPercent(ctx, field)
			case "needsRoomAlone":
				return ec.fieldContext_NTA_needsRoomAlone(ctx, field)
			case "needsHardware":
				return ec.fieldContext_NTA_needsHardware(ctx, field)
			case "program":
				return ec.fieldContext_NTA_program(ctx, field)
			case "from":
				return ec.fieldContext_NTA_from(ctx, field)
			case "until":
				return ec.fieldContext_NTA_until(ctx, field)
			case "lastSemester":
				return ec.fieldContext_NTA_lastSemester(ctx, field)
			case "exams":
				return ec.fieldContext_NTA_exams(ctx, field)
			case "deactivated":
				return ec.fieldContext_NTA_deactivated(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type NTA", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _PlannedExam_maxDuration(ctx context.Context, field graphql.CollectedField, obj *model.PlannedExam) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PlannedExam_maxDuration(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MaxDuration, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PlannedExam_maxDuration(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PlannedExam",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PlannedExam_planEntry(ctx context.Context, field graphql.CollectedField, obj *model.PlannedExam) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PlannedExam_planEntry(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PlanEntry, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.PlanEntry)
	fc.Result = res
	return ec.marshalOPlanEntry2githubcomobcodeplexamsgographmodelPlanEntry(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PlannedExam_planEntry(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PlannedExam",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "dayNumber":
				return ec.fieldContext_PlanEntry_dayNumber(ctx, field)
			case "slotNumber":
				return ec.fieldContext_PlanEntry_slotNumber(ctx, field)
			case "starttime":
				return ec.fieldContext_PlanEntry_starttime(ctx, field)
			case "ancode":
				return ec.fieldContext_PlanEntry_ancode(ctx, field)
			case "locked":
				return ec.fieldContext_PlanEntry_locked(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PlanEntry", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _PlannedExam_plannedRooms(ctx context.Context, field graphql.CollectedField, obj *model.PlannedExam) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PlannedExam_plannedRooms(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PlannedRooms, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.PlannedRoom)
	fc.Result = res
	return ec.marshalOPlannedRoom2githubcomobcodeplexamsgographmodelPlannedRoom(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PlannedExam_plannedRooms(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PlannedExam",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "day":
				return ec.fieldContext_PlannedRoom_day(ctx, field)
			case "slot":
				return ec.fieldContext_PlannedRoom_slot(ctx, field)
			case "room":
				return ec.fieldContext_PlannedRoom_room(ctx, field)
			case "ancode":
				return ec.fieldContext_PlannedRoom_ancode(ctx, field)
			case "duration":
				return ec.fieldContext_PlannedRoom_duration(ctx, field)
			case "handicap":
				return ec.fieldContext_PlannedRoom_handicap(ctx, field)
			case "handicapRoomAlone":
				return ec.fieldContext_PlannedRoom_handicapRoomAlone(ctx, field)
			case "reserve":
				return ec.fieldContext_PlannedRoom_reserve(ctx, field)
			case "studentsInRoom":
				return ec.fieldContext_PlannedRoom_studentsInRoom(ctx, field)
			case "ntaMtknr":
				return ec.fieldContext_PlannedRoom_ntaMtknr(ctx, field)
			case "prePlanned":
				return ec.fieldContext_PlannedRoom_prePlanned(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PlannedRoom", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _PlannedRoom_day(ctx context.Context, field graphql.CollectedField, obj *model.PlannedRoom) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PlannedRoom_day(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Day, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PlannedRoom_day(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PlannedRoom",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PlannedRoom_slot(ctx context.Context, field graphql.CollectedField, obj *model.PlannedRoom) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PlannedRoom_slot(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Slot, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PlannedRoom_slot(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PlannedRoom",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PlannedRoom_room(ctx context.Context, field graphql.CollectedField, obj *model.PlannedRoom) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PlannedRoom_room(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.PlannedRoom().Room(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Room)
	fc.Result = res
	return ec.marshalNRoom2githubcomobcodeplexamsgographmodelRoom(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PlannedRoom_room(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PlannedRoom",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext_Room_name(ctx, field)
			case "seats":
				return ec.fieldContext_Room_seats(ctx, field)
			case "handicap":
				return ec.fieldContext_Room_handicap(ctx, field)
			case "lab":
				return ec.fieldContext_Room_lab(ctx, field)
			case "placesWithSocket":
				return ec.fieldContext_Room_placesWithSocket(ctx, field)
			case "needsRequest":
				return ec.fieldContext_Room_needsRequest(ctx, field)
			case "exahm":
				return ec.fieldContext_Room_exahm(ctx, field)
			case "seb":
				return ec.fieldContext_Room_seb(ctx, field)
			case "sebSeats":
				return ec.fieldContext_Room_sebSeats(ctx, field)
			case "hmebSeats":
				return ec.fieldContext_Room_hmebSeats(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Room", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _PlannedRoom_ancode(ctx context.Context, field graphql.CollectedField, obj *model.PlannedRoom) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PlannedRoom_ancode(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Ancode, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PlannedRoom_ancode(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PlannedRoom",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PlannedRoom_duration(ctx context.Context, field graphql.CollectedField, obj *model.PlannedRoom) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PlannedRoom_duration(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Duration, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PlannedRoom_duration(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PlannedRoom",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PlannedRoom_handicap(ctx context.Context, field graphql.CollectedField, obj *model.PlannedRoom) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PlannedRoom_handicap(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Handicap, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PlannedRoom_handicap(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PlannedRoom",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PlannedRoom_handicapRoomAlone(ctx context.Context, field graphql.CollectedField, obj *model.PlannedRoom) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PlannedRoom_handicapRoomAlone(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.HandicapRoomAlone, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PlannedRoom_handicapRoomAlone(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PlannedRoom",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PlannedRoom_reserve(ctx context.Context, field graphql.CollectedField, obj *model.PlannedRoom) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PlannedRoom_reserve(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Reserve, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PlannedRoom_reserve(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PlannedRoom",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PlannedRoom_studentsInRoom(ctx context.Context, field graphql.CollectedField, obj *model.PlannedRoom) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PlannedRoom_studentsInRoom(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.StudentsInRoom, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PlannedRoom_studentsInRoom(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PlannedRoom",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PlannedRoom_ntaMtknr(ctx context.Context, field graphql.CollectedField, obj *model.PlannedRoom) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PlannedRoom_ntaMtknr(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.NtaMtknr, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PlannedRoom_ntaMtknr(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PlannedRoom",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PlannedRoom_prePlanned(ctx context.Context, field graphql.CollectedField, obj *model.PlannedRoom) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PlannedRoom_prePlanned(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PrePlanned, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PlannedRoom_prePlanned(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PlannedRoom",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PreExam_zpaExam(ctx context.Context, field graphql.CollectedField, obj *model.PreExam) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PreExam_zpaExam(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ZpaExam, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.ZPAExam)
	fc.Result = res
	return ec.marshalNZPAExam2githubcomobcodeplexamsgographmodelZPAExam(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PreExam_zpaExam(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PreExam",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "zpaID":
				return ec.fieldContext_ZPAExam_zpaID(ctx, field)
			case "semester":
				return ec.fieldContext_ZPAExam_semester(ctx, field)
			case "ancode":
				return ec.fieldContext_ZPAExam_ancode(ctx, field)
			case "module":
				return ec.fieldContext_ZPAExam_module(ctx, field)
			case "mainExamer":
				return ec.fieldContext_ZPAExam_mainExamer(ctx, field)
			case "mainExamerID":
				return ec.fieldContext_ZPAExam_mainExamerID(ctx, field)
			case "examType":
				return ec.fieldContext_ZPAExam_examType(ctx, field)
			case "examTypeFull":
				return ec.fieldContext_ZPAExam_examTypeFull(ctx, field)
			case "duration":
				return ec.fieldContext_ZPAExam_duration(ctx, field)
			case "isRepeaterExam":
				return ec.fieldContext_ZPAExam_isRepeaterExam(ctx, field)
			case "groups":
				return ec.fieldContext_ZPAExam_groups(ctx, field)
			case "primussAncodes":
				return ec.fieldContext_ZPAExam_primussAncodes(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ZPAExam", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _PreExam_constraints(ctx context.Context, field graphql.CollectedField, obj *model.PreExam) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PreExam_constraints(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Constraints, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.Constraints)
	fc.Result = res
	return ec.marshalOConstraints2githubcomobcodeplexamsgographmodelConstraints(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PreExam_constraints(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PreExam",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "ancode":
				return ec.fieldContext_Constraints_ancode(ctx, field)
			case "notPlannedByMe":
				return ec.fieldContext_Constraints_notPlannedByMe(ctx, field)
			case "excludeDays":
				return ec.fieldContext_Constraints_excludeDays(ctx, field)
			case "possibleDays":
				return ec.fieldContext_Constraints_possibleDays(ctx, field)
			case "fixedDay":
				return ec.fieldContext_Constraints_fixedDay(ctx, field)
			case "fixedTime":
				return ec.fieldContext_Constraints_fixedTime(ctx, field)
			case "sameSlot":
				return ec.fieldContext_Constraints_sameSlot(ctx, field)
			case "online":
				return ec.fieldContext_Constraints_online(ctx, field)
			case "roomConstraints":
				return ec.fieldContext_Constraints_roomConstraints(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Constraints", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _PreExam_planEntry(ctx context.Context, field graphql.CollectedField, obj *model.PreExam) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PreExam_planEntry(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PlanEntry, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.PlanEntry)
	fc.Result = res
	return ec.marshalOPlanEntry2githubcomobcodeplexamsgographmodelPlanEntry(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PreExam_planEntry(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PreExam",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "dayNumber":
				return ec.fieldContext_PlanEntry_dayNumber(ctx, field)
			case "slotNumber":
				return ec.fieldContext_PlanEntry_slotNumber(ctx, field)
			case "starttime":
				return ec.fieldContext_PlanEntry_starttime(ctx, field)
			case "ancode":
				return ec.fieldContext_PlanEntry_ancode(ctx, field)
			case "locked":
				return ec.fieldContext_PlanEntry_locked(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PlanEntry", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _PrePlannedRoom_ancode(ctx context.Context, field graphql.CollectedField, obj *model.PrePlannedRoom) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PrePlannedRoom_ancode(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Ancode, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PrePlannedRoom_ancode(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PrePlannedRoom",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PrePlannedRoom_roomName(ctx context.Context, field graphql.CollectedField, obj *model.PrePlannedRoom) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PrePlannedRoom_roomName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RoomName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PrePlannedRoom_roomName(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PrePlannedRoom",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PrePlannedRoom_mtknr(ctx context.Context, field graphql.CollectedField, obj *model.PrePlannedRoom) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PrePlannedRoom_mtknr(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Mtknr, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PrePlannedRoom_mtknr(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PrePlannedRoom",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PrePlannedRoom_reserve(ctx context.Context, field graphql.CollectedField, obj *model.PrePlannedRoom) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PrePlannedRoom_reserve(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Reserve, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PrePlannedRoom_reserve(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PrePlannedRoom",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PrimussExam_ancode(ctx context.Context, field graphql.CollectedField, obj *model.PrimussExam) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PrimussExam_ancode(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AnCode, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PrimussExam_ancode(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PrimussExam",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PrimussExam_module(ctx context.Context, field graphql.CollectedField, obj *model.PrimussExam) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PrimussExam_module(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Module, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PrimussExam_module(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PrimussExam",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PrimussExam_mainExamer(ctx context.Context, field graphql.CollectedField, obj *model.PrimussExam) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PrimussExam_mainExamer(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MainExamer, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PrimussExam_mainExamer(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PrimussExam",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PrimussExam_program(ctx context.Context, field graphql.CollectedField, obj *model.PrimussExam) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PrimussExam_program(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Program, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PrimussExam_program(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PrimussExam",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PrimussExam_examType(ctx context.Context, field graphql.CollectedField, obj *model.PrimussExam) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PrimussExam_examType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ExamType, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PrimussExam_examType(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PrimussExam",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PrimussExam_presence(ctx context.Context, field graphql.CollectedField, obj *model.PrimussExam) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PrimussExam_presence(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Presence, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PrimussExam_presence(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PrimussExam",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PrimussExamAncode_ancode(ctx context.Context, field graphql.CollectedField, obj *model.PrimussExamAncode) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PrimussExamAncode_ancode(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Ancode, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PrimussExamAncode_ancode(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PrimussExamAncode",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PrimussExamAncode_program(ctx context.Context, field graphql.CollectedField, obj *model.PrimussExamAncode) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PrimussExamAncode_program(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Program, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PrimussExamAncode_program(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PrimussExamAncode",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PrimussExamAncode_numberOfStuds(ctx context.Context, field graphql.CollectedField, obj *model.PrimussExamAncode) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PrimussExamAncode_numberOfStuds(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.NumberOfStuds, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PrimussExamAncode_numberOfStuds(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PrimussExamAncode",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PrimussExamByProgram_program(ctx context.Context, field graphql.CollectedField, obj *model.PrimussExamByProgram) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PrimussExamByProgram_program(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Program, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PrimussExamByProgram_program(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PrimussExamByProgram",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PrimussExamByProgram_exams(ctx context.Context, field graphql.CollectedField, obj *model.PrimussExamByProgram) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PrimussExamByProgram_exams(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Exams, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.PrimussExamWithCount)
	fc.Result = res
	return ec.marshalNPrimussExamWithCount2githubcomobcodeplexamsgographmodelPrimussExamWithCount(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PrimussExamByProgram_exams(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PrimussExamByProgram",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "ancode":
				return ec.fieldContext_PrimussExamWithCount_ancode(ctx, field)
			case "module":
				return ec.fieldContext_PrimussExamWithCount_module(ctx, field)
			case "mainExamer":
				return ec.fieldContext_PrimussExamWithCount_mainExamer(ctx, field)
			case "program":
				return ec.fieldContext_PrimussExamWithCount_program(ctx, field)
			case "examType":
				return ec.fieldContext_PrimussExamWithCount_examType(ctx, field)
			case "presence":
				return ec.fieldContext_PrimussExamWithCount_presence(ctx, field)
			case "studentRegsCount":
				return ec.fieldContext_PrimussExamWithCount_studentRegsCount(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PrimussExamWithCount", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _PrimussExamWithCount_ancode(ctx context.Context, field graphql.CollectedField, obj *model.PrimussExamWithCount) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PrimussExamWithCount_ancode(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Ancode, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PrimussExamWithCount_ancode(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PrimussExamWithCount",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PrimussExamWithCount_module(ctx context.Context, field graphql.CollectedField, obj *model.PrimussExamWithCount) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PrimussExamWithCount_module(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Module, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PrimussExamWithCount_module(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PrimussExamWithCount",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PrimussExamWithCount_mainExamer(ctx context.Context, field graphql.CollectedField, obj *model.PrimussExamWithCount) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PrimussExamWithCount_mainExamer(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MainExamer, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PrimussExamWithCount_mainExamer(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PrimussExamWithCount",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PrimussExamWithCount_program(ctx context.Context, field graphql.CollectedField, obj *model.PrimussExamWithCount) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PrimussExamWithCount_program(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Program, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PrimussExamWithCount_program(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PrimussExamWithCount",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PrimussExamWithCount_examType(ctx context.Context, field graphql.CollectedField, obj *model.PrimussExamWithCount) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PrimussExamWithCount_examType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ExamType, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PrimussExamWithCount_examType(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PrimussExamWithCount",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PrimussExamWithCount_presence(ctx context.Context, field graphql.CollectedField, obj *model.PrimussExamWithCount) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PrimussExamWithCount_presence(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Presence, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PrimussExamWithCount_presence(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PrimussExamWithCount",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PrimussExamWithCount_studentRegsCount(ctx context.Context, field graphql.CollectedField, obj *model.PrimussExamWithCount) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PrimussExamWithCount_studentRegsCount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.StudentRegsCount, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PrimussExamWithCount_studentRegsCount(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PrimussExamWithCount",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_allSemesterNames(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_allSemesterNames(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().AllSemesterNames(rctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.Semester)
	fc.Result = res
	return ec.marshalNSemester2githubcomobcodeplexamsgographmodelSemester(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_allSemesterNames(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Semester_id(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Semester", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_semester(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_semester(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Semester(rctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Semester)
	fc.Result = res
	return ec.marshalNSemester2githubcomobcodeplexamsgographmodelSemester(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_semester(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Semester_id(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Semester", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_semesterConfig(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_semesterConfig(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().SemesterConfig(rctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.SemesterConfig)
	fc.Result = res
	return ec.marshalNSemesterConfig2githubcomobcodeplexamsgographmodelSemesterConfig(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_semesterConfig(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "days":
				return ec.fieldContext_SemesterConfig_days(ctx, field)
			case "starttimes":
				return ec.fieldContext_SemesterConfig_starttimes(ctx, field)
			case "slots":
				return ec.fieldContext_SemesterConfig_slots(ctx, field)
			case "goSlotsRaw":
				return ec.fieldContext_SemesterConfig_goSlotsRaw(ctx, field)
			case "goSlots":
				return ec.fieldContext_SemesterConfig_goSlots(ctx, field)
			case "goDay0":
				return ec.fieldContext_SemesterConfig_goDay0(ctx, field)
			case "forbiddenSlots":
				return ec.fieldContext_SemesterConfig_forbiddenSlots(ctx, field)
			case "from":
				return ec.fieldContext_SemesterConfig_from(ctx, field)
			case "fromFK07":
				return ec.fieldContext_SemesterConfig_fromFK07(ctx, field)
			case "until":
				return ec.fieldContext_SemesterConfig_until(ctx, field)
			case "emails":
				return ec.fieldContext_SemesterConfig_emails(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type SemesterConfig", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_constraintForAncode(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_constraintForAncode(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().ConstraintForAncode(rctx, fc.Args["ancode"].(int))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.Constraints)
	fc.Result = res
	return ec.marshalOConstraints2githubcomobcodeplexamsgographmodelConstraints(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_constraintForAncode(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "ancode":
				return ec.fieldContext_Constraints_ancode(ctx, field)
			case "notPlannedByMe":
				return ec.fieldContext_Constraints_notPlannedByMe(ctx, field)
			case "excludeDays":
				return ec.fieldContext_Constraints_excludeDays(ctx, field)
			case "possibleDays":
				return ec.fieldContext_Constraints_possibleDays(ctx, field)
			case "fixedDay":
				return ec.fieldContext_Constraints_fixedDay(ctx, field)
			case "fixedTime":
				return ec.fieldContext_Constraints_fixedTime(ctx, field)
			case "sameSlot":
				return ec.fieldContext_Constraints_sameSlot(ctx, field)
			case "online":
				return ec.fieldContext_Constraints_online(ctx, field)
			case "roomConstraints":
				return ec.fieldContext_Constraints_roomConstraints(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Constraints", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_constraintForAncode_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_zpaExamsToPlanWithConstraints(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_zpaExamsToPlanWithConstraints(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().ZpaExamsToPlanWithConstraints(rctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.ZPAExamWithConstraints)
	fc.Result = res
	return ec.marshalNZPAExamWithConstraints2githubcomobcodeplexamsgographmodelZPAExamWithConstraints(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_zpaExamsToPlanWithConstraints(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "zpaExam":
				return ec.fieldContext_ZPAExamWithConstraints_zpaExam(ctx, field)
			case "constraints":
				return ec.fieldContext_ZPAExamWithConstraints_constraints(ctx, field)
			case "planEntry":
				return ec.fieldContext_ZPAExamWithConstraints_planEntry(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ZPAExamWithConstraints", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_connectedExam(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_connectedExam(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().ConnectedExam(rctx, fc.Args["ancode"].(int))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.ConnectedExam)
	fc.Result = res
	return ec.marshalOConnectedExam2githubcomobcodeplexamsgographmodelConnectedExam(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_connectedExam(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "zpaExam":
				return ec.fieldContext_ConnectedExam_zpaExam(ctx, field)
			case "primussExams":
				return ec.fieldContext_ConnectedExam_primussExams(ctx, field)
			case "otherPrimussExams":
				return ec.fieldContext_ConnectedExam_otherPrimussExams(ctx, field)
			case "errors":
				return ec.fieldContext_ConnectedExam_errors(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ConnectedExam", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_connectedExam_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_connectedExams(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_connectedExams(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().ConnectedExams(rctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.ConnectedExam)
	fc.Result = res
	return ec.marshalNConnectedExam2githubcomobcodeplexamsgographmodelConnectedExam(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_connectedExams(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "zpaExam":
				return ec.fieldContext_ConnectedExam_zpaExam(ctx, field)
			case "primussExams":
				return ec.fieldContext_ConnectedExam_primussExams(ctx, field)
			case "otherPrimussExams":
				return ec.fieldContext_ConnectedExam_otherPrimussExams(ctx, field)
			case "errors":
				return ec.fieldContext_ConnectedExam_errors(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ConnectedExam", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_generatedExams(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_generatedExams(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().GeneratedExams(rctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.GeneratedExam)
	fc.Result = res
	return ec.marshalNGeneratedExam2githubcomobcodeplexamsgographmodelGeneratedExam(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_generatedExams(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "ancode":
				return ec.fieldContext_GeneratedExam_ancode(ctx, field)
			case "zpaExam":
				return ec.fieldContext_GeneratedExam_zpaExam(ctx, field)
			case "mainExamer":
				return ec.fieldContext_GeneratedExam_mainExamer(ctx, field)
			case "primussExams":
				return ec.fieldContext_GeneratedExam_primussExams(ctx, field)
			case "constraints":
				return ec.fieldContext_GeneratedExam_constraints(ctx, field)
			case "conflicts":
				return ec.fieldContext_GeneratedExam_conflicts(ctx, field)
			case "studentRegsCount":
				return ec.fieldContext_GeneratedExam_studentRegsCount(ctx, field)
			case "ntas":
				return ec.fieldContext_GeneratedExam_ntas(ctx, field)
			case "maxDuration":
				return ec.fieldContext_GeneratedExam_maxDuration(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type GeneratedExam", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_generatedExam(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_generatedExam(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().GeneratedExam(rctx, fc.Args["ancode"].(int))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.GeneratedExam)
	fc.Result = res
	return ec.marshalOGeneratedExam2githubcomobcodeplexamsgographmodelGeneratedExam(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_generatedExam(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "ancode":
				return ec.fieldContext_GeneratedExam_ancode(ctx, field)
			case "zpaExam":
				return ec.fieldContext_GeneratedExam_zpaExam(ctx, field)
			case "mainExamer":
				return ec.fieldContext_GeneratedExam_mainExamer(ctx, field)
			case "primussExams":
				return ec.fieldContext_GeneratedExam_primussExams(ctx, field)
			case "constraints":
				return ec.fieldContext_GeneratedExam_constraints(ctx, field)
			case "conflicts":
				return ec.fieldContext_GeneratedExam_conflicts(ctx, field)
			case "studentRegsCount":
				return ec.fieldContext_GeneratedExam_studentRegsCount(ctx, field)
			case "ntas":
				return ec.fieldContext_GeneratedExam_ntas(ctx, field)
			case "maxDuration":
				return ec.fieldContext_GeneratedExam_maxDuration(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type GeneratedExam", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_generatedExam_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_plannedExams(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_plannedExams(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().PlannedExams(rctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.PlannedExam)
	fc.Result = res
	return ec.marshalNPlannedExam2githubcomobcodeplexamsgographmodelPlannedExam(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_plannedExams(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "ancode":
				return ec.fieldContext_PlannedExam_ancode(ctx, field)
			case "zpaExam":
				return ec.fieldContext_PlannedExam_zpaExam(ctx, field)
			case "mainExamer":
				return ec.fieldContext_PlannedExam_mainExamer(ctx, field)
			case "primussExams":
				return ec.fieldContext_PlannedExam_primussExams(ctx, field)
			case "constraints":
				return ec.fieldContext_PlannedExam_constraints(ctx, field)
			case "conflicts":
				return ec.fieldContext_PlannedExam_conflicts(ctx, field)
			case "studentRegsCount":
				return ec.fieldContext_PlannedExam_studentRegsCount(ctx, field)
			case "ntas":
				return ec.fieldContext_PlannedExam_ntas(ctx, field)
			case "maxDuration":
				return ec.fieldContext_PlannedExam_maxDuration(ctx, field)
			case "planEntry":
				return ec.fieldContext_PlannedExam_planEntry(ctx, field)
			case "plannedRooms":
				return ec.fieldContext_PlannedExam_plannedRooms(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PlannedExam", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_plannedExam(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_plannedExam(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().PlannedExam(rctx, fc.Args["ancode"].(int))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.PlannedExam)
	fc.Result = res
	return ec.marshalOPlannedExam2githubcomobcodeplexamsgographmodelPlannedExam(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_plannedExam(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "ancode":
				return ec.fieldContext_PlannedExam_ancode(ctx, field)
			case "zpaExam":
				return ec.fieldContext_PlannedExam_zpaExam(ctx, field)
			case "mainExamer":
				return ec.fieldContext_PlannedExam_mainExamer(ctx, field)
			case "primussExams":
				return ec.fieldContext_PlannedExam_primussExams(ctx, field)
			case "constraints":
				return ec.fieldContext_PlannedExam_constraints(ctx, field)
			case "conflicts":
				return ec.fieldContext_PlannedExam_conflicts(ctx, field)
			case "studentRegsCount":
				return ec.fieldContext_PlannedExam_studentRegsCount(ctx, field)
			case "ntas":
				return ec.fieldContext_PlannedExam_ntas(ctx, field)
			case "maxDuration":
				return ec.fieldContext_PlannedExam_maxDuration(ctx, field)
			case "planEntry":
				return ec.fieldContext_PlannedExam_planEntry(ctx, field)
			case "plannedRooms":
				return ec.fieldContext_PlannedExam_plannedRooms(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PlannedExam", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_plannedExam_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_mucdaiExams(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_mucdaiExams(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().MucdaiExams(rctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.MucDaiExam)
	fc.Result = res
	return ec.marshalNMucDaiExam2githubcomobcodeplexamsgographmodelMucDaiExam(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_mucdaiExams(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "primussAncode":
				return ec.fieldContext_MucDaiExam_primussAncode(ctx, field)
			case "module":
				return ec.fieldContext_MucDaiExam_module(ctx, field)
			case "mainExamer":
				return ec.fieldContext_MucDaiExam_mainExamer(ctx, field)
			case "mainExamerID":
				return ec.fieldContext_MucDaiExam_mainExamerID(ctx, field)
			case "examType":
				return ec.fieldContext_MucDaiExam_examType(ctx, field)
			case "duration":
				return ec.fieldContext_MucDaiExam_duration(ctx, field)
			case "isRepeaterExam":
				return ec.fieldContext_MucDaiExam_isRepeaterExam(ctx, field)
			case "program":
				return ec.fieldContext_MucDaiExam_program(ctx, field)
			case "plannedBy":
				return ec.fieldContext_MucDaiExam_plannedBy(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type MucDaiExam", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_conflictingAncodes(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_conflictingAncodes(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().ConflictingAncodes(rctx, fc.Args["ancode"].(int))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.Conflict)
	fc.Result = res
	return ec.marshalOConflict2githubcomobcodeplexamsgographmodelConflict(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_conflictingAncodes(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "ancode":
				return ec.fieldContext_Conflict_ancode(ctx, field)
			case "numberOfStuds":
				return ec.fieldContext_Conflict_numberOfStuds(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Conflict", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_conflictingAncodes_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_invigilatorTodos(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_invigilatorTodos(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().InvigilatorTodos(rctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.InvigilationTodos)
	fc.Result = res
	return ec.marshalOInvigilationTodos2githubcomobcodeplexamsgographmodelInvigilationTodos(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_invigilatorTodos(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "sumExamRooms":
				return ec.fieldContext_InvigilationTodos_sumExamRooms(ctx, field)
			case "sumReserve":
				return ec.fieldContext_InvigilationTodos_sumReserve(ctx, field)
			case "sumOtherContributions":
				return ec.fieldContext_InvigilationTodos_sumOtherContributions(ctx, field)
			case "sumOtherContributionsOvertimeCutted":
				return ec.fieldContext_InvigilationTodos_sumOtherContributionsOvertimeCutted(ctx, field)
			case "invigilatorCount":
				return ec.fieldContext_InvigilationTodos_invigilatorCount(ctx, field)
			case "todoPerInvigilator":
				return ec.fieldContext_InvigilationTodos_todoPerInvigilator(ctx, field)
			case "todoPerInvigilatorOvertimeCutted":
				return ec.fieldContext_InvigilationTodos_todoPerInvigilatorOvertimeCutted(ctx, field)
			case "invigilators":
				return ec.fieldContext_InvigilationTodos_invigilators(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type InvigilationTodos", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_invigilatorsWithReq(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_invigilatorsWithReq(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().InvigilatorsWithReq(rctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.Invigilator)
	fc.Result = res
	return ec.marshalNInvigilator2githubcomobcodeplexamsgographmodelInvigilator(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_invigilatorsWithReq(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "teacher":
				return ec.fieldContext_Invigilator_teacher(ctx, field)
			case "requirements":
				return ec.fieldContext_Invigilator_requirements(ctx, field)
			case "todos":
				return ec.fieldContext_Invigilator_todos(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Invigilator", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_roomsWithInvigilationsForSlot(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_roomsWithInvigilationsForSlot(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().RoomsWithInvigilationsForSlot(rctx, fc.Args["day"].(int), fc.Args["time"].(int))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.InvigilationSlot)
	fc.Result = res
	return ec.marshalOInvigilationSlot2githubcomobcodeplexamsgographmodelInvigilationSlot(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_roomsWithInvigilationsForSlot(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "reserve":
				return ec.fieldContext_InvigilationSlot_reserve(ctx, field)
			case "roomsWithInvigilators":
				return ec.fieldContext_InvigilationSlot_roomsWithInvigilators(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type InvigilationSlot", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_roomsWithInvigilationsForSlot_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_invigilatorsForDay(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_invigilatorsForDay(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().InvigilatorsForDay(rctx, fc.Args["day"].(int))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.InvigilatorsForDay)
	fc.Result = res
	return ec.marshalOInvigilatorsForDay2githubcomobcodeplexamsgographmodelInvigilatorsForDay(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_invigilatorsForDay(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "want":
				return ec.fieldContext_InvigilatorsForDay_want(ctx, field)
			case "can":
				return ec.fieldContext_InvigilatorsForDay_can(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type InvigilatorsForDay", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_invigilatorsForDay_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_ntas(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_ntas(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Ntas(rctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.NTA)
	fc.Result = res
	return ec.marshalONTA2githubcomobcodeplexamsgographmodelNTA(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_ntas(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext_NTA_name(ctx, field)
			case "email":
				return ec.fieldContext_NTA_email(ctx, field)
			case "mtknr":
				return ec.fieldContext_NTA_mtknr(ctx, field)
			case "compensation":
				return ec.fieldContext_NTA_compensation(ctx, field)
			case "deltaDurationPercent":
				return ec.fieldContext_NTA_deltaDurationPercent(ctx, field)
			case "needsRoomAlone":
				return ec.fieldContext_NTA_needsRoomAlone(ctx, field)
			case "needsHardware":
				return ec.fieldContext_NTA_needsHardware(ctx, field)
			case "program":
				return ec.fieldContext_NTA_program(ctx, field)
			case "from":
				return ec.fieldContext_NTA_from(ctx, field)
			case "until":
				return ec.fieldContext_NTA_until(ctx, field)
			case "lastSemester":
				return ec.fieldContext_NTA_lastSemester(ctx, field)
			case "exams":
				return ec.fieldContext_NTA_exams(ctx, field)
			case "deactivated":
				return ec.fieldContext_NTA_deactivated(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type NTA", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_ntasWithRegs(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_ntasWithRegs(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().NtasWithRegs(rctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.Student)
	fc.Result = res
	return ec.marshalOStudent2githubcomobcodeplexamsgographmodelStudent(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_ntasWithRegs(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "mtknr":
				return ec.fieldContext_Student_mtknr(ctx, field)
			case "program":
				return ec.fieldContext_Student_program(ctx, field)
			case "group":
				return ec.fieldContext_Student_group(ctx, field)
			case "name":
				return ec.fieldContext_Student_name(ctx, field)
			case "regs":
				return ec.fieldContext_Student_regs(ctx, field)
			case "regsWithProgram":
				return ec.fieldContext_Student_regsWithProgram(ctx, field)
			case "zpaStudent":
				return ec.fieldContext_Student_zpaStudent(ctx, field)
			case "nta":
				return ec.fieldContext_Student_nta(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Student", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_nta(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_nta(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Nta(rctx, fc.Args["mtknr"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.NTAWithRegs)
	fc.Result = res
	return ec.marshalONTAWithRegs2githubcomobcodeplexamsgographmodelNTAWithRegs(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_nta(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "nta":
				return ec.fieldContext_NTAWithRegs_nta(ctx, field)
			case "regs":
				return ec.fieldContext_NTAWithRegs_regs(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type NTAWithRegs", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_nta_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_allProgramsInPlan(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_allProgramsInPlan(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().AllProgramsInPlan(rctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_allProgramsInPlan(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_ancodesInPlan(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_ancodesInPlan(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().AncodesInPlan(rctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_ancodesInPlan(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_examerInPlan(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_examerInPlan(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().ExamerInPlan(rctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.ExamerInPlan)
	fc.Result = res
	return ec.marshalOExamerInPlan2githubcomobcodeplexamsgographmodelExamerInPlan(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_examerInPlan(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "mainExamer":
				return ec.fieldContext_ExamerInPlan_mainExamer(ctx, field)
			case "mainExamerID":
				return ec.fieldContext_ExamerInPlan_mainExamerID(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ExamerInPlan", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_preExamsInSlot(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_preExamsInSlot(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().PreExamsInSlot(rctx, fc.Args["day"].(int), fc.Args["time"].(int))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.PreExam)
	fc.Result = res
	return ec.marshalOPreExam2githubcomobcodeplexamsgographmodelPreExam(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_preExamsInSlot(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "zpaExam":
				return ec.fieldContext_PreExam_zpaExam(ctx, field)
			case "constraints":
				return ec.fieldContext_PreExam_constraints(ctx, field)
			case "planEntry":
				return ec.fieldContext_PreExam_planEntry(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PreExam", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_preExamsInSlot_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_examsInSlot(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_examsInSlot(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().ExamsInSlot(rctx, fc.Args["day"].(int), fc.Args["time"].(int))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.PlannedExam)
	fc.Result = res
	return ec.marshalOPlannedExam2githubcomobcodeplexamsgographmodelPlannedExam(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_examsInSlot(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "ancode":
				return ec.fieldContext_PlannedExam_ancode(ctx, field)
			case "zpaExam":
				return ec.fieldContext_PlannedExam_zpaExam(ctx, field)
			case "mainExamer":
				return ec.fieldContext_PlannedExam_mainExamer(ctx, field)
			case "primussExams":
				return ec.fieldContext_PlannedExam_primussExams(ctx, field)
			case "constraints":
				return ec.fieldContext_PlannedExam_constraints(ctx, field)
			case "conflicts":
				return ec.fieldContext_PlannedExam_conflicts(ctx, field)
			case "studentRegsCount":
				return ec.fieldContext_PlannedExam_studentRegsCount(ctx, field)
			case "ntas":
				return ec.fieldContext_PlannedExam_ntas(ctx, field)
			case "maxDuration":
				return ec.fieldContext_PlannedExam_maxDuration(ctx, field)
			case "planEntry":
				return ec.fieldContext_PlannedExam_planEntry(ctx, field)
			case "plannedRooms":
				return ec.fieldContext_PlannedExam_plannedRooms(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PlannedExam", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_examsInSlot_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_examsWithoutSlot(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_examsWithoutSlot(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().ExamsWithoutSlot(rctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.PlannedExam)
	fc.Result = res
	return ec.marshalNPlannedExam2githubcomobcodeplexamsgographmodelPlannedExam(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_examsWithoutSlot(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "ancode":
				return ec.fieldContext_PlannedExam_ancode(ctx, field)
			case "zpaExam":
				return ec.fieldContext_PlannedExam_zpaExam(ctx, field)
			case "mainExamer":
				return ec.fieldContext_PlannedExam_mainExamer(ctx, field)
			case "primussExams":
				return ec.fieldContext_PlannedExam_primussExams(ctx, field)
			case "constraints":
				return ec.fieldContext_PlannedExam_constraints(ctx, field)
			case "conflicts":
				return ec.fieldContext_PlannedExam_conflicts(ctx, field)
			case "studentRegsCount":
				return ec.fieldContext_PlannedExam_studentRegsCount(ctx, field)
			case "ntas":
				return ec.fieldContext_PlannedExam_ntas(ctx, field)
			case "maxDuration":
				return ec.fieldContext_PlannedExam_maxDuration(ctx, field)
			case "planEntry":
				return ec.fieldContext_PlannedExam_planEntry(ctx, field)
			case "plannedRooms":
				return ec.fieldContext_PlannedExam_plannedRooms(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PlannedExam", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_allowedSlots(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_allowedSlots(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().AllowedSlots(rctx, fc.Args["ancode"].(int))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.Slot)
	fc.Result = res
	return ec.marshalOSlot2githubcomobcodeplexamsgographmodelSlot(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_allowedSlots(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "dayNumber":
				return ec.fieldContext_Slot_dayNumber(ctx, field)
			case "slotNumber":
				return ec.fieldContext_Slot_slotNumber(ctx, field)
			case "starttime":
				return ec.fieldContext_Slot_starttime(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Slot", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_allowedSlots_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_awkwardSlots(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_awkwardSlots(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().AwkwardSlots(rctx, fc.Args["ancode"].(int))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.Slot)
	fc.Result = res
	return ec.marshalNSlot2githubcomobcodeplexamsgographmodelSlot(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_awkwardSlots(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "dayNumber":
				return ec.fieldContext_Slot_dayNumber(ctx, field)
			case "slotNumber":
				return ec.fieldContext_Slot_slotNumber(ctx, field)
			case "starttime":
				return ec.fieldContext_Slot_starttime(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Slot", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_awkwardSlots_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_primussExams(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_primussExams(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().PrimussExams(rctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.PrimussExamByProgram)
	fc.Result = res
	return ec.marshalOPrimussExamByProgram2githubcomobcodeplexamsgographmodelPrimussExamByProgram(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_primussExams(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "program":
				return ec.fieldContext_PrimussExamByProgram_program(ctx, field)
			case "exams":
				return ec.fieldContext_PrimussExamByProgram_exams(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PrimussExamByProgram", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_primussExam(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_primussExam(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().PrimussExam(rctx, fc.Args["program"].(string), fc.Args["ancode"].(int))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.PrimussExam)
	fc.Result = res
	return ec.marshalNPrimussExam2githubcomobcodeplexamsgographmodelPrimussExam(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_primussExam(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "ancode":
				return ec.fieldContext_PrimussExam_ancode(ctx, field)
			case "module":
				return ec.fieldContext_PrimussExam_module(ctx, field)
			case "mainExamer":
				return ec.fieldContext_PrimussExam_mainExamer(ctx, field)
			case "program":
				return ec.fieldContext_PrimussExam_program(ctx, field)
			case "examType":
				return ec.fieldContext_PrimussExam_examType(ctx, field)
			case "presence":
				return ec.fieldContext_PrimussExam_presence(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PrimussExam", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_primussExam_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_primussExamsForAnCode(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_primussExamsForAnCode(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().PrimussExamsForAnCode(rctx, fc.Args["ancode"].(int))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.PrimussExam)
	fc.Result = res
	return ec.marshalOPrimussExam2githubcomobcodeplexamsgographmodelPrimussExam(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_primussExamsForAnCode(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "ancode":
				return ec.fieldContext_PrimussExam_ancode(ctx, field)
			case "module":
				return ec.fieldContext_PrimussExam_module(ctx, field)
			case "mainExamer":
				return ec.fieldContext_PrimussExam_mainExamer(ctx, field)
			case "program":
				return ec.fieldContext_PrimussExam_program(ctx, field)
			case "examType":
				return ec.fieldContext_PrimussExam_examType(ctx, field)
			case "presence":
				return ec.fieldContext_PrimussExam_presence(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PrimussExam", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_primussExamsForAnCode_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_studentRegsForProgram(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_studentRegsForProgram(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().StudentRegsForProgram(rctx, fc.Args["program"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.StudentReg)
	fc.Result = res
	return ec.marshalOStudentReg2githubcomobcodeplexamsgographmodelStudentReg(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_studentRegsForProgram(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "mtknr":
				return ec.fieldContext_StudentReg_mtknr(ctx, field)
			case "ancode":
				return ec.fieldContext_StudentReg_ancode(ctx, field)
			case "program":
				return ec.fieldContext_StudentReg_program(ctx, field)
			case "group":
				return ec.fieldContext_StudentReg_group(ctx, field)
			case "name":
				return ec.fieldContext_StudentReg_name(ctx, field)
			case "presence":
				return ec.fieldContext_StudentReg_presence(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type StudentReg", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_studentRegsForProgram_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_rooms(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_rooms(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Rooms(rctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.Room)
	fc.Result = res
	return ec.marshalNRoom2githubcomobcodeplexamsgographmodelRoom(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_rooms(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext_Room_name(ctx, field)
			case "seats":
				return ec.fieldContext_Room_seats(ctx, field)
			case "handicap":
				return ec.fieldContext_Room_handicap(ctx, field)
			case "lab":
				return ec.fieldContext_Room_lab(ctx, field)
			case "placesWithSocket":
				return ec.fieldContext_Room_placesWithSocket(ctx, field)
			case "needsRequest":
				return ec.fieldContext_Room_needsRequest(ctx, field)
			case "exahm":
				return ec.fieldContext_Room_exahm(ctx, field)
			case "seb":
				return ec.fieldContext_Room_seb(ctx, field)
			case "sebSeats":
				return ec.fieldContext_Room_sebSeats(ctx, field)
			case "hmebSeats":
				return ec.fieldContext_Room_hmebSeats(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Room", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_prePlannedRooms(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_prePlannedRooms(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().PrePlannedRooms(rctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.PrePlannedRoom)
	fc.Result = res
	return ec.marshalNPrePlannedRoom2githubcomobcodeplexamsgographmodelPrePlannedRoom(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_prePlannedRooms(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "ancode":
				return ec.fieldContext_PrePlannedRoom_ancode(ctx, field)
			case "roomName":
				return ec.fieldContext_PrePlannedRoom_roomName(ctx, field)
			case "mtknr":
				return ec.fieldContext_PrePlannedRoom_mtknr(ctx, field)
			case "reserve":
				return ec.fieldContext_PrePlannedRoom_reserve(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PrePlannedRoom", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_roomsForSlots(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_roomsForSlots(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().RoomsForSlots(rctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.RoomsForSlot)
	fc.Result = res
	return ec.marshalNRoomsForSlot2githubcomobcodeplexamsgographmodelRoomsForSlot(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_roomsForSlots(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "day":
				return ec.fieldContext_RoomsForSlot_day(ctx, field)
			case "slot":
				return ec.fieldContext_RoomsForSlot_slot(ctx, field)
			case "rooms":
				return ec.fieldContext_RoomsForSlot_rooms(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type RoomsForSlot", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_plannedRooms(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_plannedRooms(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().PlannedRooms(rctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.PlannedRoom)
	fc.Result = res
	return ec.marshalNPlannedRoom2githubcomobcodeplexamsgographmodelPlannedRoom(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_plannedRooms(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "day":
				return ec.fieldContext_PlannedRoom_day(ctx, field)
			case "slot":
				return ec.fieldContext_PlannedRoom_slot(ctx, field)
			case "room":
				return ec.fieldContext_PlannedRoom_room(ctx, field)
			case "ancode":
				return ec.fieldContext_PlannedRoom_ancode(ctx, field)
			case "duration":
				return ec.fieldContext_PlannedRoom_duration(ctx, field)
			case "handicap":
				return ec.fieldContext_PlannedRoom_handicap(ctx, field)
			case "handicapRoomAlone":
				return ec.fieldContext_PlannedRoom_handicapRoomAlone(ctx, field)
			case "reserve":
				return ec.fieldContext_PlannedRoom_reserve(ctx, field)
			case "studentsInRoom":
				return ec.fieldContext_PlannedRoom_studentsInRoom(ctx, field)
			case "ntaMtknr":
				return ec.fieldContext_PlannedRoom_ntaMtknr(ctx, field)
			case "prePlanned":
				return ec.fieldContext_PlannedRoom_prePlanned(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PlannedRoom", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_plannedRoomNames(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_plannedRoomNames(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().PlannedRoomNames(rctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_plannedRoomNames(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_plannedRoomNamesInSlot(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_plannedRoomNamesInSlot(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().PlannedRoomNamesInSlot(rctx, fc.Args["day"].(int), fc.Args["time"].(int))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_plannedRoomNamesInSlot(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_plannedRoomNamesInSlot_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_plannedRoomsInSlot(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_plannedRoomsInSlot(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().PlannedRoomsInSlot(rctx, fc.Args["day"].(int), fc.Args["time"].(int))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.PlannedRoom)
	fc.Result = res
	return ec.marshalOPlannedRoom2githubcomobcodeplexamsgographmodelPlannedRoom(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_plannedRoomsInSlot(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "day":
				return ec.fieldContext_PlannedRoom_day(ctx, field)
			case "slot":
				return ec.fieldContext_PlannedRoom_slot(ctx, field)
			case "room":
				return ec.fieldContext_PlannedRoom_room(ctx, field)
			case "ancode":
				return ec.fieldContext_PlannedRoom_ancode(ctx, field)
			case "duration":
				return ec.fieldContext_PlannedRoom_duration(ctx, field)
			case "handicap":
				return ec.fieldContext_PlannedRoom_handicap(ctx, field)
			case "handicapRoomAlone":
				return ec.fieldContext_PlannedRoom_handicapRoomAlone(ctx, field)
			case "reserve":
				return ec.fieldContext_PlannedRoom_reserve(ctx, field)
			case "studentsInRoom":
				return ec.fieldContext_PlannedRoom_studentsInRoom(ctx, field)
			case "ntaMtknr":
				return ec.fieldContext_PlannedRoom_ntaMtknr(ctx, field)
			case "prePlanned":
				return ec.fieldContext_PlannedRoom_prePlanned(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PlannedRoom", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_plannedRoomsInSlot_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_plannedRoomForStudent(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_plannedRoomForStudent(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().PlannedRoomForStudent(rctx, fc.Args["ancode"].(int), fc.Args["mtknr"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.PlannedRoom)
	fc.Result = res
	return ec.marshalOPlannedRoom2githubcomobcodeplexamsgographmodelPlannedRoom(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_plannedRoomForStudent(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "day":
				return ec.fieldContext_PlannedRoom_day(ctx, field)
			case "slot":
				return ec.fieldContext_PlannedRoom_slot(ctx, field)
			case "room":
				return ec.fieldContext_PlannedRoom_room(ctx, field)
			case "ancode":
				return ec.fieldContext_PlannedRoom_ancode(ctx, field)
			case "duration":
				return ec.fieldContext_PlannedRoom_duration(ctx, field)
			case "handicap":
				return ec.fieldContext_PlannedRoom_handicap(ctx, field)
			case "handicapRoomAlone":
				return ec.fieldContext_PlannedRoom_handicapRoomAlone(ctx, field)
			case "reserve":
				return ec.fieldContext_PlannedRoom_reserve(ctx, field)
			case "studentsInRoom":
				return ec.fieldContext_PlannedRoom_studentsInRoom(ctx, field)
			case "ntaMtknr":
				return ec.fieldContext_PlannedRoom_ntaMtknr(ctx, field)
			case "prePlanned":
				return ec.fieldContext_PlannedRoom_prePlanned(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PlannedRoom", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_plannedRoomForStudent_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_studentByMtknr(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_studentByMtknr(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().StudentByMtknr(rctx, fc.Args["mtknr"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.Student)
	fc.Result = res
	return ec.marshalOStudent2githubcomobcodeplexamsgographmodelStudent(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_studentByMtknr(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "mtknr":
				return ec.fieldContext_Student_mtknr(ctx, field)
			case "program":
				return ec.fieldContext_Student_program(ctx, field)
			case "group":
				return ec.fieldContext_Student_group(ctx, field)
			case "name":
				return ec.fieldContext_Student_name(ctx, field)
			case "regs":
				return ec.fieldContext_Student_regs(ctx, field)
			case "regsWithProgram":
				return ec.fieldContext_Student_regsWithProgram(ctx, field)
			case "zpaStudent":
				return ec.fieldContext_Student_zpaStudent(ctx, field)
			case "nta":
				return ec.fieldContext_Student_nta(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Student", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_studentByMtknr_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_studentsByName(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_studentsByName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().StudentsByName(rctx, fc.Args["regex"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.Student)
	fc.Result = res
	return ec.marshalNStudent2githubcomobcodeplexamsgographmodelStudent(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_studentsByName(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "mtknr":
				return ec.fieldContext_Student_mtknr(ctx, field)
			case "program":
				return ec.fieldContext_Student_program(ctx, field)
			case "group":
				return ec.fieldContext_Student_group(ctx, field)
			case "name":
				return ec.fieldContext_Student_name(ctx, field)
			case "regs":
				return ec.fieldContext_Student_regs(ctx, field)
			case "regsWithProgram":
				return ec.fieldContext_Student_regsWithProgram(ctx, field)
			case "zpaStudent":
				return ec.fieldContext_Student_zpaStudent(ctx, field)
			case "nta":
				return ec.fieldContext_Student_nta(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Student", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_studentsByName_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_students(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_students(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Students(rctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.Student)
	fc.Result = res
	return ec.marshalNStudent2githubcomobcodeplexamsgographmodelStudent(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_students(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "mtknr":
				return ec.fieldContext_Student_mtknr(ctx, field)
			case "program":
				return ec.fieldContext_Student_program(ctx, field)
			case "group":
				return ec.fieldContext_Student_group(ctx, field)
			case "name":
				return ec.fieldContext_Student_name(ctx, field)
			case "regs":
				return ec.fieldContext_Student_regs(ctx, field)
			case "regsWithProgram":
				return ec.fieldContext_Student_regsWithProgram(ctx, field)
			case "zpaStudent":
				return ec.fieldContext_Student_zpaStudent(ctx, field)
			case "nta":
				return ec.fieldContext_Student_nta(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Student", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_teacher(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_teacher(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Teacher(rctx, fc.Args["id"].(int))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.Teacher)
	fc.Result = res
	return ec.marshalOTeacher2githubcomobcodeplexamsgographmodelTeacher(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_teacher(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "shortname":
				return ec.fieldContext_Teacher_shortname(ctx, field)
			case "fullname":
				return ec.fieldContext_Teacher_fullname(ctx, field)
			case "isProf":
				return ec.fieldContext_Teacher_isProf(ctx, field)
			case "isLBA":
				return ec.fieldContext_Teacher_isLBA(ctx, field)
			case "isProfHC":
				return ec.fieldContext_Teacher_isProfHC(ctx, field)
			case "isStaff":
				return ec.fieldContext_Teacher_isStaff(ctx, field)
			case "lastSemester":
				return ec.fieldContext_Teacher_lastSemester(ctx, field)
			case "fk":
				return ec.fieldContext_Teacher_fk(ctx, field)
			case "id":
				return ec.fieldContext_Teacher_id(ctx, field)
			case "email":
				return ec.fieldContext_Teacher_email(ctx, field)
			case "isActive":
				return ec.fieldContext_Teacher_isActive(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Teacher", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_teacher_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_teachers(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_teachers(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Teachers(rctx, fc.Args["fromZPA"].(*bool))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.Teacher)
	fc.Result = res
	return ec.marshalNTeacher2githubcomobcodeplexamsgographmodelTeacher(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_teachers(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "shortname":
				return ec.fieldContext_Teacher_shortname(ctx, field)
			case "fullname":
				return ec.fieldContext_Teacher_fullname(ctx, field)
			case "isProf":
				return ec.fieldContext_Teacher_isProf(ctx, field)
			case "isLBA":
				return ec.fieldContext_Teacher_isLBA(ctx, field)
			case "isProfHC":
				return ec.fieldContext_Teacher_isProfHC(ctx, field)
			case "isStaff":
				return ec.fieldContext_Teacher_isStaff(ctx, field)
			case "lastSemester":
				return ec.fieldContext_Teacher_lastSemester(ctx, field)
			case "fk":
				return ec.fieldContext_Teacher_fk(ctx, field)
			case "id":
				return ec.fieldContext_Teacher_id(ctx, field)
			case "email":
				return ec.fieldContext_Teacher_email(ctx, field)
			case "isActive":
				return ec.fieldContext_Teacher_isActive(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Teacher", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_teachers_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_invigilators(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_invigilators(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Invigilators(rctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.ZPAInvigilator)
	fc.Result = res
	return ec.marshalNZPAInvigilator2githubcomobcodeplexamsgographmodelZPAInvigilator(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_invigilators(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "teacher":
				return ec.fieldContext_ZPAInvigilator_teacher(ctx, field)
			case "hasSubmittedRequirements":
				return ec.fieldContext_ZPAInvigilator_hasSubmittedRequirements(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ZPAInvigilator", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_fk07programs(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_fk07programs(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Fk07programs(rctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.FK07Program)
	fc.Result = res
	return ec.marshalNFK07Program2githubcomobcodeplexamsgographmodelFK07Program(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_fk07programs(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext_FK07Program_name(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type FK07Program", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_zpaExams(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_zpaExams(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().ZpaExams(rctx, fc.Args["fromZPA"].(*bool))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.ZPAExam)
	fc.Result = res
	return ec.marshalNZPAExam2githubcomobcodeplexamsgographmodelZPAExam(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_zpaExams(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "zpaID":
				return ec.fieldContext_ZPAExam_zpaID(ctx, field)
			case "semester":
				return ec.fieldContext_ZPAExam_semester(ctx, field)
			case "ancode":
				return ec.fieldContext_ZPAExam_ancode(ctx, field)
			case "module":
				return ec.fieldContext_ZPAExam_module(ctx, field)
			case "mainExamer":
				return ec.fieldContext_ZPAExam_mainExamer(ctx, field)
			case "mainExamerID":
				return ec.fieldContext_ZPAExam_mainExamerID(ctx, field)
			case "examType":
				return ec.fieldContext_ZPAExam_examType(ctx, field)
			case "examTypeFull":
				return ec.fieldContext_ZPAExam_examTypeFull(ctx, field)
			case "duration":
				return ec.fieldContext_ZPAExam_duration(ctx, field)
			case "isRepeaterExam":
				return ec.fieldContext_ZPAExam_isRepeaterExam(ctx, field)
			case "groups":
				return ec.fieldContext_ZPAExam_groups(ctx, field)
			case "primussAncodes":
				return ec.fieldContext_ZPAExam_primussAncodes(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ZPAExam", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_zpaExams_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_zpaExamsByType(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_zpaExamsByType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().ZpaExamsByType(rctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.ZPAExamsForType)
	fc.Result = res
	return ec.marshalNZPAExamsForType2githubcomobcodeplexamsgographmodelZPAExamsForType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_zpaExamsByType(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "type":
				return ec.fieldContext_ZPAExamsForType_type(ctx, field)
			case "exams":
				return ec.fieldContext_ZPAExamsForType_exams(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ZPAExamsForType", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_zpaExamsToPlan(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_zpaExamsToPlan(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().ZpaExamsToPlan(rctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.ZPAExam)
	fc.Result = res
	return ec.marshalNZPAExam2githubcomobcodeplexamsgographmodelZPAExam(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_zpaExamsToPlan(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "zpaID":
				return ec.fieldContext_ZPAExam_zpaID(ctx, field)
			case "semester":
				return ec.fieldContext_ZPAExam_semester(ctx, field)
			case "ancode":
				return ec.fieldContext_ZPAExam_ancode(ctx, field)
			case "module":
				return ec.fieldContext_ZPAExam_module(ctx, field)
			case "mainExamer":
				return ec.fieldContext_ZPAExam_mainExamer(ctx, field)
			case "mainExamerID":
				return ec.fieldContext_ZPAExam_mainExamerID(ctx, field)
			case "examType":
				return ec.fieldContext_ZPAExam_examType(ctx, field)
			case "examTypeFull":
				return ec.fieldContext_ZPAExam_examTypeFull(ctx, field)
			case "duration":
				return ec.fieldContext_ZPAExam_duration(ctx, field)
			case "isRepeaterExam":
				return ec.fieldContext_ZPAExam_isRepeaterExam(ctx, field)
			case "groups":
				return ec.fieldContext_ZPAExam_groups(ctx, field)
			case "primussAncodes":
				return ec.fieldContext_ZPAExam_primussAncodes(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ZPAExam", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_zpaExamsNotToPlan(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_zpaExamsNotToPlan(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().ZpaExamsNotToPlan(rctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.ZPAExam)
	fc.Result = res
	return ec.marshalNZPAExam2githubcomobcodeplexamsgographmodelZPAExam(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_zpaExamsNotToPlan(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "zpaID":
				return ec.fieldContext_ZPAExam_zpaID(ctx, field)
			case "semester":
				return ec.fieldContext_ZPAExam_semester(ctx, field)
			case "ancode":
				return ec.fieldContext_ZPAExam_ancode(ctx, field)
			case "module":
				return ec.fieldContext_ZPAExam_module(ctx, field)
			case "mainExamer":
				return ec.fieldContext_ZPAExam_mainExamer(ctx, field)
			case "mainExamerID":
				return ec.fieldContext_ZPAExam_mainExamerID(ctx, field)
			case "examType":
				return ec.fieldContext_ZPAExam_examType(ctx, field)
			case "examTypeFull":
				return ec.fieldContext_ZPAExam_examTypeFull(ctx, field)
			case "duration":
				return ec.fieldContext_ZPAExam_duration(ctx, field)
			case "isRepeaterExam":
				return ec.fieldContext_ZPAExam_isRepeaterExam(ctx, field)
			case "groups":
				return ec.fieldContext_ZPAExam_groups(ctx, field)
			case "primussAncodes":
				return ec.fieldContext_ZPAExam_primussAncodes(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ZPAExam", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_zpaExamsPlaningStatusUnknown(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_zpaExamsPlaningStatusUnknown(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().ZpaExamsPlaningStatusUnknown(rctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.ZPAExam)
	fc.Result = res
	return ec.marshalNZPAExam2githubcomobcodeplexamsgographmodelZPAExam(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_zpaExamsPlaningStatusUnknown(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "zpaID":
				return ec.fieldContext_ZPAExam_zpaID(ctx, field)
			case "semester":
				return ec.fieldContext_ZPAExam_semester(ctx, field)
			case "ancode":
				return ec.fieldContext_ZPAExam_ancode(ctx, field)
			case "module":
				return ec.fieldContext_ZPAExam_module(ctx, field)
			case "mainExamer":
				return ec.fieldContext_ZPAExam_mainExamer(ctx, field)
			case "mainExamerID":
				return ec.fieldContext_ZPAExam_mainExamerID(ctx, field)
			case "examType":
				return ec.fieldContext_ZPAExam_examType(ctx, field)
			case "examTypeFull":
				return ec.fieldContext_ZPAExam_examTypeFull(ctx, field)
			case "duration":
				return ec.fieldContext_ZPAExam_duration(ctx, field)
			case "isRepeaterExam":
				return ec.fieldContext_ZPAExam_isRepeaterExam(ctx, field)
			case "groups":
				return ec.fieldContext_ZPAExam_groups(ctx, field)
			case "primussAncodes":
				return ec.fieldContext_ZPAExam_primussAncodes(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ZPAExam", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_zpaExam(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_zpaExam(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().ZpaExam(rctx, fc.Args["ancode"].(int))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.ZPAExam)
	fc.Result = res
	return ec.marshalOZPAExam2githubcomobcodeplexamsgographmodelZPAExam(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_zpaExam(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "zpaID":
				return ec.fieldContext_ZPAExam_zpaID(ctx, field)
			case "semester":
				return ec.fieldContext_ZPAExam_semester(ctx, field)
			case "ancode":
				return ec.fieldContext_ZPAExam_ancode(ctx, field)
			case "module":
				return ec.fieldContext_ZPAExam_module(ctx, field)
			case "mainExamer":
				return ec.fieldContext_ZPAExam_mainExamer(ctx, field)
			case "mainExamerID":
				return ec.fieldContext_ZPAExam_mainExamerID(ctx, field)
			case "examType":
				return ec.fieldContext_ZPAExam_examType(ctx, field)
			case "examTypeFull":
				return ec.fieldContext_ZPAExam_examTypeFull(ctx, field)
			case "duration":
				return ec.fieldContext_ZPAExam_duration(ctx, field)
			case "isRepeaterExam":
				return ec.fieldContext_ZPAExam_isRepeaterExam(ctx, field)
			case "groups":
				return ec.fieldContext_ZPAExam_groups(ctx, field)
			case "primussAncodes":
				return ec.fieldContext_ZPAExam_primussAncodes(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ZPAExam", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_zpaExam_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_zpaAnCodes(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_zpaAnCodes(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().ZpaAnCodes(rctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.AnCode)
	fc.Result = res
	return ec.marshalOAnCode2githubcomobcodeplexamsgographmodelAnCode(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_zpaAnCodes(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "ancode":
				return ec.fieldContext_AnCode_ancode(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type AnCode", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_studentRegsImportErrors(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_studentRegsImportErrors(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().StudentRegsImportErrors(rctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.RegWithError)
	fc.Result = res
	return ec.marshalNRegWithError2githubcomobcodeplexamsgographmodelRegWithError(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_studentRegsImportErrors(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "registration":
				return ec.fieldContext_RegWithError_registration(ctx, field)
			case "error":
				return ec.fieldContext_RegWithError_error(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type RegWithError", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query___type(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query___type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.introspectType(fc.Args["name"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query___type(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "isOneOf":
				return ec.fieldContext___Type_isOneOf(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query___type_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query___schema(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query___schema(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.introspectSchema()
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Schema)
	fc.Result = res
	return ec.marshalO__Schema2githubcom99designsgqlgengraphqlintrospectionSchema(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query___schema(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "description":
				return ec.fieldContext___Schema_description(ctx, field)
			case "types":
				return ec.fieldContext___Schema_types(ctx, field)
			case "queryType":
				return ec.fieldContext___Schema_queryType(ctx, field)
			case "mutationType":
				return ec.fieldContext___Schema_mutationType(ctx, field)
			case "subscriptionType":
				return ec.fieldContext___Schema_subscriptionType(ctx, field)
			case "directives":
				return ec.fieldContext___Schema_directives(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Schema", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _RegWithError_registration(ctx context.Context, field graphql.CollectedField, obj *model.RegWithError) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RegWithError_registration(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Registration, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.ZPAStudentReg)
	fc.Result = res
	return ec.marshalNZPAStudentReg2githubcomobcodeplexamsgographmodelZPAStudentReg(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RegWithError_registration(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RegWithError",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "ancode":
				return ec.fieldContext_ZPAStudentReg_ancode(ctx, field)
			case "mtknr":
				return ec.fieldContext_ZPAStudentReg_mtknr(ctx, field)
			case "program":
				return ec.fieldContext_ZPAStudentReg_program(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ZPAStudentReg", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _RegWithError_error(ctx context.Context, field graphql.CollectedField, obj *model.RegWithError) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RegWithError_error(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Error, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.ZPAStudentRegError)
	fc.Result = res
	return ec.marshalNZPAStudentRegError2githubcomobcodeplexamsgographmodelZPAStudentRegError(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RegWithError_error(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RegWithError",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "semester":
				return ec.fieldContext_ZPAStudentRegError_semester(ctx, field)
			case "ancode":
				return ec.fieldContext_ZPAStudentRegError_ancode(ctx, field)
			case "exam":
				return ec.fieldContext_ZPAStudentRegError_exam(ctx, field)
			case "mtknr":
				return ec.fieldContext_ZPAStudentRegError_mtknr(ctx, field)
			case "program":
				return ec.fieldContext_ZPAStudentRegError_program(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ZPAStudentRegError", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _RegWithProgram_program(ctx context.Context, field graphql.CollectedField, obj *model.RegWithProgram) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RegWithProgram_program(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Program, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RegWithProgram_program(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RegWithProgram",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RegWithProgram_reg(ctx context.Context, field graphql.CollectedField, obj *model.RegWithProgram) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RegWithProgram_reg(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Reg, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RegWithProgram_reg(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RegWithProgram",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Room_name(ctx context.Context, field graphql.CollectedField, obj *model.Room) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Room_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Room_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Room",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Room_seats(ctx context.Context, field graphql.CollectedField, obj *model.Room) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Room_seats(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Seats, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Room_seats(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Room",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Room_handicap(ctx context.Context, field graphql.CollectedField, obj *model.Room) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Room_handicap(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Handicap, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Room_handicap(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Room",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Room_lab(ctx context.Context, field graphql.CollectedField, obj *model.Room) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Room_lab(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Lab, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Room_lab(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Room",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Room_placesWithSocket(ctx context.Context, field graphql.CollectedField, obj *model.Room) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Room_placesWithSocket(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PlacesWithSocket, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Room_placesWithSocket(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Room",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Room_needsRequest(ctx context.Context, field graphql.CollectedField, obj *model.Room) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Room_needsRequest(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.NeedsRequest, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Room_needsRequest(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Room",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Room_exahm(ctx context.Context, field graphql.CollectedField, obj *model.Room) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Room_exahm(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Exahm, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Room_exahm(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Room",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Room_seb(ctx context.Context, field graphql.CollectedField, obj *model.Room) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Room_seb(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Seb, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Room_seb(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Room",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Room_sebSeats(ctx context.Context, field graphql.CollectedField, obj *model.Room) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Room_sebSeats(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SebSeats, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Room_sebSeats(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Room",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Room_hmebSeats(ctx context.Context, field graphql.CollectedField, obj *model.Room) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Room_hmebSeats(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.HmebSeats, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Room_hmebSeats(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Room",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RoomAndExam_room(ctx context.Context, field graphql.CollectedField, obj *model.RoomAndExam) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RoomAndExam_room(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Room, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.PlannedRoom)
	fc.Result = res
	return ec.marshalNPlannedRoom2githubcomobcodeplexamsgographmodelPlannedRoom(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RoomAndExam_room(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RoomAndExam",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "day":
				return ec.fieldContext_PlannedRoom_day(ctx, field)
			case "slot":
				return ec.fieldContext_PlannedRoom_slot(ctx, field)
			case "room":
				return ec.fieldContext_PlannedRoom_room(ctx, field)
			case "ancode":
				return ec.fieldContext_PlannedRoom_ancode(ctx, field)
			case "duration":
				return ec.fieldContext_PlannedRoom_duration(ctx, field)
			case "handicap":
				return ec.fieldContext_PlannedRoom_handicap(ctx, field)
			case "handicapRoomAlone":
				return ec.fieldContext_PlannedRoom_handicapRoomAlone(ctx, field)
			case "reserve":
				return ec.fieldContext_PlannedRoom_reserve(ctx, field)
			case "studentsInRoom":
				return ec.fieldContext_PlannedRoom_studentsInRoom(ctx, field)
			case "ntaMtknr":
				return ec.fieldContext_PlannedRoom_ntaMtknr(ctx, field)
			case "prePlanned":
				return ec.fieldContext_PlannedRoom_prePlanned(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PlannedRoom", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _RoomAndExam_exam(ctx context.Context, field graphql.CollectedField, obj *model.RoomAndExam) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RoomAndExam_exam(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Exam, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.ZPAExam)
	fc.Result = res
	return ec.marshalNZPAExam2githubcomobcodeplexamsgographmodelZPAExam(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RoomAndExam_exam(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RoomAndExam",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "zpaID":
				return ec.fieldContext_ZPAExam_zpaID(ctx, field)
			case "semester":
				return ec.fieldContext_ZPAExam_semester(ctx, field)
			case "ancode":
				return ec.fieldContext_ZPAExam_ancode(ctx, field)
			case "module":
				return ec.fieldContext_ZPAExam_module(ctx, field)
			case "mainExamer":
				return ec.fieldContext_ZPAExam_mainExamer(ctx, field)
			case "mainExamerID":
				return ec.fieldContext_ZPAExam_mainExamerID(ctx, field)
			case "examType":
				return ec.fieldContext_ZPAExam_examType(ctx, field)
			case "examTypeFull":
				return ec.fieldContext_ZPAExam_examTypeFull(ctx, field)
			case "duration":
				return ec.fieldContext_ZPAExam_duration(ctx, field)
			case "isRepeaterExam":
				return ec.fieldContext_ZPAExam_isRepeaterExam(ctx, field)
			case "groups":
				return ec.fieldContext_ZPAExam_groups(ctx, field)
			case "primussAncodes":
				return ec.fieldContext_ZPAExam_primussAncodes(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ZPAExam", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _RoomConstraints_allowedRooms(ctx context.Context, field graphql.CollectedField, obj *model.RoomConstraints) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RoomConstraints_allowedRooms(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AllowedRooms, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RoomConstraints_allowedRooms(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RoomConstraints",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RoomConstraints_placesWithSocket(ctx context.Context, field graphql.CollectedField, obj *model.RoomConstraints) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RoomConstraints_placesWithSocket(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PlacesWithSocket, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RoomConstraints_placesWithSocket(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RoomConstraints",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RoomConstraints_lab(ctx context.Context, field graphql.CollectedField, obj *model.RoomConstraints) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RoomConstraints_lab(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Lab, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RoomConstraints_lab(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RoomConstraints",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RoomConstraints_exahm(ctx context.Context, field graphql.CollectedField, obj *model.RoomConstraints) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RoomConstraints_exahm(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Exahm, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RoomConstraints_exahm(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RoomConstraints",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RoomConstraints_seb(ctx context.Context, field graphql.CollectedField, obj *model.RoomConstraints) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RoomConstraints_seb(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Seb, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RoomConstraints_seb(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RoomConstraints",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RoomConstraints_kdpJiraURL(ctx context.Context, field graphql.CollectedField, obj *model.RoomConstraints) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RoomConstraints_kdpJiraURL(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.KdpJiraURL, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RoomConstraints_kdpJiraURL(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RoomConstraints",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RoomConstraints_maxStudents(ctx context.Context, field graphql.CollectedField, obj *model.RoomConstraints) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RoomConstraints_maxStudents(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MaxStudents, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RoomConstraints_maxStudents(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RoomConstraints",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RoomConstraints_comments(ctx context.Context, field graphql.CollectedField, obj *model.RoomConstraints) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RoomConstraints_comments(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Comments, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RoomConstraints_comments(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RoomConstraints",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RoomWithInvigilator_name(ctx context.Context, field graphql.CollectedField, obj *model.RoomWithInvigilator) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RoomWithInvigilator_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RoomWithInvigilator_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RoomWithInvigilator",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RoomWithInvigilator_maxDuration(ctx context.Context, field graphql.CollectedField, obj *model.RoomWithInvigilator) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RoomWithInvigilator_maxDuration(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MaxDuration, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RoomWithInvigilator_maxDuration(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RoomWithInvigilator",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RoomWithInvigilator_studentCount(ctx context.Context, field graphql.CollectedField, obj *model.RoomWithInvigilator) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RoomWithInvigilator_studentCount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.StudentCount, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RoomWithInvigilator_studentCount(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RoomWithInvigilator",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RoomWithInvigilator_roomAndExams(ctx context.Context, field graphql.CollectedField, obj *model.RoomWithInvigilator) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RoomWithInvigilator_roomAndExams(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RoomAndExams, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.RoomAndExam)
	fc.Result = res
	return ec.marshalNRoomAndExam2githubcomobcodeplexamsgographmodelRoomAndExam(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RoomWithInvigilator_roomAndExams(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RoomWithInvigilator",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "room":
				return ec.fieldContext_RoomAndExam_room(ctx, field)
			case "exam":
				return ec.fieldContext_RoomAndExam_exam(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type RoomAndExam", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _RoomWithInvigilator_invigilator(ctx context.Context, field graphql.CollectedField, obj *model.RoomWithInvigilator) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RoomWithInvigilator_invigilator(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Invigilator, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.Teacher)
	fc.Result = res
	return ec.marshalOTeacher2githubcomobcodeplexamsgographmodelTeacher(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RoomWithInvigilator_invigilator(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RoomWithInvigilator",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "shortname":
				return ec.fieldContext_Teacher_shortname(ctx, field)
			case "fullname":
				return ec.fieldContext_Teacher_fullname(ctx, field)
			case "isProf":
				return ec.fieldContext_Teacher_isProf(ctx, field)
			case "isLBA":
				return ec.fieldContext_Teacher_isLBA(ctx, field)
			case "isProfHC":
				return ec.fieldContext_Teacher_isProfHC(ctx, field)
			case "isStaff":
				return ec.fieldContext_Teacher_isStaff(ctx, field)
			case "lastSemester":
				return ec.fieldContext_Teacher_lastSemester(ctx, field)
			case "fk":
				return ec.fieldContext_Teacher_fk(ctx, field)
			case "id":
				return ec.fieldContext_Teacher_id(ctx, field)
			case "email":
				return ec.fieldContext_Teacher_email(ctx, field)
			case "isActive":
				return ec.fieldContext_Teacher_isActive(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Teacher", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _RoomsForSlot_day(ctx context.Context, field graphql.CollectedField, obj *model.RoomsForSlot) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RoomsForSlot_day(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Day, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RoomsForSlot_day(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RoomsForSlot",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RoomsForSlot_slot(ctx context.Context, field graphql.CollectedField, obj *model.RoomsForSlot) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RoomsForSlot_slot(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Slot, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RoomsForSlot_slot(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RoomsForSlot",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RoomsForSlot_rooms(ctx context.Context, field graphql.CollectedField, obj *model.RoomsForSlot) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RoomsForSlot_rooms(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.RoomsForSlot().Rooms(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.Room)
	fc.Result = res
	return ec.marshalNRoom2githubcomobcodeplexamsgographmodelRoom(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RoomsForSlot_rooms(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RoomsForSlot",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext_Room_name(ctx, field)
			case "seats":
				return ec.fieldContext_Room_seats(ctx, field)
			case "handicap":
				return ec.fieldContext_Room_handicap(ctx, field)
			case "lab":
				return ec.fieldContext_Room_lab(ctx, field)
			case "placesWithSocket":
				return ec.fieldContext_Room_placesWithSocket(ctx, field)
			case "needsRequest":
				return ec.fieldContext_Room_needsRequest(ctx, field)
			case "exahm":
				return ec.fieldContext_Room_exahm(ctx, field)
			case "seb":
				return ec.fieldContext_Room_seb(ctx, field)
			case "sebSeats":
				return ec.fieldContext_Room_sebSeats(ctx, field)
			case "hmebSeats":
				return ec.fieldContext_Room_hmebSeats(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Room", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Semester_id(ctx context.Context, field graphql.CollectedField, obj *model.Semester) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Semester_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Semester_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Semester",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SemesterConfig_days(ctx context.Context, field graphql.CollectedField, obj *model.SemesterConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SemesterConfig_days(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Days, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.ExamDay)
	fc.Result = res
	return ec.marshalNExamDay2githubcomobcodeplexamsgographmodelExamDay(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SemesterConfig_days(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SemesterConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "number":
				return ec.fieldContext_ExamDay_number(ctx, field)
			case "date":
				return ec.fieldContext_ExamDay_date(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ExamDay", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _SemesterConfig_starttimes(ctx context.Context, field graphql.CollectedField, obj *model.SemesterConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SemesterConfig_starttimes(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Starttimes, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.Starttime)
	fc.Result = res
	return ec.marshalNStarttime2githubcomobcodeplexamsgographmodelStarttime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SemesterConfig_starttimes(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SemesterConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "number":
				return ec.fieldContext_Starttime_number(ctx, field)
			case "start":
				return ec.fieldContext_Starttime_start(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Starttime", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _SemesterConfig_slots(ctx context.Context, field graphql.CollectedField, obj *model.SemesterConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SemesterConfig_slots(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Slots, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.Slot)
	fc.Result = res
	return ec.marshalNSlot2githubcomobcodeplexamsgographmodelSlot(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SemesterConfig_slots(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SemesterConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "dayNumber":
				return ec.fieldContext_Slot_dayNumber(ctx, field)
			case "slotNumber":
				return ec.fieldContext_Slot_slotNumber(ctx, field)
			case "starttime":
				return ec.fieldContext_Slot_starttime(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Slot", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _SemesterConfig_goSlotsRaw(ctx context.Context, field graphql.CollectedField, obj *model.SemesterConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SemesterConfig_goSlotsRaw(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.GoSlotsRaw, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([][]int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SemesterConfig_goSlotsRaw(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SemesterConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SemesterConfig_goSlots(ctx context.Context, field graphql.CollectedField, obj *model.SemesterConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SemesterConfig_goSlots(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.GoSlots, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.Slot)
	fc.Result = res
	return ec.marshalNSlot2githubcomobcodeplexamsgographmodelSlot(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SemesterConfig_goSlots(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SemesterConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "dayNumber":
				return ec.fieldContext_Slot_dayNumber(ctx, field)
			case "slotNumber":
				return ec.fieldContext_Slot_slotNumber(ctx, field)
			case "starttime":
				return ec.fieldContext_Slot_starttime(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Slot", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _SemesterConfig_goDay0(ctx context.Context, field graphql.CollectedField, obj *model.SemesterConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SemesterConfig_goDay0(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.GoDay0, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SemesterConfig_goDay0(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SemesterConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SemesterConfig_forbiddenSlots(ctx context.Context, field graphql.CollectedField, obj *model.SemesterConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SemesterConfig_forbiddenSlots(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ForbiddenSlots, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.Slot)
	fc.Result = res
	return ec.marshalOSlot2githubcomobcodeplexamsgographmodelSlot(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SemesterConfig_forbiddenSlots(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SemesterConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "dayNumber":
				return ec.fieldContext_Slot_dayNumber(ctx, field)
			case "slotNumber":
				return ec.fieldContext_Slot_slotNumber(ctx, field)
			case "starttime":
				return ec.fieldContext_Slot_starttime(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Slot", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _SemesterConfig_from(ctx context.Context, field graphql.CollectedField, obj *model.SemesterConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SemesterConfig_from(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.From, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SemesterConfig_from(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SemesterConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SemesterConfig_fromFK07(ctx context.Context, field graphql.CollectedField, obj *model.SemesterConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SemesterConfig_fromFK07(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FromFk07, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SemesterConfig_fromFK07(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SemesterConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SemesterConfig_until(ctx context.Context, field graphql.CollectedField, obj *model.SemesterConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SemesterConfig_until(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Until, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SemesterConfig_until(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SemesterConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SemesterConfig_emails(ctx context.Context, field graphql.CollectedField, obj *model.SemesterConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SemesterConfig_emails(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Emails, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Emails)
	fc.Result = res
	return ec.marshalNEmails2githubcomobcodeplexamsgographmodelEmails(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SemesterConfig_emails(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SemesterConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "profs":
				return ec.fieldContext_Emails_profs(ctx, field)
			case "lbas":
				return ec.fieldContext_Emails_lbas(ctx, field)
			case "lbasLastSemester":
				return ec.fieldContext_Emails_lbasLastSemester(ctx, field)
			case "additionalExamer":
				return ec.fieldContext_Emails_additionalExamer(ctx, field)
			case "fs":
				return ec.fieldContext_Emails_fs(ctx, field)
			case "sekr":
				return ec.fieldContext_Emails_sekr(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Emails", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Slot_dayNumber(ctx context.Context, field graphql.CollectedField, obj *model.Slot) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Slot_dayNumber(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DayNumber, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Slot_dayNumber(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Slot",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Slot_slotNumber(ctx context.Context, field graphql.CollectedField, obj *model.Slot) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Slot_slotNumber(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SlotNumber, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Slot_slotNumber(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Slot",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Slot_starttime(ctx context.Context, field graphql.CollectedField, obj *model.Slot) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Slot_starttime(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Starttime, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Slot_starttime(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Slot",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Starttime_number(ctx context.Context, field graphql.CollectedField, obj *model.Starttime) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Starttime_number(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Number, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Starttime_number(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Starttime",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Starttime_start(ctx context.Context, field graphql.CollectedField, obj *model.Starttime) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Starttime_start(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Start, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Starttime_start(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Starttime",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Student_mtknr(ctx context.Context, field graphql.CollectedField, obj *model.Student) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Student_mtknr(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Mtknr, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Student_mtknr(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Student",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Student_program(ctx context.Context, field graphql.CollectedField, obj *model.Student) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Student_program(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Program, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Student_program(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Student",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Student_group(ctx context.Context, field graphql.CollectedField, obj *model.Student) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Student_group(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Group, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Student_group(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Student",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Student_name(ctx context.Context, field graphql.CollectedField, obj *model.Student) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Student_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Student_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Student",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Student_regs(ctx context.Context, field graphql.CollectedField, obj *model.Student) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Student_regs(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Regs, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Student_regs(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Student",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Student_regsWithProgram(ctx context.Context, field graphql.CollectedField, obj *model.Student) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Student_regsWithProgram(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RegsWithProgram, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.RegWithProgram)
	fc.Result = res
	return ec.marshalNRegWithProgram2githubcomobcodeplexamsgographmodelRegWithProgram(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Student_regsWithProgram(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Student",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "program":
				return ec.fieldContext_RegWithProgram_program(ctx, field)
			case "reg":
				return ec.fieldContext_RegWithProgram_reg(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type RegWithProgram", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Student_zpaStudent(ctx context.Context, field graphql.CollectedField, obj *model.Student) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Student_zpaStudent(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ZpaStudent, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.ZPAStudent)
	fc.Result = res
	return ec.marshalOZPAStudent2githubcomobcodeplexamsgographmodelZPAStudent(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Student_zpaStudent(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Student",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "Greeting":
				return ec.fieldContext_ZPAStudent_Greeting(ctx, field)
			case "FirstName":
				return ec.fieldContext_ZPAStudent_FirstName(ctx, field)
			case "LastName":
				return ec.fieldContext_ZPAStudent_LastName(ctx, field)
			case "Email":
				return ec.fieldContext_ZPAStudent_Email(ctx, field)
			case "Gender":
				return ec.fieldContext_ZPAStudent_Gender(ctx, field)
			case "Group":
				return ec.fieldContext_ZPAStudent_Group(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ZPAStudent", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Student_nta(ctx context.Context, field graphql.CollectedField, obj *model.Student) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Student_nta(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Nta, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.NTA)
	fc.Result = res
	return ec.marshalONTA2githubcomobcodeplexamsgographmodelNTA(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Student_nta(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Student",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext_NTA_name(ctx, field)
			case "email":
				return ec.fieldContext_NTA_email(ctx, field)
			case "mtknr":
				return ec.fieldContext_NTA_mtknr(ctx, field)
			case "compensation":
				return ec.fieldContext_NTA_compensation(ctx, field)
			case "deltaDurationPercent":
				return ec.fieldContext_NTA_deltaDurationPercent(ctx, field)
			case "needsRoomAlone":
				return ec.fieldContext_NTA_needsRoomAlone(ctx, field)
			case "needsHardware":
				return ec.fieldContext_NTA_needsHardware(ctx, field)
			case "program":
				return ec.fieldContext_NTA_program(ctx, field)
			case "from":
				return ec.fieldContext_NTA_from(ctx, field)
			case "until":
				return ec.fieldContext_NTA_until(ctx, field)
			case "lastSemester":
				return ec.fieldContext_NTA_lastSemester(ctx, field)
			case "exams":
				return ec.fieldContext_NTA_exams(ctx, field)
			case "deactivated":
				return ec.fieldContext_NTA_deactivated(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type NTA", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _StudentReg_mtknr(ctx context.Context, field graphql.CollectedField, obj *model.StudentReg) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_StudentReg_mtknr(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Mtknr, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_StudentReg_mtknr(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "StudentReg",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _StudentReg_ancode(ctx context.Context, field graphql.CollectedField, obj *model.StudentReg) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_StudentReg_ancode(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AnCode, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_StudentReg_ancode(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "StudentReg",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _StudentReg_program(ctx context.Context, field graphql.CollectedField, obj *model.StudentReg) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_StudentReg_program(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Program, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_StudentReg_program(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "StudentReg",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _StudentReg_group(ctx context.Context, field graphql.CollectedField, obj *model.StudentReg) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_StudentReg_group(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Group, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_StudentReg_group(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "StudentReg",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _StudentReg_name(ctx context.Context, field graphql.CollectedField, obj *model.StudentReg) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_StudentReg_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_StudentReg_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "StudentReg",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _StudentReg_presence(ctx context.Context, field graphql.CollectedField, obj *model.StudentReg) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_StudentReg_presence(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Presence, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_StudentReg_presence(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "StudentReg",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _StudentRegsPerAncode_ancode(ctx context.Context, field graphql.CollectedField, obj *model.StudentRegsPerAncode) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_StudentRegsPerAncode_ancode(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Ancode, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_StudentRegsPerAncode_ancode(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "StudentRegsPerAncode",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _StudentRegsPerAncode_perProgram(ctx context.Context, field graphql.CollectedField, obj *model.StudentRegsPerAncode) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_StudentRegsPerAncode_perProgram(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PerProgram, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.StudentRegsPerAncodeAndProgram)
	fc.Result = res
	return ec.marshalNStudentRegsPerAncodeAndProgram2githubcomobcodeplexamsgographmodelStudentRegsPerAncodeAndProgram(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_StudentRegsPerAncode_perProgram(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "StudentRegsPerAncode",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "program":
				return ec.fieldContext_StudentRegsPerAncodeAndProgram_program(ctx, field)
			case "ancode":
				return ec.fieldContext_StudentRegsPerAncodeAndProgram_ancode(ctx, field)
			case "studentRegs":
				return ec.fieldContext_StudentRegsPerAncodeAndProgram_studentRegs(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type StudentRegsPerAncodeAndProgram", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _StudentRegsPerAncodeAndProgram_program(ctx context.Context, field graphql.CollectedField, obj *model.StudentRegsPerAncodeAndProgram) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_StudentRegsPerAncodeAndProgram_program(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Program, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_StudentRegsPerAncodeAndProgram_program(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "StudentRegsPerAncodeAndProgram",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _StudentRegsPerAncodeAndProgram_ancode(ctx context.Context, field graphql.CollectedField, obj *model.StudentRegsPerAncodeAndProgram) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_StudentRegsPerAncodeAndProgram_ancode(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Ancode, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_StudentRegsPerAncodeAndProgram_ancode(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "StudentRegsPerAncodeAndProgram",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _StudentRegsPerAncodeAndProgram_studentRegs(ctx context.Context, field graphql.CollectedField, obj *model.StudentRegsPerAncodeAndProgram) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_StudentRegsPerAncodeAndProgram_studentRegs(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.StudentRegs, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.StudentReg)
	fc.Result = res
	return ec.marshalNStudentReg2githubcomobcodeplexamsgographmodelStudentReg(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_StudentRegsPerAncodeAndProgram_studentRegs(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "StudentRegsPerAncodeAndProgram",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "mtknr":
				return ec.fieldContext_StudentReg_mtknr(ctx, field)
			case "ancode":
				return ec.fieldContext_StudentReg_ancode(ctx, field)
			case "program":
				return ec.fieldContext_StudentReg_program(ctx, field)
			case "group":
				return ec.fieldContext_StudentReg_group(ctx, field)
			case "name":
				return ec.fieldContext_StudentReg_name(ctx, field)
			case "presence":
				return ec.fieldContext_StudentReg_presence(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type StudentReg", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _StudentRegsPerStudent_student(ctx context.Context, field graphql.CollectedField, obj *model.StudentRegsPerStudent) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_StudentRegsPerStudent_student(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Student, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Student)
	fc.Result = res
	return ec.marshalNStudent2githubcomobcodeplexamsgographmodelStudent(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_StudentRegsPerStudent_student(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "StudentRegsPerStudent",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "mtknr":
				return ec.fieldContext_Student_mtknr(ctx, field)
			case "program":
				return ec.fieldContext_Student_program(ctx, field)
			case "group":
				return ec.fieldContext_Student_group(ctx, field)
			case "name":
				return ec.fieldContext_Student_name(ctx, field)
			case "regs":
				return ec.fieldContext_Student_regs(ctx, field)
			case "regsWithProgram":
				return ec.fieldContext_Student_regsWithProgram(ctx, field)
			case "zpaStudent":
				return ec.fieldContext_Student_zpaStudent(ctx, field)
			case "nta":
				return ec.fieldContext_Student_nta(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Student", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _StudentRegsPerStudent_ancodes(ctx context.Context, field graphql.CollectedField, obj *model.StudentRegsPerStudent) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_StudentRegsPerStudent_ancodes(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Ancodes, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_StudentRegsPerStudent_ancodes(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "StudentRegsPerStudent",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Teacher_shortname(ctx context.Context, field graphql.CollectedField, obj *model.Teacher) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Teacher_shortname(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Shortname, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Teacher_shortname(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Teacher",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Teacher_fullname(ctx context.Context, field graphql.CollectedField, obj *model.Teacher) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Teacher_fullname(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Fullname, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Teacher_fullname(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Teacher",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Teacher_isProf(ctx context.Context, field graphql.CollectedField, obj *model.Teacher) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Teacher_isProf(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsProf, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Teacher_isProf(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Teacher",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Teacher_isLBA(ctx context.Context, field graphql.CollectedField, obj *model.Teacher) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Teacher_isLBA(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsLBA, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Teacher_isLBA(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Teacher",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Teacher_isProfHC(ctx context.Context, field graphql.CollectedField, obj *model.Teacher) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Teacher_isProfHC(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsProfHC, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Teacher_isProfHC(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Teacher",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Teacher_isStaff(ctx context.Context, field graphql.CollectedField, obj *model.Teacher) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Teacher_isStaff(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsStaff, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Teacher_isStaff(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Teacher",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Teacher_lastSemester(ctx context.Context, field graphql.CollectedField, obj *model.Teacher) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Teacher_lastSemester(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.LastSemester, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Teacher_lastSemester(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Teacher",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Teacher_fk(ctx context.Context, field graphql.CollectedField, obj *model.Teacher) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Teacher_fk(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FK, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Teacher_fk(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Teacher",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Teacher_id(ctx context.Context, field graphql.CollectedField, obj *model.Teacher) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Teacher_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Teacher_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Teacher",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Teacher_email(ctx context.Context, field graphql.CollectedField, obj *model.Teacher) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Teacher_email(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Email, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Teacher_email(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Teacher",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Teacher_isActive(ctx context.Context, field graphql.CollectedField, obj *model.Teacher) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Teacher_isActive(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsActive, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Teacher_isActive(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Teacher",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ZPAConflict_ancode(ctx context.Context, field graphql.CollectedField, obj *model.ZPAConflict) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ZPAConflict_ancode(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Ancode, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ZPAConflict_ancode(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ZPAConflict",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ZPAConflict_numberOfStuds(ctx context.Context, field graphql.CollectedField, obj *model.ZPAConflict) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ZPAConflict_numberOfStuds(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.NumberOfStuds, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ZPAConflict_numberOfStuds(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ZPAConflict",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ZPAConflict_primussAncodes(ctx context.Context, field graphql.CollectedField, obj *model.ZPAConflict) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ZPAConflict_primussAncodes(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PrimussAncodes, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.PrimussExamAncode)
	fc.Result = res
	return ec.marshalNPrimussExamAncode2githubcomobcodeplexamsgographmodelPrimussExamAncode(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ZPAConflict_primussAncodes(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ZPAConflict",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "ancode":
				return ec.fieldContext_PrimussExamAncode_ancode(ctx, field)
			case "program":
				return ec.fieldContext_PrimussExamAncode_program(ctx, field)
			case "numberOfStuds":
				return ec.fieldContext_PrimussExamAncode_numberOfStuds(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PrimussExamAncode", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ZPAExam_zpaID(ctx context.Context, field graphql.CollectedField, obj *model.ZPAExam) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ZPAExam_zpaID(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ZpaID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ZPAExam_zpaID(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ZPAExam",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ZPAExam_semester(ctx context.Context, field graphql.CollectedField, obj *model.ZPAExam) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ZPAExam_semester(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Semester, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ZPAExam_semester(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ZPAExam",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ZPAExam_ancode(ctx context.Context, field graphql.CollectedField, obj *model.ZPAExam) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ZPAExam_ancode(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AnCode, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ZPAExam_ancode(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ZPAExam",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ZPAExam_module(ctx context.Context, field graphql.CollectedField, obj *model.ZPAExam) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ZPAExam_module(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Module, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ZPAExam_module(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ZPAExam",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ZPAExam_mainExamer(ctx context.Context, field graphql.CollectedField, obj *model.ZPAExam) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ZPAExam_mainExamer(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MainExamer, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ZPAExam_mainExamer(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ZPAExam",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ZPAExam_mainExamerID(ctx context.Context, field graphql.CollectedField, obj *model.ZPAExam) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ZPAExam_mainExamerID(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MainExamerID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ZPAExam_mainExamerID(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ZPAExam",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ZPAExam_examType(ctx context.Context, field graphql.CollectedField, obj *model.ZPAExam) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ZPAExam_examType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ExamType, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ZPAExam_examType(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ZPAExam",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ZPAExam_examTypeFull(ctx context.Context, field graphql.CollectedField, obj *model.ZPAExam) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ZPAExam_examTypeFull(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ExamTypeFull, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ZPAExam_examTypeFull(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ZPAExam",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ZPAExam_duration(ctx context.Context, field graphql.CollectedField, obj *model.ZPAExam) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ZPAExam_duration(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Duration, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ZPAExam_duration(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ZPAExam",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ZPAExam_isRepeaterExam(ctx context.Context, field graphql.CollectedField, obj *model.ZPAExam) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ZPAExam_isRepeaterExam(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsRepeaterExam, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ZPAExam_isRepeaterExam(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ZPAExam",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ZPAExam_groups(ctx context.Context, field graphql.CollectedField, obj *model.ZPAExam) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ZPAExam_groups(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Groups, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ZPAExam_groups(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ZPAExam",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ZPAExam_primussAncodes(ctx context.Context, field graphql.CollectedField, obj *model.ZPAExam) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ZPAExam_primussAncodes(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PrimussAncodes, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]model.ZPAPrimussAncodes)
	fc.Result = res
	return ec.marshalNZPAPrimussAncodes2githubcomobcodeplexamsgographmodelZPAPrimussAncodes(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ZPAExam_primussAncodes(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ZPAExam",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "program":
				return ec.fieldContext_ZPAPrimussAncodes_program(ctx, field)
			case "ancode":
				return ec.fieldContext_ZPAPrimussAncodes_ancode(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ZPAPrimussAncodes", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ZPAExamWithConstraints_zpaExam(ctx context.Context, field graphql.CollectedField, obj *model.ZPAExamWithConstraints) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ZPAExamWithConstraints_zpaExam(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ZpaExam, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.ZPAExam)
	fc.Result = res
	return ec.marshalNZPAExam2githubcomobcodeplexamsgographmodelZPAExam(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ZPAExamWithConstraints_zpaExam(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ZPAExamWithConstraints",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "zpaID":
				return ec.fieldContext_ZPAExam_zpaID(ctx, field)
			case "semester":
				return ec.fieldContext_ZPAExam_semester(ctx, field)
			case "ancode":
				return ec.fieldContext_ZPAExam_ancode(ctx, field)
			case "module":
				return ec.fieldContext_ZPAExam_module(ctx, field)
			case "mainExamer":
				return ec.fieldContext_ZPAExam_mainExamer(ctx, field)
			case "mainExamerID":
				return ec.fieldContext_ZPAExam_mainExamerID(ctx, field)
			case "examType":
				return ec.fieldContext_ZPAExam_examType(ctx, field)
			case "examTypeFull":
				return ec.fieldContext_ZPAExam_examTypeFull(ctx, field)
			case "duration":
				return ec.fieldContext_ZPAExam_duration(ctx, field)
			case "isRepeaterExam":
				return ec.fieldContext_ZPAExam_isRepeaterExam(ctx, field)
			case "groups":
				return ec.fieldContext_ZPAExam_groups(ctx, field)
			case "primussAncodes":
				return ec.fieldContext_ZPAExam_primussAncodes(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ZPAExam", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ZPAExamWithConstraints_constraints(ctx context.Context, field graphql.CollectedField, obj *model.ZPAExamWithConstraints) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ZPAExamWithConstraints_constraints(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Constraints, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.Constraints)
	fc.Result = res
	return ec.marshalOConstraints2githubcomobcodeplexamsgographmodelConstraints(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ZPAExamWithConstraints_constraints(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ZPAExamWithConstraints",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "ancode":
				return ec.fieldContext_Constraints_ancode(ctx, field)
			case "notPlannedByMe":
				return ec.fieldContext_Constraints_notPlannedByMe(ctx, field)
			case "excludeDays":
				return ec.fieldContext_Constraints_excludeDays(ctx, field)
			case "possibleDays":
				return ec.fieldContext_Constraints_possibleDays(ctx, field)
			case "fixedDay":
				return ec.fieldContext_Constraints_fixedDay(ctx, field)
			case "fixedTime":
				return ec.fieldContext_Constraints_fixedTime(ctx, field)
			case "sameSlot":
				return ec.fieldContext_Constraints_sameSlot(ctx, field)
			case "online":
				return ec.fieldContext_Constraints_online(ctx, field)
			case "roomConstraints":
				return ec.fieldContext_Constraints_roomConstraints(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Constraints", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ZPAExamWithConstraints_planEntry(ctx context.Context, field graphql.CollectedField, obj *model.ZPAExamWithConstraints) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ZPAExamWithConstraints_planEntry(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PlanEntry, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.PlanEntry)
	fc.Result = res
	return ec.marshalOPlanEntry2githubcomobcodeplexamsgographmodelPlanEntry(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ZPAExamWithConstraints_planEntry(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ZPAExamWithConstraints",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "dayNumber":
				return ec.fieldContext_PlanEntry_dayNumber(ctx, field)
			case "slotNumber":
				return ec.fieldContext_PlanEntry_slotNumber(ctx, field)
			case "starttime":
				return ec.fieldContext_PlanEntry_starttime(ctx, field)
			case "ancode":
				return ec.fieldContext_PlanEntry_ancode(ctx, field)
			case "locked":
				return ec.fieldContext_PlanEntry_locked(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PlanEntry", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ZPAExamsForType_type(ctx context.Context, field graphql.CollectedField, obj *model.ZPAExamsForType) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ZPAExamsForType_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ZPAExamsForType_type(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ZPAExamsForType",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ZPAExamsForType_exams(ctx context.Context, field graphql.CollectedField, obj *model.ZPAExamsForType) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ZPAExamsForType_exams(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Exams, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.ZPAExam)
	fc.Result = res
	return ec.marshalNZPAExam2githubcomobcodeplexamsgographmodelZPAExam(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ZPAExamsForType_exams(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ZPAExamsForType",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "zpaID":
				return ec.fieldContext_ZPAExam_zpaID(ctx, field)
			case "semester":
				return ec.fieldContext_ZPAExam_semester(ctx, field)
			case "ancode":
				return ec.fieldContext_ZPAExam_ancode(ctx, field)
			case "module":
				return ec.fieldContext_ZPAExam_module(ctx, field)
			case "mainExamer":
				return ec.fieldContext_ZPAExam_mainExamer(ctx, field)
			case "mainExamerID":
				return ec.fieldContext_ZPAExam_mainExamerID(ctx, field)
			case "examType":
				return ec.fieldContext_ZPAExam_examType(ctx, field)
			case "examTypeFull":
				return ec.fieldContext_ZPAExam_examTypeFull(ctx, field)
			case "duration":
				return ec.fieldContext_ZPAExam_duration(ctx, field)
			case "isRepeaterExam":
				return ec.fieldContext_ZPAExam_isRepeaterExam(ctx, field)
			case "groups":
				return ec.fieldContext_ZPAExam_groups(ctx, field)
			case "primussAncodes":
				return ec.fieldContext_ZPAExam_primussAncodes(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ZPAExam", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ZPAInvigilator_teacher(ctx context.Context, field graphql.CollectedField, obj *model.ZPAInvigilator) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ZPAInvigilator_teacher(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Teacher, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Teacher)
	fc.Result = res
	return ec.marshalNTeacher2githubcomobcodeplexamsgographmodelTeacher(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ZPAInvigilator_teacher(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ZPAInvigilator",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "shortname":
				return ec.fieldContext_Teacher_shortname(ctx, field)
			case "fullname":
				return ec.fieldContext_Teacher_fullname(ctx, field)
			case "isProf":
				return ec.fieldContext_Teacher_isProf(ctx, field)
			case "isLBA":
				return ec.fieldContext_Teacher_isLBA(ctx, field)
			case "isProfHC":
				return ec.fieldContext_Teacher_isProfHC(ctx, field)
			case "isStaff":
				return ec.fieldContext_Teacher_isStaff(ctx, field)
			case "lastSemester":
				return ec.fieldContext_Teacher_lastSemester(ctx, field)
			case "fk":
				return ec.fieldContext_Teacher_fk(ctx, field)
			case "id":
				return ec.fieldContext_Teacher_id(ctx, field)
			case "email":
				return ec.fieldContext_Teacher_email(ctx, field)
			case "isActive":
				return ec.fieldContext_Teacher_isActive(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Teacher", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ZPAInvigilator_hasSubmittedRequirements(ctx context.Context, field graphql.CollectedField, obj *model.ZPAInvigilator) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ZPAInvigilator_hasSubmittedRequirements(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.HasSubmittedRequirements, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ZPAInvigilator_hasSubmittedRequirements(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ZPAInvigilator",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ZPAPrimussAncodes_program(ctx context.Context, field graphql.CollectedField, obj *model.ZPAPrimussAncodes) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ZPAPrimussAncodes_program(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Program, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ZPAPrimussAncodes_program(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ZPAPrimussAncodes",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ZPAPrimussAncodes_ancode(ctx context.Context, field graphql.CollectedField, obj *model.ZPAPrimussAncodes) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ZPAPrimussAncodes_ancode(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Ancode, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ZPAPrimussAncodes_ancode(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ZPAPrimussAncodes",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ZPAStudent_Greeting(ctx context.Context, field graphql.CollectedField, obj *model.ZPAStudent) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ZPAStudent_Greeting(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Greeting, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ZPAStudent_Greeting(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ZPAStudent",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ZPAStudent_FirstName(ctx context.Context, field graphql.CollectedField, obj *model.ZPAStudent) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ZPAStudent_FirstName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FirstName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ZPAStudent_FirstName(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ZPAStudent",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ZPAStudent_LastName(ctx context.Context, field graphql.CollectedField, obj *model.ZPAStudent) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ZPAStudent_LastName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.LastName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ZPAStudent_LastName(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ZPAStudent",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ZPAStudent_Email(ctx context.Context, field graphql.CollectedField, obj *model.ZPAStudent) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ZPAStudent_Email(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Email, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ZPAStudent_Email(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ZPAStudent",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ZPAStudent_Gender(ctx context.Context, field graphql.CollectedField, obj *model.ZPAStudent) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ZPAStudent_Gender(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Gender, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ZPAStudent_Gender(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ZPAStudent",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ZPAStudent_Group(ctx context.Context, field graphql.CollectedField, obj *model.ZPAStudent) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ZPAStudent_Group(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Group, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ZPAStudent_Group(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ZPAStudent",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ZPAStudentReg_ancode(ctx context.Context, field graphql.CollectedField, obj *model.ZPAStudentReg) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ZPAStudentReg_ancode(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AnCode, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ZPAStudentReg_ancode(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ZPAStudentReg",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ZPAStudentReg_mtknr(ctx context.Context, field graphql.CollectedField, obj *model.ZPAStudentReg) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ZPAStudentReg_mtknr(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Mtknr, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ZPAStudentReg_mtknr(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ZPAStudentReg",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ZPAStudentReg_program(ctx context.Context, field graphql.CollectedField, obj *model.ZPAStudentReg) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ZPAStudentReg_program(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Program, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ZPAStudentReg_program(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ZPAStudentReg",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ZPAStudentRegError_semester(ctx context.Context, field graphql.CollectedField, obj *model.ZPAStudentRegError) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ZPAStudentRegError_semester(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Semester, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ZPAStudentRegError_semester(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ZPAStudentRegError",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ZPAStudentRegError_ancode(ctx context.Context, field graphql.CollectedField, obj *model.ZPAStudentRegError) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ZPAStudentRegError_ancode(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AnCode, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ZPAStudentRegError_ancode(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ZPAStudentRegError",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ZPAStudentRegError_exam(ctx context.Context, field graphql.CollectedField, obj *model.ZPAStudentRegError) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ZPAStudentRegError_exam(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Exam, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ZPAStudentRegError_exam(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ZPAStudentRegError",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ZPAStudentRegError_mtknr(ctx context.Context, field graphql.CollectedField, obj *model.ZPAStudentRegError) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ZPAStudentRegError_mtknr(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Mtknr, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ZPAStudentRegError_mtknr(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ZPAStudentRegError",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ZPAStudentRegError_program(ctx context.Context, field graphql.CollectedField, obj *model.ZPAStudentRegError) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ZPAStudentRegError_program(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Program, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ZPAStudentRegError_program(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ZPAStudentRegError",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Directive_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Directive_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Directive_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Directive_description(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_isRepeatable(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Directive_isRepeatable(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsRepeatable, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Directive_isRepeatable(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_locations(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Directive_locations(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Locations, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalN__DirectiveLocation2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Directive_locations(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type __DirectiveLocation does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_args(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Directive_args(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Args, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.InputValue)
	fc.Result = res
	return ec.marshalN__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Directive_args(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___InputValue_name(ctx, field)
			case "description":
				return ec.fieldContext___InputValue_description(ctx, field)
			case "type":
				return ec.fieldContext___InputValue_type(ctx, field)
			case "defaultValue":
				return ec.fieldContext___InputValue_defaultValue(ctx, field)
			case "isDeprecated":
				return ec.fieldContext___InputValue_isDeprecated(ctx, field)
			case "deprecationReason":
				return ec.fieldContext___InputValue_deprecationReason(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __InputValue", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field___Directive_args_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) ___EnumValue_name(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___EnumValue_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___EnumValue_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__EnumValue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___EnumValue_description(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___EnumValue_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___EnumValue_description(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__EnumValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___EnumValue_isDeprecated(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___EnumValue_isDeprecated(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsDeprecated(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___EnumValue_isDeprecated(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__EnumValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___EnumValue_deprecationReason(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___EnumValue_deprecationReason(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeprecationReason(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___EnumValue_deprecationReason(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__EnumValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_description(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_args(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_args(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Args, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.InputValue)
	fc.Result = res
	return ec.marshalN__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_args(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___InputValue_name(ctx, field)
			case "description":
				return ec.fieldContext___InputValue_description(ctx, field)
			case "type":
				return ec.fieldContext___InputValue_type(ctx, field)
			case "defaultValue":
				return ec.fieldContext___InputValue_defaultValue(ctx, field)
			case "isDeprecated":
				return ec.fieldContext___InputValue_isDeprecated(ctx, field)
			case "deprecationReason":
				return ec.fieldContext___InputValue_deprecationReason(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __InputValue", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field___Field_args_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) ___Field_type(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_type(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "isOneOf":
				return ec.fieldContext___Type_isOneOf(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_isDeprecated(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_isDeprecated(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsDeprecated(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_isDeprecated(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_deprecationReason(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_deprecationReason(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeprecationReason(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_deprecationReason(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_name(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___InputValue_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___InputValue_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_description(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___InputValue_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___InputValue_description(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_type(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___InputValue_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___InputValue_type(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "isOneOf":
				return ec.fieldContext___Type_isOneOf(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_defaultValue(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___InputValue_defaultValue(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DefaultValue, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___InputValue_defaultValue(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_isDeprecated(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___InputValue_isDeprecated(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsDeprecated(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___InputValue_isDeprecated(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_deprecationReason(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___InputValue_deprecationReason(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeprecationReason(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___InputValue_deprecationReason(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_description(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_types(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_types(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Types(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.Type)
	fc.Result = res
	return ec.marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_types(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "isOneOf":
				return ec.fieldContext___Type_isOneOf(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_queryType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_queryType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.QueryType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_queryType(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "isOneOf":
				return ec.fieldContext___Type_isOneOf(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_mutationType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_mutationType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MutationType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_mutationType(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "isOneOf":
				return ec.fieldContext___Type_isOneOf(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_subscriptionType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_subscriptionType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SubscriptionType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_subscriptionType(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "isOneOf":
				return ec.fieldContext___Type_isOneOf(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_directives(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_directives(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Directives(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.Directive)
	fc.Result = res
	return ec.marshalN__Directive2githubcom99designsgqlgengraphqlintrospectionDirective(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_directives(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___Directive_name(ctx, field)
			case "description":
				return ec.fieldContext___Directive_description(ctx, field)
			case "isRepeatable":
				return ec.fieldContext___Directive_isRepeatable(ctx, field)
			case "locations":
				return ec.fieldContext___Directive_locations(ctx, field)
			case "args":
				return ec.fieldContext___Directive_args(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Directive", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_kind(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_kind(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Kind(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalN__TypeKind2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_kind(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type __TypeKind does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_description(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_specifiedByURL(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_specifiedByURL(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SpecifiedByURL(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_specifiedByURL(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_fields(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_fields(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Fields(fc.Args["includeDeprecated"].(bool)), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.Field)
	fc.Result = res
	return ec.marshalO__Field2githubcom99designsgqlgengraphqlintrospectionField(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_fields(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___Field_name(ctx, field)
			case "description":
				return ec.fieldContext___Field_description(ctx, field)
			case "args":
				return ec.fieldContext___Field_args(ctx, field)
			case "type":
				return ec.fieldContext___Field_type(ctx, field)
			case "isDeprecated":
				return ec.fieldContext___Field_isDeprecated(ctx, field)
			case "deprecationReason":
				return ec.fieldContext___Field_deprecationReason(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Field", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field___Type_fields_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) ___Type_interfaces(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_interfaces(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Interfaces(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_interfaces(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "isOneOf":
				return ec.fieldContext___Type_isOneOf(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_possibleTypes(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_possibleTypes(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PossibleTypes(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_possibleTypes(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "isOneOf":
				return ec.fieldContext___Type_isOneOf(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_enumValues(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_enumValues(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EnumValues(fc.Args["includeDeprecated"].(bool)), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.EnumValue)
	fc.Result = res
	return ec.marshalO__EnumValue2githubcom99designsgqlgengraphqlintrospectionEnumValue(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_enumValues(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___EnumValue_name(ctx, field)
			case "description":
				return ec.fieldContext___EnumValue_description(ctx, field)
			case "isDeprecated":
				return ec.fieldContext___EnumValue_isDeprecated(ctx, field)
			case "deprecationReason":
				return ec.fieldContext___EnumValue_deprecationReason(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __EnumValue", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field___Type_enumValues_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) ___Type_inputFields(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_inputFields(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.InputFields(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.InputValue)
	fc.Result = res
	return ec.marshalO__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_inputFields(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___InputValue_name(ctx, field)
			case "description":
				return ec.fieldContext___InputValue_description(ctx, field)
			case "type":
				return ec.fieldContext___InputValue_type(ctx, field)
			case "defaultValue":
				return ec.fieldContext___InputValue_defaultValue(ctx, field)
			case "isDeprecated":
				return ec.fieldContext___InputValue_isDeprecated(ctx, field)
			case "deprecationReason":
				return ec.fieldContext___InputValue_deprecationReason(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __InputValue", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_ofType(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_ofType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.OfType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_ofType(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "isOneOf":
				return ec.fieldContext___Type_isOneOf(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_isOneOf(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_isOneOf(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsOneOf(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalOBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_isOneOf(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

// endregion **************************** field.gotpl *****************************

// region    **************************** input.gotpl *****************************

func (ec *executionContext) unmarshalInputConstraintsInput(ctx context.Context, obj any) (model.ConstraintsInput, error) {
	var it model.ConstraintsInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"allowedRooms", "notPlannedByMe", "excludeDays", "possibleDays", "fixedDay", "fixedTime", "sameSlot", "online", "placesWithSocket", "lab", "exahm", "seb", "kdpJiraURL", "maxStudents", "comments"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "allowedRooms":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("allowedRooms"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.AllowedRooms = data
		case "notPlannedByMe":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("notPlannedByMe"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.NotPlannedByMe = data
		case "excludeDays":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("excludeDays"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.ExcludeDays = data
		case "possibleDays":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("possibleDays"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.PossibleDays = data
		case "fixedDay":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("fixedDay"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.FixedDay = data
		case "fixedTime":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("fixedTime"))
			data, err := ec.unmarshalOTime2timeTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.FixedTime = data
		case "sameSlot":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("sameSlot"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.SameSlot = data
		case "online":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("online"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.Online = data
		case "placesWithSocket":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("placesWithSocket"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.PlacesWithSocket = data
		case "lab":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("lab"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.Lab = data
		case "exahm":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("exahm"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.Exahm = data
		case "seb":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("seb"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.Seb = data
		case "kdpJiraURL":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("kdpJiraURL"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.KdpJiraURL = data
		case "maxStudents":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("maxStudents"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.MaxStudents = data
		case "comments":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("comments"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Comments = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputNTAInput(ctx context.Context, obj any) (model.NTAInput, error) {
	var it model.NTAInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"name", "email", "mtknr", "compensation", "deltaDurationPercent", "needsRoomAlone", "needsHardware", "program", "from", "until"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "email":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("email"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Email = data
		case "mtknr":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("mtknr"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Mtknr = data
		case "compensation":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("compensation"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Compensation = data
		case "deltaDurationPercent":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("deltaDurationPercent"))
			data, err := ec.unmarshalNInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.DeltaDurationPercent = data
		case "needsRoomAlone":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("needsRoomAlone"))
			data, err := ec.unmarshalNBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.NeedsRoomAlone = data
		case "needsHardware":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("needsHardware"))
			data, err := ec.unmarshalNBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.NeedsHardware = data
		case "program":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("program"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Program = data
		case "from":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("from"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.From = data
		case "until":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("until"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Until = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputPrimussExamInput(ctx context.Context, obj any) (model.PrimussExamInput, error) {
	var it model.PrimussExamInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"ancode", "program"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "ancode":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("ancode"))
			data, err := ec.unmarshalNInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.Ancode = data
		case "program":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("program"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Program = data
		}
	}

	return it, nil
}

// endregion **************************** input.gotpl *****************************

// region    ************************** interface.gotpl ***************************

// endregion ************************** interface.gotpl ***************************

// region    **************************** object.gotpl ****************************

var anCodeImplementors = []string{"AnCode"}

func (ec *executionContext) _AnCode(ctx context.Context, sel ast.SelectionSet, obj *model.AnCode) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, anCodeImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("AnCode")
		case "ancode":
			out.Values[i] = ec._AnCode_ancode(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var conflictImplementors = []string{"Conflict"}

func (ec *executionContext) _Conflict(ctx context.Context, sel ast.SelectionSet, obj *model.Conflict) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, conflictImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Conflict")
		case "ancode":
			out.Values[i] = ec._Conflict_ancode(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "numberOfStuds":
			out.Values[i] = ec._Conflict_numberOfStuds(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var conflictPerProgramImplementors = []string{"ConflictPerProgram"}

func (ec *executionContext) _ConflictPerProgram(ctx context.Context, sel ast.SelectionSet, obj *model.ConflictPerProgram) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, conflictPerProgramImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ConflictPerProgram")
		case "program":
			out.Values[i] = ec._ConflictPerProgram_program(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "conflicts":
			out.Values[i] = ec._ConflictPerProgram_conflicts(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var conflictsImplementors = []string{"Conflicts"}

func (ec *executionContext) _Conflicts(ctx context.Context, sel ast.SelectionSet, obj *model.Conflicts) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, conflictsImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Conflicts")
		case "ancode":
			out.Values[i] = ec._Conflicts_ancode(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "module":
			out.Values[i] = ec._Conflicts_module(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "mainExamer":
			out.Values[i] = ec._Conflicts_mainExamer(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "conflicts":
			out.Values[i] = ec._Conflicts_conflicts(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var conflictsPerProgramAncodeImplementors = []string{"ConflictsPerProgramAncode"}

func (ec *executionContext) _ConflictsPerProgramAncode(ctx context.Context, sel ast.SelectionSet, obj *model.ConflictsPerProgramAncode) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, conflictsPerProgramAncodeImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ConflictsPerProgramAncode")
		case "program":
			out.Values[i] = ec._ConflictsPerProgramAncode_program(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "ancode":
			out.Values[i] = ec._ConflictsPerProgramAncode_ancode(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "conflicts":
			out.Values[i] = ec._ConflictsPerProgramAncode_conflicts(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var connectedExamImplementors = []string{"ConnectedExam"}

func (ec *executionContext) _ConnectedExam(ctx context.Context, sel ast.SelectionSet, obj *model.ConnectedExam) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, connectedExamImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ConnectedExam")
		case "zpaExam":
			out.Values[i] = ec._ConnectedExam_zpaExam(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "primussExams":
			out.Values[i] = ec._ConnectedExam_primussExams(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "otherPrimussExams":
			out.Values[i] = ec._ConnectedExam_otherPrimussExams(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "errors":
			out.Values[i] = ec._ConnectedExam_errors(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var constraintsImplementors = []string{"Constraints"}

func (ec *executionContext) _Constraints(ctx context.Context, sel ast.SelectionSet, obj *model.Constraints) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, constraintsImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Constraints")
		case "ancode":
			out.Values[i] = ec._Constraints_ancode(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "notPlannedByMe":
			out.Values[i] = ec._Constraints_notPlannedByMe(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "excludeDays":
			out.Values[i] = ec._Constraints_excludeDays(ctx, field, obj)
		case "possibleDays":
			out.Values[i] = ec._Constraints_possibleDays(ctx, field, obj)
		case "fixedDay":
			out.Values[i] = ec._Constraints_fixedDay(ctx, field, obj)
		case "fixedTime":
			out.Values[i] = ec._Constraints_fixedTime(ctx, field, obj)
		case "sameSlot":
			out.Values[i] = ec._Constraints_sameSlot(ctx, field, obj)
		case "online":
			out.Values[i] = ec._Constraints_online(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "roomConstraints":
			out.Values[i] = ec._Constraints_roomConstraints(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var emailsImplementors = []string{"Emails"}

func (ec *executionContext) _Emails(ctx context.Context, sel ast.SelectionSet, obj *model.Emails) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, emailsImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Emails")
		case "profs":
			out.Values[i] = ec._Emails_profs(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "lbas":
			out.Values[i] = ec._Emails_lbas(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "lbasLastSemester":
			out.Values[i] = ec._Emails_lbasLastSemester(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "additionalExamer":
			out.Values[i] = ec._Emails_additionalExamer(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "fs":
			out.Values[i] = ec._Emails_fs(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "sekr":
			out.Values[i] = ec._Emails_sekr(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var enhancedPrimussExamImplementors = []string{"EnhancedPrimussExam"}

func (ec *executionContext) _EnhancedPrimussExam(ctx context.Context, sel ast.SelectionSet, obj *model.EnhancedPrimussExam) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, enhancedPrimussExamImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("EnhancedPrimussExam")
		case "exam":
			out.Values[i] = ec._EnhancedPrimussExam_exam(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "studentRegs":
			out.Values[i] = ec._EnhancedPrimussExam_studentRegs(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "conflicts":
			out.Values[i] = ec._EnhancedPrimussExam_conflicts(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "ntas":
			out.Values[i] = ec._EnhancedPrimussExam_ntas(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var examDayImplementors = []string{"ExamDay"}

func (ec *executionContext) _ExamDay(ctx context.Context, sel ast.SelectionSet, obj *model.ExamDay) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, examDayImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ExamDay")
		case "number":
			out.Values[i] = ec._ExamDay_number(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "date":
			out.Values[i] = ec._ExamDay_date(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var examWithRegsAndRoomsImplementors = []string{"ExamWithRegsAndRooms"}

func (ec *executionContext) _ExamWithRegsAndRooms(ctx context.Context, sel ast.SelectionSet, obj *model.ExamWithRegsAndRooms) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, examWithRegsAndRoomsImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ExamWithRegsAndRooms")
		case "exam":
			out.Values[i] = ec._ExamWithRegsAndRooms_exam(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "normalRegsMtknr":
			out.Values[i] = ec._ExamWithRegsAndRooms_normalRegsMtknr(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "ntasInNormalRooms":
			out.Values[i] = ec._ExamWithRegsAndRooms_ntasInNormalRooms(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "ntasInAloneRooms":
			out.Values[i] = ec._ExamWithRegsAndRooms_ntasInAloneRooms(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "rooms":
			out.Values[i] = ec._ExamWithRegsAndRooms_rooms(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var examerInPlanImplementors = []string{"ExamerInPlan"}

func (ec *executionContext) _ExamerInPlan(ctx context.Context, sel ast.SelectionSet, obj *model.ExamerInPlan) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, examerInPlanImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ExamerInPlan")
		case "mainExamer":
			out.Values[i] = ec._ExamerInPlan_mainExamer(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "mainExamerID":
			out.Values[i] = ec._ExamerInPlan_mainExamerID(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var fK07ProgramImplementors = []string{"FK07Program"}

func (ec *executionContext) _FK07Program(ctx context.Context, sel ast.SelectionSet, obj *model.FK07Program) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, fK07ProgramImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("FK07Program")
		case "name":
			out.Values[i] = ec._FK07Program_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var generatedExamImplementors = []string{"GeneratedExam"}

func (ec *executionContext) _GeneratedExam(ctx context.Context, sel ast.SelectionSet, obj *model.GeneratedExam) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, generatedExamImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("GeneratedExam")
		case "ancode":
			out.Values[i] = ec._GeneratedExam_ancode(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "zpaExam":
			out.Values[i] = ec._GeneratedExam_zpaExam(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "mainExamer":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._GeneratedExam_mainExamer(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "primussExams":
			out.Values[i] = ec._GeneratedExam_primussExams(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "constraints":
			out.Values[i] = ec._GeneratedExam_constraints(ctx, field, obj)
		case "conflicts":
			out.Values[i] = ec._GeneratedExam_conflicts(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "studentRegsCount":
			out.Values[i] = ec._GeneratedExam_studentRegsCount(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "ntas":
			out.Values[i] = ec._GeneratedExam_ntas(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "maxDuration":
			out.Values[i] = ec._GeneratedExam_maxDuration(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var invigilationImplementors = []string{"Invigilation"}

func (ec *executionContext) _Invigilation(ctx context.Context, sel ast.SelectionSet, obj *model.Invigilation) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, invigilationImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Invigilation")
		case "roomName":
			out.Values[i] = ec._Invigilation_roomName(ctx, field, obj)
		case "duration":
			out.Values[i] = ec._Invigilation_duration(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "invigilatorID":
			out.Values[i] = ec._Invigilation_invigilatorID(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "slot":
			out.Values[i] = ec._Invigilation_slot(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "isReserve":
			out.Values[i] = ec._Invigilation_isReserve(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "isSelfInvigilation":
			out.Values[i] = ec._Invigilation_isSelfInvigilation(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var invigilationSlotImplementors = []string{"InvigilationSlot"}

func (ec *executionContext) _InvigilationSlot(ctx context.Context, sel ast.SelectionSet, obj *model.InvigilationSlot) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, invigilationSlotImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("InvigilationSlot")
		case "reserve":
			out.Values[i] = ec._InvigilationSlot_reserve(ctx, field, obj)
		case "roomsWithInvigilators":
			out.Values[i] = ec._InvigilationSlot_roomsWithInvigilators(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var invigilationTodosImplementors = []string{"InvigilationTodos"}

func (ec *executionContext) _InvigilationTodos(ctx context.Context, sel ast.SelectionSet, obj *model.InvigilationTodos) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, invigilationTodosImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("InvigilationTodos")
		case "sumExamRooms":
			out.Values[i] = ec._InvigilationTodos_sumExamRooms(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "sumReserve":
			out.Values[i] = ec._InvigilationTodos_sumReserve(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "sumOtherContributions":
			out.Values[i] = ec._InvigilationTodos_sumOtherContributions(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "sumOtherContributionsOvertimeCutted":
			out.Values[i] = ec._InvigilationTodos_sumOtherContributionsOvertimeCutted(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "invigilatorCount":
			out.Values[i] = ec._InvigilationTodos_invigilatorCount(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "todoPerInvigilator":
			out.Values[i] = ec._InvigilationTodos_todoPerInvigilator(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "todoPerInvigilatorOvertimeCutted":
			out.Values[i] = ec._InvigilationTodos_todoPerInvigilatorOvertimeCutted(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "invigilators":
			out.Values[i] = ec._InvigilationTodos_invigilators(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var invigilatorImplementors = []string{"Invigilator"}

func (ec *executionContext) _Invigilator(ctx context.Context, sel ast.SelectionSet, obj *model.Invigilator) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, invigilatorImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Invigilator")
		case "teacher":
			out.Values[i] = ec._Invigilator_teacher(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "requirements":
			out.Values[i] = ec._Invigilator_requirements(ctx, field, obj)
		case "todos":
			out.Values[i] = ec._Invigilator_todos(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var invigilatorRequirementsImplementors = []string{"InvigilatorRequirements"}

func (ec *executionContext) _InvigilatorRequirements(ctx context.Context, sel ast.SelectionSet, obj *model.InvigilatorRequirements) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, invigilatorRequirementsImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("InvigilatorRequirements")
		case "excludedDates":
			out.Values[i] = ec._InvigilatorRequirements_excludedDates(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "excludedDays":
			out.Values[i] = ec._InvigilatorRequirements_excludedDays(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "examDateTimes":
			out.Values[i] = ec._InvigilatorRequirements_examDateTimes(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "examDays":
			out.Values[i] = ec._InvigilatorRequirements_examDays(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "partTime":
			out.Values[i] = ec._InvigilatorRequirements_partTime(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "oralExamsContribution":
			out.Values[i] = ec._InvigilatorRequirements_oralExamsContribution(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "liveCodingContribution":
			out.Values[i] = ec._InvigilatorRequirements_liveCodingContribution(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "masterContribution":
			out.Values[i] = ec._InvigilatorRequirements_masterContribution(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "freeSemester":
			out.Values[i] = ec._InvigilatorRequirements_freeSemester(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "overtimeLastSemester":
			out.Values[i] = ec._InvigilatorRequirements_overtimeLastSemester(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "overtimeThisSemester":
			out.Values[i] = ec._InvigilatorRequirements_overtimeThisSemester(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "allContributions":
			out.Values[i] = ec._InvigilatorRequirements_allContributions(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "factor":
			out.Values[i] = ec._InvigilatorRequirements_factor(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "onlyInSlots":
			out.Values[i] = ec._InvigilatorRequirements_onlyInSlots(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var invigilatorTodosImplementors = []string{"InvigilatorTodos"}

func (ec *executionContext) _InvigilatorTodos(ctx context.Context, sel ast.SelectionSet, obj *model.InvigilatorTodos) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, invigilatorTodosImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("InvigilatorTodos")
		case "totalMinutes":
			out.Values[i] = ec._InvigilatorTodos_totalMinutes(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "doingMinutes":
			out.Values[i] = ec._InvigilatorTodos_doingMinutes(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "enough":
			out.Values[i] = ec._InvigilatorTodos_enough(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "invigilationDays":
			out.Values[i] = ec._InvigilatorTodos_invigilationDays(ctx, field, obj)
		case "invigilations":
			out.Values[i] = ec._InvigilatorTodos_invigilations(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var invigilatorsForDayImplementors = []string{"InvigilatorsForDay"}

func (ec *executionContext) _InvigilatorsForDay(ctx context.Context, sel ast.SelectionSet, obj *model.InvigilatorsForDay) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, invigilatorsForDayImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("InvigilatorsForDay")
		case "want":
			out.Values[i] = ec._InvigilatorsForDay_want(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "can":
			out.Values[i] = ec._InvigilatorsForDay_can(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var mucDaiExamImplementors = []string{"MucDaiExam"}

func (ec *executionContext) _MucDaiExam(ctx context.Context, sel ast.SelectionSet, obj *model.MucDaiExam) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, mucDaiExamImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("MucDaiExam")
		case "primussAncode":
			out.Values[i] = ec._MucDaiExam_primussAncode(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "module":
			out.Values[i] = ec._MucDaiExam_module(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "mainExamer":
			out.Values[i] = ec._MucDaiExam_mainExamer(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "mainExamerID":
			out.Values[i] = ec._MucDaiExam_mainExamerID(ctx, field, obj)
		case "examType":
			out.Values[i] = ec._MucDaiExam_examType(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "duration":
			out.Values[i] = ec._MucDaiExam_duration(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "isRepeaterExam":
			out.Values[i] = ec._MucDaiExam_isRepeaterExam(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "program":
			out.Values[i] = ec._MucDaiExam_program(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "plannedBy":
			out.Values[i] = ec._MucDaiExam_plannedBy(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var mutationImplementors = []string{"Mutation"}

func (ec *executionContext) _Mutation(ctx context.Context, sel ast.SelectionSet) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, mutationImplementors)
	ctx = graphql.WithFieldContext(ctx, &graphql.FieldContext{
		Object: "Mutation",
	})

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		innerCtx := graphql.WithRootFieldContext(ctx, &graphql.RootFieldContext{
			Object: field.Name,
			Field:  field,
		})

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Mutation")
		case "notPlannedByMe":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_notPlannedByMe(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "excludeDays":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_excludeDays(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "possibleDays":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_possibleDays(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "sameSlot":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_sameSlot(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "placesWithSockets":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_placesWithSockets(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "lab":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_lab(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "exahm":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_exahm(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "seb":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_seb(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "online":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_online(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "addConstraints":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_addConstraints(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "rmConstraints":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_rmConstraints(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "addNTA":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_addNTA(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "addExamToSlot":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_addExamToSlot(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "rmExamFromSlot":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_rmExamFromSlot(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "prePlanRoom":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_prePlanRoom(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "zpaExamsToPlan":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_zpaExamsToPlan(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "addZpaExamToPlan":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_addZpaExamToPlan(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "rmZpaExamFromPlan":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_rmZpaExamFromPlan(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var nTAImplementors = []string{"NTA"}

func (ec *executionContext) _NTA(ctx context.Context, sel ast.SelectionSet, obj *model.NTA) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, nTAImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("NTA")
		case "name":
			out.Values[i] = ec._NTA_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "email":
			out.Values[i] = ec._NTA_email(ctx, field, obj)
		case "mtknr":
			out.Values[i] = ec._NTA_mtknr(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "compensation":
			out.Values[i] = ec._NTA_compensation(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "deltaDurationPercent":
			out.Values[i] = ec._NTA_deltaDurationPercent(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "needsRoomAlone":
			out.Values[i] = ec._NTA_needsRoomAlone(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "needsHardware":
			out.Values[i] = ec._NTA_needsHardware(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "program":
			out.Values[i] = ec._NTA_program(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "from":
			out.Values[i] = ec._NTA_from(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "until":
			out.Values[i] = ec._NTA_until(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "lastSemester":
			out.Values[i] = ec._NTA_lastSemester(ctx, field, obj)
		case "exams":
			out.Values[i] = ec._NTA_exams(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "deactivated":
			out.Values[i] = ec._NTA_deactivated(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var nTAExamImplementors = []string{"NTAExam"}

func (ec *executionContext) _NTAExam(ctx context.Context, sel ast.SelectionSet, obj *model.NTAExam) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, nTAExamImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("NTAExam")
		case "semester":
			out.Values[i] = ec._NTAExam_semester(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "ancode":
			out.Values[i] = ec._NTAExam_ancode(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "module":
			out.Values[i] = ec._NTAExam_module(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "mainExamer":
			out.Values[i] = ec._NTAExam_mainExamer(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var nTAWithRegsImplementors = []string{"NTAWithRegs"}

func (ec *executionContext) _NTAWithRegs(ctx context.Context, sel ast.SelectionSet, obj *model.NTAWithRegs) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, nTAWithRegsImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("NTAWithRegs")
		case "nta":
			out.Values[i] = ec._NTAWithRegs_nta(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "regs":
			out.Values[i] = ec._NTAWithRegs_regs(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var nTAWithRegsByExamImplementors = []string{"NTAWithRegsByExam"}

func (ec *executionContext) _NTAWithRegsByExam(ctx context.Context, sel ast.SelectionSet, obj *model.NTAWithRegsByExam) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, nTAWithRegsByExamImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("NTAWithRegsByExam")
		case "exam":
			out.Values[i] = ec._NTAWithRegsByExam_exam(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "ntas":
			out.Values[i] = ec._NTAWithRegsByExam_ntas(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var nTAWithRegsByExamAndTeacherImplementors = []string{"NTAWithRegsByExamAndTeacher"}

func (ec *executionContext) _NTAWithRegsByExamAndTeacher(ctx context.Context, sel ast.SelectionSet, obj *model.NTAWithRegsByExamAndTeacher) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, nTAWithRegsByExamAndTeacherImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("NTAWithRegsByExamAndTeacher")
		case "teacher":
			out.Values[i] = ec._NTAWithRegsByExamAndTeacher_teacher(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "exams":
			out.Values[i] = ec._NTAWithRegsByExamAndTeacher_exams(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var planEntryImplementors = []string{"PlanEntry"}

func (ec *executionContext) _PlanEntry(ctx context.Context, sel ast.SelectionSet, obj *model.PlanEntry) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, planEntryImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("PlanEntry")
		case "dayNumber":
			out.Values[i] = ec._PlanEntry_dayNumber(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "slotNumber":
			out.Values[i] = ec._PlanEntry_slotNumber(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "starttime":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._PlanEntry_starttime(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "ancode":
			out.Values[i] = ec._PlanEntry_ancode(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "locked":
			out.Values[i] = ec._PlanEntry_locked(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var plannedExamImplementors = []string{"PlannedExam"}

func (ec *executionContext) _PlannedExam(ctx context.Context, sel ast.SelectionSet, obj *model.PlannedExam) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, plannedExamImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("PlannedExam")
		case "ancode":
			out.Values[i] = ec._PlannedExam_ancode(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "zpaExam":
			out.Values[i] = ec._PlannedExam_zpaExam(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "mainExamer":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._PlannedExam_mainExamer(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "primussExams":
			out.Values[i] = ec._PlannedExam_primussExams(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "constraints":
			out.Values[i] = ec._PlannedExam_constraints(ctx, field, obj)
		case "conflicts":
			out.Values[i] = ec._PlannedExam_conflicts(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "studentRegsCount":
			out.Values[i] = ec._PlannedExam_studentRegsCount(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "ntas":
			out.Values[i] = ec._PlannedExam_ntas(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "maxDuration":
			out.Values[i] = ec._PlannedExam_maxDuration(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "planEntry":
			out.Values[i] = ec._PlannedExam_planEntry(ctx, field, obj)
		case "plannedRooms":
			out.Values[i] = ec._PlannedExam_plannedRooms(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var plannedRoomImplementors = []string{"PlannedRoom"}

func (ec *executionContext) _PlannedRoom(ctx context.Context, sel ast.SelectionSet, obj *model.PlannedRoom) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, plannedRoomImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("PlannedRoom")
		case "day":
			out.Values[i] = ec._PlannedRoom_day(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "slot":
			out.Values[i] = ec._PlannedRoom_slot(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "room":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._PlannedRoom_room(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "ancode":
			out.Values[i] = ec._PlannedRoom_ancode(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "duration":
			out.Values[i] = ec._PlannedRoom_duration(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "handicap":
			out.Values[i] = ec._PlannedRoom_handicap(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "handicapRoomAlone":
			out.Values[i] = ec._PlannedRoom_handicapRoomAlone(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "reserve":
			out.Values[i] = ec._PlannedRoom_reserve(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "studentsInRoom":
			out.Values[i] = ec._PlannedRoom_studentsInRoom(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "ntaMtknr":
			out.Values[i] = ec._PlannedRoom_ntaMtknr(ctx, field, obj)
		case "prePlanned":
			out.Values[i] = ec._PlannedRoom_prePlanned(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var preExamImplementors = []string{"PreExam"}

func (ec *executionContext) _PreExam(ctx context.Context, sel ast.SelectionSet, obj *model.PreExam) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, preExamImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("PreExam")
		case "zpaExam":
			out.Values[i] = ec._PreExam_zpaExam(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "constraints":
			out.Values[i] = ec._PreExam_constraints(ctx, field, obj)
		case "planEntry":
			out.Values[i] = ec._PreExam_planEntry(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var prePlannedRoomImplementors = []string{"PrePlannedRoom"}

func (ec *executionContext) _PrePlannedRoom(ctx context.Context, sel ast.SelectionSet, obj *model.PrePlannedRoom) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, prePlannedRoomImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("PrePlannedRoom")
		case "ancode":
			out.Values[i] = ec._PrePlannedRoom_ancode(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "roomName":
			out.Values[i] = ec._PrePlannedRoom_roomName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "mtknr":
			out.Values[i] = ec._PrePlannedRoom_mtknr(ctx, field, obj)
		case "reserve":
			out.Values[i] = ec._PrePlannedRoom_reserve(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var primussExamImplementors = []string{"PrimussExam"}

func (ec *executionContext) _PrimussExam(ctx context.Context, sel ast.SelectionSet, obj *model.PrimussExam) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, primussExamImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("PrimussExam")
		case "ancode":
			out.Values[i] = ec._PrimussExam_ancode(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "module":
			out.Values[i] = ec._PrimussExam_module(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "mainExamer":
			out.Values[i] = ec._PrimussExam_mainExamer(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "program":
			out.Values[i] = ec._PrimussExam_program(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "examType":
			out.Values[i] = ec._PrimussExam_examType(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "presence":
			out.Values[i] = ec._PrimussExam_presence(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var primussExamAncodeImplementors = []string{"PrimussExamAncode"}

func (ec *executionContext) _PrimussExamAncode(ctx context.Context, sel ast.SelectionSet, obj *model.PrimussExamAncode) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, primussExamAncodeImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("PrimussExamAncode")
		case "ancode":
			out.Values[i] = ec._PrimussExamAncode_ancode(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "program":
			out.Values[i] = ec._PrimussExamAncode_program(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "numberOfStuds":
			out.Values[i] = ec._PrimussExamAncode_numberOfStuds(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var primussExamByProgramImplementors = []string{"PrimussExamByProgram"}

func (ec *executionContext) _PrimussExamByProgram(ctx context.Context, sel ast.SelectionSet, obj *model.PrimussExamByProgram) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, primussExamByProgramImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("PrimussExamByProgram")
		case "program":
			out.Values[i] = ec._PrimussExamByProgram_program(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "exams":
			out.Values[i] = ec._PrimussExamByProgram_exams(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var primussExamWithCountImplementors = []string{"PrimussExamWithCount"}

func (ec *executionContext) _PrimussExamWithCount(ctx context.Context, sel ast.SelectionSet, obj *model.PrimussExamWithCount) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, primussExamWithCountImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("PrimussExamWithCount")
		case "ancode":
			out.Values[i] = ec._PrimussExamWithCount_ancode(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "module":
			out.Values[i] = ec._PrimussExamWithCount_module(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "mainExamer":
			out.Values[i] = ec._PrimussExamWithCount_mainExamer(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "program":
			out.Values[i] = ec._PrimussExamWithCount_program(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "examType":
			out.Values[i] = ec._PrimussExamWithCount_examType(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "presence":
			out.Values[i] = ec._PrimussExamWithCount_presence(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "studentRegsCount":
			out.Values[i] = ec._PrimussExamWithCount_studentRegsCount(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var queryImplementors = []string{"Query"}

func (ec *executionContext) _Query(ctx context.Context, sel ast.SelectionSet) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, queryImplementors)
	ctx = graphql.WithFieldContext(ctx, &graphql.FieldContext{
		Object: "Query",
	})

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		innerCtx := graphql.WithRootFieldContext(ctx, &graphql.RootFieldContext{
			Object: field.Name,
			Field:  field,
		})

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Query")
		case "allSemesterNames":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_allSemesterNames(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "semester":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_semester(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "semesterConfig":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_semesterConfig(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "constraintForAncode":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_constraintForAncode(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "zpaExamsToPlanWithConstraints":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_zpaExamsToPlanWithConstraints(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "connectedExam":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_connectedExam(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "connectedExams":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_connectedExams(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "generatedExams":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_generatedExams(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "generatedExam":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_generatedExam(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "plannedExams":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_plannedExams(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "plannedExam":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_plannedExam(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "mucdaiExams":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_mucdaiExams(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "conflictingAncodes":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_conflictingAncodes(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "invigilatorTodos":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_invigilatorTodos(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "invigilatorsWithReq":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_invigilatorsWithReq(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "roomsWithInvigilationsForSlot":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_roomsWithInvigilationsForSlot(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "invigilatorsForDay":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_invigilatorsForDay(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "ntas":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_ntas(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "ntasWithRegs":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_ntasWithRegs(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "nta":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_nta(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "allProgramsInPlan":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_allProgramsInPlan(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "ancodesInPlan":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_ancodesInPlan(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "examerInPlan":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_examerInPlan(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "preExamsInSlot":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_preExamsInSlot(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "examsInSlot":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_examsInSlot(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "examsWithoutSlot":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_examsWithoutSlot(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "allowedSlots":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_allowedSlots(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "awkwardSlots":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_awkwardSlots(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "primussExams":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_primussExams(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "primussExam":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_primussExam(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "primussExamsForAnCode":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_primussExamsForAnCode(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "studentRegsForProgram":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_studentRegsForProgram(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "rooms":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_rooms(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "prePlannedRooms":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_prePlannedRooms(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "roomsForSlots":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_roomsForSlots(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "plannedRooms":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_plannedRooms(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "plannedRoomNames":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_plannedRoomNames(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "plannedRoomNamesInSlot":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_plannedRoomNamesInSlot(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "plannedRoomsInSlot":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_plannedRoomsInSlot(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "plannedRoomForStudent":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_plannedRoomForStudent(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "studentByMtknr":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_studentByMtknr(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "studentsByName":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_studentsByName(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "students":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_students(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "teacher":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_teacher(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "teachers":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_teachers(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "invigilators":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_invigilators(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "fk07programs":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_fk07programs(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "zpaExams":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_zpaExams(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "zpaExamsByType":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_zpaExamsByType(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "zpaExamsToPlan":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_zpaExamsToPlan(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "zpaExamsNotToPlan":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_zpaExamsNotToPlan(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "zpaExamsPlaningStatusUnknown":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_zpaExamsPlaningStatusUnknown(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "zpaExam":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_zpaExam(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "zpaAnCodes":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_zpaAnCodes(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "studentRegsImportErrors":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_studentRegsImportErrors(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "__type":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Query___type(ctx, field)
			})
		case "__schema":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Query___schema(ctx, field)
			})
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var regWithErrorImplementors = []string{"RegWithError"}

func (ec *executionContext) _RegWithError(ctx context.Context, sel ast.SelectionSet, obj *model.RegWithError) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, regWithErrorImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("RegWithError")
		case "registration":
			out.Values[i] = ec._RegWithError_registration(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "error":
			out.Values[i] = ec._RegWithError_error(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var regWithProgramImplementors = []string{"RegWithProgram"}

func (ec *executionContext) _RegWithProgram(ctx context.Context, sel ast.SelectionSet, obj *model.RegWithProgram) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, regWithProgramImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("RegWithProgram")
		case "program":
			out.Values[i] = ec._RegWithProgram_program(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "reg":
			out.Values[i] = ec._RegWithProgram_reg(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var roomImplementors = []string{"Room"}

func (ec *executionContext) _Room(ctx context.Context, sel ast.SelectionSet, obj *model.Room) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, roomImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Room")
		case "name":
			out.Values[i] = ec._Room_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "seats":
			out.Values[i] = ec._Room_seats(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "handicap":
			out.Values[i] = ec._Room_handicap(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "lab":
			out.Values[i] = ec._Room_lab(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "placesWithSocket":
			out.Values[i] = ec._Room_placesWithSocket(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "needsRequest":
			out.Values[i] = ec._Room_needsRequest(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "exahm":
			out.Values[i] = ec._Room_exahm(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "seb":
			out.Values[i] = ec._Room_seb(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "sebSeats":
			out.Values[i] = ec._Room_sebSeats(ctx, field, obj)
		case "hmebSeats":
			out.Values[i] = ec._Room_hmebSeats(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var roomAndExamImplementors = []string{"RoomAndExam"}

func (ec *executionContext) _RoomAndExam(ctx context.Context, sel ast.SelectionSet, obj *model.RoomAndExam) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, roomAndExamImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("RoomAndExam")
		case "room":
			out.Values[i] = ec._RoomAndExam_room(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "exam":
			out.Values[i] = ec._RoomAndExam_exam(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var roomConstraintsImplementors = []string{"RoomConstraints"}

func (ec *executionContext) _RoomConstraints(ctx context.Context, sel ast.SelectionSet, obj *model.RoomConstraints) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, roomConstraintsImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("RoomConstraints")
		case "allowedRooms":
			out.Values[i] = ec._RoomConstraints_allowedRooms(ctx, field, obj)
		case "placesWithSocket":
			out.Values[i] = ec._RoomConstraints_placesWithSocket(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "lab":
			out.Values[i] = ec._RoomConstraints_lab(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "exahm":
			out.Values[i] = ec._RoomConstraints_exahm(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "seb":
			out.Values[i] = ec._RoomConstraints_seb(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "kdpJiraURL":
			out.Values[i] = ec._RoomConstraints_kdpJiraURL(ctx, field, obj)
		case "maxStudents":
			out.Values[i] = ec._RoomConstraints_maxStudents(ctx, field, obj)
		case "comments":
			out.Values[i] = ec._RoomConstraints_comments(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var roomWithInvigilatorImplementors = []string{"RoomWithInvigilator"}

func (ec *executionContext) _RoomWithInvigilator(ctx context.Context, sel ast.SelectionSet, obj *model.RoomWithInvigilator) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, roomWithInvigilatorImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("RoomWithInvigilator")
		case "name":
			out.Values[i] = ec._RoomWithInvigilator_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "maxDuration":
			out.Values[i] = ec._RoomWithInvigilator_maxDuration(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "studentCount":
			out.Values[i] = ec._RoomWithInvigilator_studentCount(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "roomAndExams":
			out.Values[i] = ec._RoomWithInvigilator_roomAndExams(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "invigilator":
			out.Values[i] = ec._RoomWithInvigilator_invigilator(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var roomsForSlotImplementors = []string{"RoomsForSlot"}

func (ec *executionContext) _RoomsForSlot(ctx context.Context, sel ast.SelectionSet, obj *model.RoomsForSlot) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, roomsForSlotImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("RoomsForSlot")
		case "day":
			out.Values[i] = ec._RoomsForSlot_day(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "slot":
			out.Values[i] = ec._RoomsForSlot_slot(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "rooms":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._RoomsForSlot_rooms(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var semesterImplementors = []string{"Semester"}

func (ec *executionContext) _Semester(ctx context.Context, sel ast.SelectionSet, obj *model.Semester) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, semesterImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Semester")
		case "id":
			out.Values[i] = ec._Semester_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var semesterConfigImplementors = []string{"SemesterConfig"}

func (ec *executionContext) _SemesterConfig(ctx context.Context, sel ast.SelectionSet, obj *model.SemesterConfig) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, semesterConfigImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("SemesterConfig")
		case "days":
			out.Values[i] = ec._SemesterConfig_days(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "starttimes":
			out.Values[i] = ec._SemesterConfig_starttimes(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "slots":
			out.Values[i] = ec._SemesterConfig_slots(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "goSlotsRaw":
			out.Values[i] = ec._SemesterConfig_goSlotsRaw(ctx, field, obj)
		case "goSlots":
			out.Values[i] = ec._SemesterConfig_goSlots(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "goDay0":
			out.Values[i] = ec._SemesterConfig_goDay0(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "forbiddenSlots":
			out.Values[i] = ec._SemesterConfig_forbiddenSlots(ctx, field, obj)
		case "from":
			out.Values[i] = ec._SemesterConfig_from(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "fromFK07":
			out.Values[i] = ec._SemesterConfig_fromFK07(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "until":
			out.Values[i] = ec._SemesterConfig_until(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "emails":
			out.Values[i] = ec._SemesterConfig_emails(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var slotImplementors = []string{"Slot"}

func (ec *executionContext) _Slot(ctx context.Context, sel ast.SelectionSet, obj *model.Slot) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, slotImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Slot")
		case "dayNumber":
			out.Values[i] = ec._Slot_dayNumber(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "slotNumber":
			out.Values[i] = ec._Slot_slotNumber(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "starttime":
			out.Values[i] = ec._Slot_starttime(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var starttimeImplementors = []string{"Starttime"}

func (ec *executionContext) _Starttime(ctx context.Context, sel ast.SelectionSet, obj *model.Starttime) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, starttimeImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Starttime")
		case "number":
			out.Values[i] = ec._Starttime_number(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "start":
			out.Values[i] = ec._Starttime_start(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var studentImplementors = []string{"Student"}

func (ec *executionContext) _Student(ctx context.Context, sel ast.SelectionSet, obj *model.Student) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, studentImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Student")
		case "mtknr":
			out.Values[i] = ec._Student_mtknr(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "program":
			out.Values[i] = ec._Student_program(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "group":
			out.Values[i] = ec._Student_group(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "name":
			out.Values[i] = ec._Student_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "regs":
			out.Values[i] = ec._Student_regs(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "regsWithProgram":
			out.Values[i] = ec._Student_regsWithProgram(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "zpaStudent":
			out.Values[i] = ec._Student_zpaStudent(ctx, field, obj)
		case "nta":
			out.Values[i] = ec._Student_nta(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var studentRegImplementors = []string{"StudentReg"}

func (ec *executionContext) _StudentReg(ctx context.Context, sel ast.SelectionSet, obj *model.StudentReg) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, studentRegImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("StudentReg")
		case "mtknr":
			out.Values[i] = ec._StudentReg_mtknr(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "ancode":
			out.Values[i] = ec._StudentReg_ancode(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "program":
			out.Values[i] = ec._StudentReg_program(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "group":
			out.Values[i] = ec._StudentReg_group(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "name":
			out.Values[i] = ec._StudentReg_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "presence":
			out.Values[i] = ec._StudentReg_presence(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var studentRegsPerAncodeImplementors = []string{"StudentRegsPerAncode"}

func (ec *executionContext) _StudentRegsPerAncode(ctx context.Context, sel ast.SelectionSet, obj *model.StudentRegsPerAncode) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, studentRegsPerAncodeImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("StudentRegsPerAncode")
		case "ancode":
			out.Values[i] = ec._StudentRegsPerAncode_ancode(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "perProgram":
			out.Values[i] = ec._StudentRegsPerAncode_perProgram(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var studentRegsPerAncodeAndProgramImplementors = []string{"StudentRegsPerAncodeAndProgram"}

func (ec *executionContext) _StudentRegsPerAncodeAndProgram(ctx context.Context, sel ast.SelectionSet, obj *model.StudentRegsPerAncodeAndProgram) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, studentRegsPerAncodeAndProgramImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("StudentRegsPerAncodeAndProgram")
		case "program":
			out.Values[i] = ec._StudentRegsPerAncodeAndProgram_program(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "ancode":
			out.Values[i] = ec._StudentRegsPerAncodeAndProgram_ancode(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "studentRegs":
			out.Values[i] = ec._StudentRegsPerAncodeAndProgram_studentRegs(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var studentRegsPerStudentImplementors = []string{"StudentRegsPerStudent"}

func (ec *executionContext) _StudentRegsPerStudent(ctx context.Context, sel ast.SelectionSet, obj *model.StudentRegsPerStudent) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, studentRegsPerStudentImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("StudentRegsPerStudent")
		case "student":
			out.Values[i] = ec._StudentRegsPerStudent_student(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "ancodes":
			out.Values[i] = ec._StudentRegsPerStudent_ancodes(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var teacherImplementors = []string{"Teacher"}

func (ec *executionContext) _Teacher(ctx context.Context, sel ast.SelectionSet, obj *model.Teacher) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, teacherImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Teacher")
		case "shortname":
			out.Values[i] = ec._Teacher_shortname(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "fullname":
			out.Values[i] = ec._Teacher_fullname(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "isProf":
			out.Values[i] = ec._Teacher_isProf(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "isLBA":
			out.Values[i] = ec._Teacher_isLBA(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "isProfHC":
			out.Values[i] = ec._Teacher_isProfHC(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "isStaff":
			out.Values[i] = ec._Teacher_isStaff(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "lastSemester":
			out.Values[i] = ec._Teacher_lastSemester(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "fk":
			out.Values[i] = ec._Teacher_fk(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "id":
			out.Values[i] = ec._Teacher_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "email":
			out.Values[i] = ec._Teacher_email(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "isActive":
			out.Values[i] = ec._Teacher_isActive(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var zPAConflictImplementors = []string{"ZPAConflict"}

func (ec *executionContext) _ZPAConflict(ctx context.Context, sel ast.SelectionSet, obj *model.ZPAConflict) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, zPAConflictImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ZPAConflict")
		case "ancode":
			out.Values[i] = ec._ZPAConflict_ancode(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "numberOfStuds":
			out.Values[i] = ec._ZPAConflict_numberOfStuds(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "primussAncodes":
			out.Values[i] = ec._ZPAConflict_primussAncodes(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var zPAExamImplementors = []string{"ZPAExam"}

func (ec *executionContext) _ZPAExam(ctx context.Context, sel ast.SelectionSet, obj *model.ZPAExam) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, zPAExamImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ZPAExam")
		case "zpaID":
			out.Values[i] = ec._ZPAExam_zpaID(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "semester":
			out.Values[i] = ec._ZPAExam_semester(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "ancode":
			out.Values[i] = ec._ZPAExam_ancode(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "module":
			out.Values[i] = ec._ZPAExam_module(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "mainExamer":
			out.Values[i] = ec._ZPAExam_mainExamer(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "mainExamerID":
			out.Values[i] = ec._ZPAExam_mainExamerID(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "examType":
			out.Values[i] = ec._ZPAExam_examType(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "examTypeFull":
			out.Values[i] = ec._ZPAExam_examTypeFull(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "duration":
			out.Values[i] = ec._ZPAExam_duration(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "isRepeaterExam":
			out.Values[i] = ec._ZPAExam_isRepeaterExam(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "groups":
			out.Values[i] = ec._ZPAExam_groups(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "primussAncodes":
			out.Values[i] = ec._ZPAExam_primussAncodes(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var zPAExamWithConstraintsImplementors = []string{"ZPAExamWithConstraints"}

func (ec *executionContext) _ZPAExamWithConstraints(ctx context.Context, sel ast.SelectionSet, obj *model.ZPAExamWithConstraints) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, zPAExamWithConstraintsImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ZPAExamWithConstraints")
		case "zpaExam":
			out.Values[i] = ec._ZPAExamWithConstraints_zpaExam(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "constraints":
			out.Values[i] = ec._ZPAExamWithConstraints_constraints(ctx, field, obj)
		case "planEntry":
			out.Values[i] = ec._ZPAExamWithConstraints_planEntry(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var zPAExamsForTypeImplementors = []string{"ZPAExamsForType"}

func (ec *executionContext) _ZPAExamsForType(ctx context.Context, sel ast.SelectionSet, obj *model.ZPAExamsForType) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, zPAExamsForTypeImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ZPAExamsForType")
		case "type":
			out.Values[i] = ec._ZPAExamsForType_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "exams":
			out.Values[i] = ec._ZPAExamsForType_exams(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var zPAInvigilatorImplementors = []string{"ZPAInvigilator"}

func (ec *executionContext) _ZPAInvigilator(ctx context.Context, sel ast.SelectionSet, obj *model.ZPAInvigilator) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, zPAInvigilatorImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ZPAInvigilator")
		case "teacher":
			out.Values[i] = ec._ZPAInvigilator_teacher(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "hasSubmittedRequirements":
			out.Values[i] = ec._ZPAInvigilator_hasSubmittedRequirements(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var zPAPrimussAncodesImplementors = []string{"ZPAPrimussAncodes"}

func (ec *executionContext) _ZPAPrimussAncodes(ctx context.Context, sel ast.SelectionSet, obj *model.ZPAPrimussAncodes) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, zPAPrimussAncodesImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ZPAPrimussAncodes")
		case "program":
			out.Values[i] = ec._ZPAPrimussAncodes_program(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "ancode":
			out.Values[i] = ec._ZPAPrimussAncodes_ancode(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var zPAStudentImplementors = []string{"ZPAStudent"}

func (ec *executionContext) _ZPAStudent(ctx context.Context, sel ast.SelectionSet, obj *model.ZPAStudent) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, zPAStudentImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ZPAStudent")
		case "Greeting":
			out.Values[i] = ec._ZPAStudent_Greeting(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "FirstName":
			out.Values[i] = ec._ZPAStudent_FirstName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "LastName":
			out.Values[i] = ec._ZPAStudent_LastName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "Email":
			out.Values[i] = ec._ZPAStudent_Email(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "Gender":
			out.Values[i] = ec._ZPAStudent_Gender(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "Group":
			out.Values[i] = ec._ZPAStudent_Group(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var zPAStudentRegImplementors = []string{"ZPAStudentReg"}

func (ec *executionContext) _ZPAStudentReg(ctx context.Context, sel ast.SelectionSet, obj *model.ZPAStudentReg) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, zPAStudentRegImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ZPAStudentReg")
		case "ancode":
			out.Values[i] = ec._ZPAStudentReg_ancode(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "mtknr":
			out.Values[i] = ec._ZPAStudentReg_mtknr(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "program":
			out.Values[i] = ec._ZPAStudentReg_program(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var zPAStudentRegErrorImplementors = []string{"ZPAStudentRegError"}

func (ec *executionContext) _ZPAStudentRegError(ctx context.Context, sel ast.SelectionSet, obj *model.ZPAStudentRegError) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, zPAStudentRegErrorImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ZPAStudentRegError")
		case "semester":
			out.Values[i] = ec._ZPAStudentRegError_semester(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "ancode":
			out.Values[i] = ec._ZPAStudentRegError_ancode(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "exam":
			out.Values[i] = ec._ZPAStudentRegError_exam(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "mtknr":
			out.Values[i] = ec._ZPAStudentRegError_mtknr(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "program":
			out.Values[i] = ec._ZPAStudentRegError_program(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var __DirectiveImplementors = []string{"__Directive"}

func (ec *executionContext) ___Directive(ctx context.Context, sel ast.SelectionSet, obj *introspection.Directive) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __DirectiveImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Directive")
		case "name":
			out.Values[i] = ec.___Directive_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "description":
			out.Values[i] = ec.___Directive_description(ctx, field, obj)
		case "isRepeatable":
			out.Values[i] = ec.___Directive_isRepeatable(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "locations":
			out.Values[i] = ec.___Directive_locations(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "args":
			out.Values[i] = ec.___Directive_args(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var __EnumValueImplementors = []string{"__EnumValue"}

func (ec *executionContext) ___EnumValue(ctx context.Context, sel ast.SelectionSet, obj *introspection.EnumValue) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __EnumValueImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__EnumValue")
		case "name":
			out.Values[i] = ec.___EnumValue_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "description":
			out.Values[i] = ec.___EnumValue_description(ctx, field, obj)
		case "isDeprecated":
			out.Values[i] = ec.___EnumValue_isDeprecated(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "deprecationReason":
			out.Values[i] = ec.___EnumValue_deprecationReason(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var __FieldImplementors = []string{"__Field"}

func (ec *executionContext) ___Field(ctx context.Context, sel ast.SelectionSet, obj *introspection.Field) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __FieldImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Field")
		case "name":
			out.Values[i] = ec.___Field_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "description":
			out.Values[i] = ec.___Field_description(ctx, field, obj)
		case "args":
			out.Values[i] = ec.___Field_args(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "type":
			out.Values[i] = ec.___Field_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "isDeprecated":
			out.Values[i] = ec.___Field_isDeprecated(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "deprecationReason":
			out.Values[i] = ec.___Field_deprecationReason(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var __InputValueImplementors = []string{"__InputValue"}

func (ec *executionContext) ___InputValue(ctx context.Context, sel ast.SelectionSet, obj *introspection.InputValue) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __InputValueImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__InputValue")
		case "name":
			out.Values[i] = ec.___InputValue_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "description":
			out.Values[i] = ec.___InputValue_description(ctx, field, obj)
		case "type":
			out.Values[i] = ec.___InputValue_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "defaultValue":
			out.Values[i] = ec.___InputValue_defaultValue(ctx, field, obj)
		case "isDeprecated":
			out.Values[i] = ec.___InputValue_isDeprecated(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "deprecationReason":
			out.Values[i] = ec.___InputValue_deprecationReason(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var __SchemaImplementors = []string{"__Schema"}

func (ec *executionContext) ___Schema(ctx context.Context, sel ast.SelectionSet, obj *introspection.Schema) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __SchemaImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Schema")
		case "description":
			out.Values[i] = ec.___Schema_description(ctx, field, obj)
		case "types":
			out.Values[i] = ec.___Schema_types(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "queryType":
			out.Values[i] = ec.___Schema_queryType(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "mutationType":
			out.Values[i] = ec.___Schema_mutationType(ctx, field, obj)
		case "subscriptionType":
			out.Values[i] = ec.___Schema_subscriptionType(ctx, field, obj)
		case "directives":
			out.Values[i] = ec.___Schema_directives(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var __TypeImplementors = []string{"__Type"}

func (ec *executionContext) ___Type(ctx context.Context, sel ast.SelectionSet, obj *introspection.Type) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __TypeImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Type")
		case "kind":
			out.Values[i] = ec.___Type_kind(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "name":
			out.Values[i] = ec.___Type_name(ctx, field, obj)
		case "description":
			out.Values[i] = ec.___Type_description(ctx, field, obj)
		case "specifiedByURL":
			out.Values[i] = ec.___Type_specifiedByURL(ctx, field, obj)
		case "fields":
			out.Values[i] = ec.___Type_fields(ctx, field, obj)
		case "interfaces":
			out.Values[i] = ec.___Type_interfaces(ctx, field, obj)
		case "possibleTypes":
			out.Values[i] = ec.___Type_possibleTypes(ctx, field, obj)
		case "enumValues":
			out.Values[i] = ec.___Type_enumValues(ctx, field, obj)
		case "inputFields":
			out.Values[i] = ec.___Type_inputFields(ctx, field, obj)
		case "ofType":
			out.Values[i] = ec.___Type_ofType(ctx, field, obj)
		case "isOneOf":
			out.Values[i] = ec.___Type_isOneOf(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

// endregion **************************** object.gotpl ****************************

// region    ***************************** type.gotpl *****************************

func (ec *executionContext) unmarshalNBoolean2bool(ctx context.Context, v any) (bool, error) {
	res, err := graphql.UnmarshalBoolean(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNBoolean2bool(ctx context.Context, sel ast.SelectionSet, v bool) graphql.Marshaler {
	_ = sel
	res := graphql.MarshalBoolean(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) marshalNConflict2githubcomobcodeplexamsgographmodelConflict(ctx context.Context, sel ast.SelectionSet, v []*model.Conflict) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNConflict2githubcomobcodeplexamsgographmodelConflict(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNConflict2githubcomobcodeplexamsgographmodelConflict(ctx context.Context, sel ast.SelectionSet, v *model.Conflict) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Conflict(ctx, sel, v)
}

func (ec *executionContext) marshalNConnectedExam2githubcomobcodeplexamsgographmodelConnectedExam(ctx context.Context, sel ast.SelectionSet, v []*model.ConnectedExam) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNConnectedExam2githubcomobcodeplexamsgographmodelConnectedExam(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNConnectedExam2githubcomobcodeplexamsgographmodelConnectedExam(ctx context.Context, sel ast.SelectionSet, v *model.ConnectedExam) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._ConnectedExam(ctx, sel, v)
}

func (ec *executionContext) marshalNConstraints2githubcomobcodeplexamsgographmodelConstraints(ctx context.Context, sel ast.SelectionSet, v model.Constraints) graphql.Marshaler {
	return ec._Constraints(ctx, sel, &v)
}

func (ec *executionContext) marshalNConstraints2githubcomobcodeplexamsgographmodelConstraints(ctx context.Context, sel ast.SelectionSet, v *model.Constraints) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Constraints(ctx, sel, v)
}

func (ec *executionContext) unmarshalNConstraintsInput2githubcomobcodeplexamsgographmodelConstraintsInput(ctx context.Context, v any) (model.ConstraintsInput, error) {
	res, err := ec.unmarshalInputConstraintsInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNEmails2githubcomobcodeplexamsgographmodelEmails(ctx context.Context, sel ast.SelectionSet, v *model.Emails) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Emails(ctx, sel, v)
}

func (ec *executionContext) marshalNEnhancedPrimussExam2githubcomobcodeplexamsgographmodelEnhancedPrimussExam(ctx context.Context, sel ast.SelectionSet, v []*model.EnhancedPrimussExam) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNEnhancedPrimussExam2githubcomobcodeplexamsgographmodelEnhancedPrimussExam(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNEnhancedPrimussExam2githubcomobcodeplexamsgographmodelEnhancedPrimussExam(ctx context.Context, sel ast.SelectionSet, v *model.EnhancedPrimussExam) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._EnhancedPrimussExam(ctx, sel, v)
}

func (ec *executionContext) marshalNExamDay2githubcomobcodeplexamsgographmodelExamDay(ctx context.Context, sel ast.SelectionSet, v []*model.ExamDay) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNExamDay2githubcomobcodeplexamsgographmodelExamDay(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNExamDay2githubcomobcodeplexamsgographmodelExamDay(ctx context.Context, sel ast.SelectionSet, v *model.ExamDay) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._ExamDay(ctx, sel, v)
}

func (ec *executionContext) marshalNExamerInPlan2githubcomobcodeplexamsgographmodelExamerInPlan(ctx context.Context, sel ast.SelectionSet, v *model.ExamerInPlan) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._ExamerInPlan(ctx, sel, v)
}

func (ec *executionContext) marshalNFK07Program2githubcomobcodeplexamsgographmodelFK07Program(ctx context.Context, sel ast.SelectionSet, v []*model.FK07Program) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNFK07Program2githubcomobcodeplexamsgographmodelFK07Program(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNFK07Program2githubcomobcodeplexamsgographmodelFK07Program(ctx context.Context, sel ast.SelectionSet, v *model.FK07Program) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._FK07Program(ctx, sel, v)
}

func (ec *executionContext) unmarshalNFloat2float64(ctx context.Context, v any) (float64, error) {
	res, err := graphql.UnmarshalFloatContext(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNFloat2float64(ctx context.Context, sel ast.SelectionSet, v float64) graphql.Marshaler {
	_ = sel
	res := graphql.MarshalFloatContext(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return graphql.WrapContextMarshaler(ctx, res)
}

func (ec *executionContext) marshalNGeneratedExam2githubcomobcodeplexamsgographmodelGeneratedExam(ctx context.Context, sel ast.SelectionSet, v []*model.GeneratedExam) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNGeneratedExam2githubcomobcodeplexamsgographmodelGeneratedExam(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNGeneratedExam2githubcomobcodeplexamsgographmodelGeneratedExam(ctx context.Context, sel ast.SelectionSet, v *model.GeneratedExam) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._GeneratedExam(ctx, sel, v)
}

func (ec *executionContext) unmarshalNInt2int(ctx context.Context, v any) (int, error) {
	res, err := graphql.UnmarshalInt(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNInt2int(ctx context.Context, sel ast.SelectionSet, v int) graphql.Marshaler {
	_ = sel
	res := graphql.MarshalInt(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNInt2int(ctx context.Context, v any) ([]int, error) {
	var vSlice []any
	vSlice = graphql.CoerceList(v)
	var err error
	res := make([]int, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNInt2int(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalNInt2int(ctx context.Context, sel ast.SelectionSet, v []int) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalNInt2int(ctx, sel, v[i])
	}

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNInvigilation2githubcomobcodeplexamsgographmodelInvigilation(ctx context.Context, sel ast.SelectionSet, v *model.Invigilation) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Invigilation(ctx, sel, v)
}

func (ec *executionContext) marshalNInvigilator2githubcomobcodeplexamsgographmodelInvigilator(ctx context.Context, sel ast.SelectionSet, v []*model.Invigilator) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNInvigilator2githubcomobcodeplexamsgographmodelInvigilator(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNInvigilator2githubcomobcodeplexamsgographmodelInvigilator(ctx context.Context, sel ast.SelectionSet, v *model.Invigilator) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Invigilator(ctx, sel, v)
}

func (ec *executionContext) marshalNMucDaiExam2githubcomobcodeplexamsgographmodelMucDaiExam(ctx context.Context, sel ast.SelectionSet, v []*model.MucDaiExam) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNMucDaiExam2githubcomobcodeplexamsgographmodelMucDaiExam(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNMucDaiExam2githubcomobcodeplexamsgographmodelMucDaiExam(ctx context.Context, sel ast.SelectionSet, v *model.MucDaiExam) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._MucDaiExam(ctx, sel, v)
}

func (ec *executionContext) marshalNNTA2githubcomobcodeplexamsgographmodelNTA(ctx context.Context, sel ast.SelectionSet, v model.NTA) graphql.Marshaler {
	return ec._NTA(ctx, sel, &v)
}

func (ec *executionContext) marshalNNTA2githubcomobcodeplexamsgographmodelNTA(ctx context.Context, sel ast.SelectionSet, v []*model.NTA) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNNTA2githubcomobcodeplexamsgographmodelNTA(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNNTA2githubcomobcodeplexamsgographmodelNTA(ctx context.Context, sel ast.SelectionSet, v *model.NTA) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._NTA(ctx, sel, v)
}

func (ec *executionContext) marshalNNTAExam2githubcomobcodeplexamsgographmodelNTAExam(ctx context.Context, sel ast.SelectionSet, v []*model.NTAExam) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNNTAExam2githubcomobcodeplexamsgographmodelNTAExam(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNNTAExam2githubcomobcodeplexamsgographmodelNTAExam(ctx context.Context, sel ast.SelectionSet, v *model.NTAExam) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._NTAExam(ctx, sel, v)
}

func (ec *executionContext) unmarshalNNTAInput2githubcomobcodeplexamsgographmodelNTAInput(ctx context.Context, v any) (model.NTAInput, error) {
	res, err := ec.unmarshalInputNTAInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNNTAWithRegs2githubcomobcodeplexamsgographmodelNTAWithRegs(ctx context.Context, sel ast.SelectionSet, v *model.NTAWithRegs) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._NTAWithRegs(ctx, sel, v)
}

func (ec *executionContext) marshalNNTAWithRegsByExam2githubcomobcodeplexamsgographmodelNTAWithRegsByExam(ctx context.Context, sel ast.SelectionSet, v *model.NTAWithRegsByExam) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._NTAWithRegsByExam(ctx, sel, v)
}

func (ec *executionContext) marshalNPlannedExam2githubcomobcodeplexamsgographmodelPlannedExam(ctx context.Context, sel ast.SelectionSet, v []*model.PlannedExam) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNPlannedExam2githubcomobcodeplexamsgographmodelPlannedExam(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNPlannedExam2githubcomobcodeplexamsgographmodelPlannedExam(ctx context.Context, sel ast.SelectionSet, v *model.PlannedExam) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._PlannedExam(ctx, sel, v)
}

func (ec *executionContext) marshalNPlannedRoom2githubcomobcodeplexamsgographmodelPlannedRoom(ctx context.Context, sel ast.SelectionSet, v []*model.PlannedRoom) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNPlannedRoom2githubcomobcodeplexamsgographmodelPlannedRoom(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNPlannedRoom2githubcomobcodeplexamsgographmodelPlannedRoom(ctx context.Context, sel ast.SelectionSet, v *model.PlannedRoom) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._PlannedRoom(ctx, sel, v)
}

func (ec *executionContext) marshalNPreExam2githubcomobcodeplexamsgographmodelPreExam(ctx context.Context, sel ast.SelectionSet, v *model.PreExam) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._PreExam(ctx, sel, v)
}

func (ec *executionContext) marshalNPrePlannedRoom2githubcomobcodeplexamsgographmodelPrePlannedRoom(ctx context.Context, sel ast.SelectionSet, v []*model.PrePlannedRoom) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNPrePlannedRoom2githubcomobcodeplexamsgographmodelPrePlannedRoom(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNPrePlannedRoom2githubcomobcodeplexamsgographmodelPrePlannedRoom(ctx context.Context, sel ast.SelectionSet, v *model.PrePlannedRoom) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._PrePlannedRoom(ctx, sel, v)
}

func (ec *executionContext) marshalNPrimussExam2githubcomobcodeplexamsgographmodelPrimussExam(ctx context.Context, sel ast.SelectionSet, v model.PrimussExam) graphql.Marshaler {
	return ec._PrimussExam(ctx, sel, &v)
}

func (ec *executionContext) marshalNPrimussExam2githubcomobcodeplexamsgographmodelPrimussExam(ctx context.Context, sel ast.SelectionSet, v []*model.PrimussExam) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNPrimussExam2githubcomobcodeplexamsgographmodelPrimussExam(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNPrimussExam2githubcomobcodeplexamsgographmodelPrimussExam(ctx context.Context, sel ast.SelectionSet, v *model.PrimussExam) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._PrimussExam(ctx, sel, v)
}

func (ec *executionContext) marshalNPrimussExamAncode2githubcomobcodeplexamsgographmodelPrimussExamAncode(ctx context.Context, sel ast.SelectionSet, v []*model.PrimussExamAncode) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNPrimussExamAncode2githubcomobcodeplexamsgographmodelPrimussExamAncode(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNPrimussExamAncode2githubcomobcodeplexamsgographmodelPrimussExamAncode(ctx context.Context, sel ast.SelectionSet, v *model.PrimussExamAncode) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._PrimussExamAncode(ctx, sel, v)
}

func (ec *executionContext) marshalNPrimussExamWithCount2githubcomobcodeplexamsgographmodelPrimussExamWithCount(ctx context.Context, sel ast.SelectionSet, v []*model.PrimussExamWithCount) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNPrimussExamWithCount2githubcomobcodeplexamsgographmodelPrimussExamWithCount(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNPrimussExamWithCount2githubcomobcodeplexamsgographmodelPrimussExamWithCount(ctx context.Context, sel ast.SelectionSet, v *model.PrimussExamWithCount) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._PrimussExamWithCount(ctx, sel, v)
}

func (ec *executionContext) marshalNRegWithError2githubcomobcodeplexamsgographmodelRegWithError(ctx context.Context, sel ast.SelectionSet, v []*model.RegWithError) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNRegWithError2githubcomobcodeplexamsgographmodelRegWithError(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNRegWithError2githubcomobcodeplexamsgographmodelRegWithError(ctx context.Context, sel ast.SelectionSet, v *model.RegWithError) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._RegWithError(ctx, sel, v)
}

func (ec *executionContext) marshalNRegWithProgram2githubcomobcodeplexamsgographmodelRegWithProgram(ctx context.Context, sel ast.SelectionSet, v []*model.RegWithProgram) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNRegWithProgram2githubcomobcodeplexamsgographmodelRegWithProgram(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNRegWithProgram2githubcomobcodeplexamsgographmodelRegWithProgram(ctx context.Context, sel ast.SelectionSet, v *model.RegWithProgram) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._RegWithProgram(ctx, sel, v)
}

func (ec *executionContext) marshalNRoom2githubcomobcodeplexamsgographmodelRoom(ctx context.Context, sel ast.SelectionSet, v model.Room) graphql.Marshaler {
	return ec._Room(ctx, sel, &v)
}

func (ec *executionContext) marshalNRoom2githubcomobcodeplexamsgographmodelRoom(ctx context.Context, sel ast.SelectionSet, v []*model.Room) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNRoom2githubcomobcodeplexamsgographmodelRoom(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNRoom2githubcomobcodeplexamsgographmodelRoom(ctx context.Context, sel ast.SelectionSet, v *model.Room) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Room(ctx, sel, v)
}

func (ec *executionContext) marshalNRoomAndExam2githubcomobcodeplexamsgographmodelRoomAndExam(ctx context.Context, sel ast.SelectionSet, v []*model.RoomAndExam) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNRoomAndExam2githubcomobcodeplexamsgographmodelRoomAndExam(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNRoomAndExam2githubcomobcodeplexamsgographmodelRoomAndExam(ctx context.Context, sel ast.SelectionSet, v *model.RoomAndExam) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._RoomAndExam(ctx, sel, v)
}

func (ec *executionContext) marshalNRoomWithInvigilator2githubcomobcodeplexamsgographmodelRoomWithInvigilator(ctx context.Context, sel ast.SelectionSet, v []*model.RoomWithInvigilator) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNRoomWithInvigilator2githubcomobcodeplexamsgographmodelRoomWithInvigilator(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNRoomWithInvigilator2githubcomobcodeplexamsgographmodelRoomWithInvigilator(ctx context.Context, sel ast.SelectionSet, v *model.RoomWithInvigilator) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._RoomWithInvigilator(ctx, sel, v)
}

func (ec *executionContext) marshalNRoomsForSlot2githubcomobcodeplexamsgographmodelRoomsForSlot(ctx context.Context, sel ast.SelectionSet, v []*model.RoomsForSlot) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNRoomsForSlot2githubcomobcodeplexamsgographmodelRoomsForSlot(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNRoomsForSlot2githubcomobcodeplexamsgographmodelRoomsForSlot(ctx context.Context, sel ast.SelectionSet, v *model.RoomsForSlot) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._RoomsForSlot(ctx, sel, v)
}

func (ec *executionContext) marshalNSemester2githubcomobcodeplexamsgographmodelSemester(ctx context.Context, sel ast.SelectionSet, v model.Semester) graphql.Marshaler {
	return ec._Semester(ctx, sel, &v)
}

func (ec *executionContext) marshalNSemester2githubcomobcodeplexamsgographmodelSemester(ctx context.Context, sel ast.SelectionSet, v []*model.Semester) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNSemester2githubcomobcodeplexamsgographmodelSemester(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNSemester2githubcomobcodeplexamsgographmodelSemester(ctx context.Context, sel ast.SelectionSet, v *model.Semester) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Semester(ctx, sel, v)
}

func (ec *executionContext) marshalNSemesterConfig2githubcomobcodeplexamsgographmodelSemesterConfig(ctx context.Context, sel ast.SelectionSet, v model.SemesterConfig) graphql.Marshaler {
	return ec._SemesterConfig(ctx, sel, &v)
}

func (ec *executionContext) marshalNSemesterConfig2githubcomobcodeplexamsgographmodelSemesterConfig(ctx context.Context, sel ast.SelectionSet, v *model.SemesterConfig) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._SemesterConfig(ctx, sel, v)
}

func (ec *executionContext) marshalNSlot2githubcomobcodeplexamsgographmodelSlot(ctx context.Context, sel ast.SelectionSet, v []*model.Slot) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNSlot2githubcomobcodeplexamsgographmodelSlot(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNSlot2githubcomobcodeplexamsgographmodelSlot(ctx context.Context, sel ast.SelectionSet, v *model.Slot) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Slot(ctx, sel, v)
}

func (ec *executionContext) marshalNStarttime2githubcomobcodeplexamsgographmodelStarttime(ctx context.Context, sel ast.SelectionSet, v []*model.Starttime) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNStarttime2githubcomobcodeplexamsgographmodelStarttime(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNStarttime2githubcomobcodeplexamsgographmodelStarttime(ctx context.Context, sel ast.SelectionSet, v *model.Starttime) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Starttime(ctx, sel, v)
}

func (ec *executionContext) unmarshalNString2string(ctx context.Context, v any) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNString2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	_ = sel
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNString2string(ctx context.Context, v any) ([]string, error) {
	var vSlice []any
	vSlice = graphql.CoerceList(v)
	var err error
	res := make([]string, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNString2string(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalNString2string(ctx context.Context, sel ast.SelectionSet, v []string) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalNString2string(ctx, sel, v[i])
	}

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNStudent2githubcomobcodeplexamsgographmodelStudent(ctx context.Context, sel ast.SelectionSet, v []*model.Student) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNStudent2githubcomobcodeplexamsgographmodelStudent(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNStudent2githubcomobcodeplexamsgographmodelStudent(ctx context.Context, sel ast.SelectionSet, v *model.Student) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Student(ctx, sel, v)
}

func (ec *executionContext) marshalNStudentReg2githubcomobcodeplexamsgographmodelStudentReg(ctx context.Context, sel ast.SelectionSet, v []*model.StudentReg) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNStudentReg2githubcomobcodeplexamsgographmodelStudentReg(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNStudentReg2githubcomobcodeplexamsgographmodelStudentReg(ctx context.Context, sel ast.SelectionSet, v *model.StudentReg) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._StudentReg(ctx, sel, v)
}

func (ec *executionContext) marshalNStudentRegsPerAncodeAndProgram2githubcomobcodeplexamsgographmodelStudentRegsPerAncodeAndProgram(ctx context.Context, sel ast.SelectionSet, v []*model.StudentRegsPerAncodeAndProgram) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNStudentRegsPerAncodeAndProgram2githubcomobcodeplexamsgographmodelStudentRegsPerAncodeAndProgram(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNStudentRegsPerAncodeAndProgram2githubcomobcodeplexamsgographmodelStudentRegsPerAncodeAndProgram(ctx context.Context, sel ast.SelectionSet, v *model.StudentRegsPerAncodeAndProgram) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._StudentRegsPerAncodeAndProgram(ctx, sel, v)
}

func (ec *executionContext) marshalNTeacher2githubcomobcodeplexamsgographmodelTeacher(ctx context.Context, sel ast.SelectionSet, v model.Teacher) graphql.Marshaler {
	return ec._Teacher(ctx, sel, &v)
}

func (ec *executionContext) marshalNTeacher2githubcomobcodeplexamsgographmodelTeacher(ctx context.Context, sel ast.SelectionSet, v []*model.Teacher) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNTeacher2githubcomobcodeplexamsgographmodelTeacher(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNTeacher2githubcomobcodeplexamsgographmodelTeacher(ctx context.Context, sel ast.SelectionSet, v *model.Teacher) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Teacher(ctx, sel, v)
}

func (ec *executionContext) unmarshalNTime2timeTime(ctx context.Context, v any) (time.Time, error) {
	res, err := graphql.UnmarshalTime(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNTime2timeTime(ctx context.Context, sel ast.SelectionSet, v time.Time) graphql.Marshaler {
	_ = sel
	res := graphql.MarshalTime(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNTime2timeTime(ctx context.Context, v any) ([]*time.Time, error) {
	var vSlice []any
	vSlice = graphql.CoerceList(v)
	var err error
	res := make([]*time.Time, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNTime2timeTime(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalNTime2timeTime(ctx context.Context, sel ast.SelectionSet, v []*time.Time) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalNTime2timeTime(ctx, sel, v[i])
	}

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalNTime2timeTime(ctx context.Context, v any) (*time.Time, error) {
	res, err := graphql.UnmarshalTime(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNTime2timeTime(ctx context.Context, sel ast.SelectionSet, v *time.Time) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	_ = sel
	res := graphql.MarshalTime(*v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) marshalNZPAConflict2githubcomobcodeplexamsgographmodelZPAConflict(ctx context.Context, sel ast.SelectionSet, v []*model.ZPAConflict) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNZPAConflict2githubcomobcodeplexamsgographmodelZPAConflict(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNZPAConflict2githubcomobcodeplexamsgographmodelZPAConflict(ctx context.Context, sel ast.SelectionSet, v *model.ZPAConflict) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._ZPAConflict(ctx, sel, v)
}

func (ec *executionContext) marshalNZPAExam2githubcomobcodeplexamsgographmodelZPAExam(ctx context.Context, sel ast.SelectionSet, v []*model.ZPAExam) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNZPAExam2githubcomobcodeplexamsgographmodelZPAExam(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNZPAExam2githubcomobcodeplexamsgographmodelZPAExam(ctx context.Context, sel ast.SelectionSet, v *model.ZPAExam) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._ZPAExam(ctx, sel, v)
}

func (ec *executionContext) marshalNZPAExamWithConstraints2githubcomobcodeplexamsgographmodelZPAExamWithConstraints(ctx context.Context, sel ast.SelectionSet, v []*model.ZPAExamWithConstraints) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNZPAExamWithConstraints2githubcomobcodeplexamsgographmodelZPAExamWithConstraints(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNZPAExamWithConstraints2githubcomobcodeplexamsgographmodelZPAExamWithConstraints(ctx context.Context, sel ast.SelectionSet, v *model.ZPAExamWithConstraints) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._ZPAExamWithConstraints(ctx, sel, v)
}

func (ec *executionContext) marshalNZPAExamsForType2githubcomobcodeplexamsgographmodelZPAExamsForType(ctx context.Context, sel ast.SelectionSet, v []*model.ZPAExamsForType) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNZPAExamsForType2githubcomobcodeplexamsgographmodelZPAExamsForType(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNZPAExamsForType2githubcomobcodeplexamsgographmodelZPAExamsForType(ctx context.Context, sel ast.SelectionSet, v *model.ZPAExamsForType) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._ZPAExamsForType(ctx, sel, v)
}

func (ec *executionContext) marshalNZPAInvigilator2githubcomobcodeplexamsgographmodelZPAInvigilator(ctx context.Context, sel ast.SelectionSet, v []*model.ZPAInvigilator) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNZPAInvigilator2githubcomobcodeplexamsgographmodelZPAInvigilator(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNZPAInvigilator2githubcomobcodeplexamsgographmodelZPAInvigilator(ctx context.Context, sel ast.SelectionSet, v *model.ZPAInvigilator) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._ZPAInvigilator(ctx, sel, v)
}

func (ec *executionContext) marshalNZPAPrimussAncodes2githubcomobcodeplexamsgographmodelZPAPrimussAncodes(ctx context.Context, sel ast.SelectionSet, v model.ZPAPrimussAncodes) graphql.Marshaler {
	return ec._ZPAPrimussAncodes(ctx, sel, &v)
}

func (ec *executionContext) marshalNZPAPrimussAncodes2githubcomobcodeplexamsgographmodelZPAPrimussAncodes(ctx context.Context, sel ast.SelectionSet, v []model.ZPAPrimussAncodes) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNZPAPrimussAncodes2githubcomobcodeplexamsgographmodelZPAPrimussAncodes(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNZPAStudentReg2githubcomobcodeplexamsgographmodelZPAStudentReg(ctx context.Context, sel ast.SelectionSet, v *model.ZPAStudentReg) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._ZPAStudentReg(ctx, sel, v)
}

func (ec *executionContext) marshalNZPAStudentRegError2githubcomobcodeplexamsgographmodelZPAStudentRegError(ctx context.Context, sel ast.SelectionSet, v *model.ZPAStudentRegError) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._ZPAStudentRegError(ctx, sel, v)
}

func (ec *executionContext) marshalN__Directive2githubcom99designsgqlgengraphqlintrospectionDirective(ctx context.Context, sel ast.SelectionSet, v introspection.Directive) graphql.Marshaler {
	return ec.___Directive(ctx, sel, &v)
}

func (ec *executionContext) marshalN__Directive2githubcom99designsgqlgengraphqlintrospectionDirective(ctx context.Context, sel ast.SelectionSet, v []introspection.Directive) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Directive2githubcom99designsgqlgengraphqlintrospectionDirective(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalN__DirectiveLocation2string(ctx context.Context, v any) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalN__DirectiveLocation2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	_ = sel
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalN__DirectiveLocation2string(ctx context.Context, v any) ([]string, error) {
	var vSlice []any
	vSlice = graphql.CoerceList(v)
	var err error
	res := make([]string, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalN__DirectiveLocation2string(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalN__DirectiveLocation2string(ctx context.Context, sel ast.SelectionSet, v []string) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__DirectiveLocation2string(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalN__EnumValue2githubcom99designsgqlgengraphqlintrospectionEnumValue(ctx context.Context, sel ast.SelectionSet, v introspection.EnumValue) graphql.Marshaler {
	return ec.___EnumValue(ctx, sel, &v)
}

func (ec *executionContext) marshalN__Field2githubcom99designsgqlgengraphqlintrospectionField(ctx context.Context, sel ast.SelectionSet, v introspection.Field) graphql.Marshaler {
	return ec.___Field(ctx, sel, &v)
}

func (ec *executionContext) marshalN__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx context.Context, sel ast.SelectionSet, v introspection.InputValue) graphql.Marshaler {
	return ec.___InputValue(ctx, sel, &v)
}

func (ec *executionContext) marshalN__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx context.Context, sel ast.SelectionSet, v []introspection.InputValue) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx context.Context, sel ast.SelectionSet, v introspection.Type) graphql.Marshaler {
	return ec.___Type(ctx, sel, &v)
}

func (ec *executionContext) marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx context.Context, sel ast.SelectionSet, v []introspection.Type) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx context.Context, sel ast.SelectionSet, v *introspection.Type) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec.___Type(ctx, sel, v)
}

func (ec *executionContext) unmarshalN__TypeKind2string(ctx context.Context, v any) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalN__TypeKind2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	_ = sel
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) marshalOAnCode2githubcomobcodeplexamsgographmodelAnCode(ctx context.Context, sel ast.SelectionSet, v []*model.AnCode) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOAnCode2githubcomobcodeplexamsgographmodelAnCode(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) marshalOAnCode2githubcomobcodeplexamsgographmodelAnCode(ctx context.Context, sel ast.SelectionSet, v *model.AnCode) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._AnCode(ctx, sel, v)
}

func (ec *executionContext) unmarshalOBoolean2bool(ctx context.Context, v any) (bool, error) {
	res, err := graphql.UnmarshalBoolean(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOBoolean2bool(ctx context.Context, sel ast.SelectionSet, v bool) graphql.Marshaler {
	_ = sel
	_ = ctx
	res := graphql.MarshalBoolean(v)
	return res
}

func (ec *executionContext) unmarshalOBoolean2bool(ctx context.Context, v any) (*bool, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalBoolean(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOBoolean2bool(ctx context.Context, sel ast.SelectionSet, v *bool) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	_ = sel
	_ = ctx
	res := graphql.MarshalBoolean(*v)
	return res
}

func (ec *executionContext) marshalOConflict2githubcomobcodeplexamsgographmodelConflict(ctx context.Context, sel ast.SelectionSet, v []*model.Conflict) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNConflict2githubcomobcodeplexamsgographmodelConflict(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalOConflicts2githubcomobcodeplexamsgographmodelConflicts(ctx context.Context, sel ast.SelectionSet, v *model.Conflicts) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Conflicts(ctx, sel, v)
}

func (ec *executionContext) marshalOConnectedExam2githubcomobcodeplexamsgographmodelConnectedExam(ctx context.Context, sel ast.SelectionSet, v *model.ConnectedExam) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._ConnectedExam(ctx, sel, v)
}

func (ec *executionContext) marshalOConstraints2githubcomobcodeplexamsgographmodelConstraints(ctx context.Context, sel ast.SelectionSet, v *model.Constraints) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Constraints(ctx, sel, v)
}

func (ec *executionContext) marshalOExamerInPlan2githubcomobcodeplexamsgographmodelExamerInPlan(ctx context.Context, sel ast.SelectionSet, v []*model.ExamerInPlan) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNExamerInPlan2githubcomobcodeplexamsgographmodelExamerInPlan(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalOGeneratedExam2githubcomobcodeplexamsgographmodelGeneratedExam(ctx context.Context, sel ast.SelectionSet, v *model.GeneratedExam) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._GeneratedExam(ctx, sel, v)
}

func (ec *executionContext) unmarshalOInt2int(ctx context.Context, v any) ([]int, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []any
	vSlice = graphql.CoerceList(v)
	var err error
	res := make([]int, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNInt2int(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOInt2int(ctx context.Context, sel ast.SelectionSet, v []int) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalNInt2int(ctx, sel, v[i])
	}

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOInt2int(ctx context.Context, v any) ([][]int, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []any
	vSlice = graphql.CoerceList(v)
	var err error
	res := make([][]int, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNInt2int(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOInt2int(ctx context.Context, sel ast.SelectionSet, v [][]int) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalNInt2int(ctx, sel, v[i])
	}

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOInt2int(ctx context.Context, v any) (*int, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalInt(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOInt2int(ctx context.Context, sel ast.SelectionSet, v *int) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	_ = sel
	_ = ctx
	res := graphql.MarshalInt(*v)
	return res
}

func (ec *executionContext) marshalOInvigilation2githubcomobcodeplexamsgographmodelInvigilation(ctx context.Context, sel ast.SelectionSet, v []*model.Invigilation) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNInvigilation2githubcomobcodeplexamsgographmodelInvigilation(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalOInvigilationSlot2githubcomobcodeplexamsgographmodelInvigilationSlot(ctx context.Context, sel ast.SelectionSet, v *model.InvigilationSlot) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._InvigilationSlot(ctx, sel, v)
}

func (ec *executionContext) marshalOInvigilationTodos2githubcomobcodeplexamsgographmodelInvigilationTodos(ctx context.Context, sel ast.SelectionSet, v *model.InvigilationTodos) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._InvigilationTodos(ctx, sel, v)
}

func (ec *executionContext) marshalOInvigilatorRequirements2githubcomobcodeplexamsgographmodelInvigilatorRequirements(ctx context.Context, sel ast.SelectionSet, v *model.InvigilatorRequirements) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._InvigilatorRequirements(ctx, sel, v)
}

func (ec *executionContext) marshalOInvigilatorTodos2githubcomobcodeplexamsgographmodelInvigilatorTodos(ctx context.Context, sel ast.SelectionSet, v *model.InvigilatorTodos) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._InvigilatorTodos(ctx, sel, v)
}

func (ec *executionContext) marshalOInvigilatorsForDay2githubcomobcodeplexamsgographmodelInvigilatorsForDay(ctx context.Context, sel ast.SelectionSet, v *model.InvigilatorsForDay) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._InvigilatorsForDay(ctx, sel, v)
}

func (ec *executionContext) marshalONTA2githubcomobcodeplexamsgographmodelNTA(ctx context.Context, sel ast.SelectionSet, v []*model.NTA) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNNTA2githubcomobcodeplexamsgographmodelNTA(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalONTA2githubcomobcodeplexamsgographmodelNTA(ctx context.Context, sel ast.SelectionSet, v *model.NTA) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._NTA(ctx, sel, v)
}

func (ec *executionContext) marshalONTAWithRegs2githubcomobcodeplexamsgographmodelNTAWithRegs(ctx context.Context, sel ast.SelectionSet, v []*model.NTAWithRegs) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNNTAWithRegs2githubcomobcodeplexamsgographmodelNTAWithRegs(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalONTAWithRegs2githubcomobcodeplexamsgographmodelNTAWithRegs(ctx context.Context, sel ast.SelectionSet, v *model.NTAWithRegs) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._NTAWithRegs(ctx, sel, v)
}

func (ec *executionContext) marshalONTAWithRegsByExam2githubcomobcodeplexamsgographmodelNTAWithRegsByExam(ctx context.Context, sel ast.SelectionSet, v []*model.NTAWithRegsByExam) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNNTAWithRegsByExam2githubcomobcodeplexamsgographmodelNTAWithRegsByExam(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalOPlanEntry2githubcomobcodeplexamsgographmodelPlanEntry(ctx context.Context, sel ast.SelectionSet, v *model.PlanEntry) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._PlanEntry(ctx, sel, v)
}

func (ec *executionContext) marshalOPlannedExam2githubcomobcodeplexamsgographmodelPlannedExam(ctx context.Context, sel ast.SelectionSet, v []*model.PlannedExam) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNPlannedExam2githubcomobcodeplexamsgographmodelPlannedExam(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalOPlannedExam2githubcomobcodeplexamsgographmodelPlannedExam(ctx context.Context, sel ast.SelectionSet, v *model.PlannedExam) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._PlannedExam(ctx, sel, v)
}

func (ec *executionContext) marshalOPlannedRoom2githubcomobcodeplexamsgographmodelPlannedRoom(ctx context.Context, sel ast.SelectionSet, v []*model.PlannedRoom) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNPlannedRoom2githubcomobcodeplexamsgographmodelPlannedRoom(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalOPlannedRoom2githubcomobcodeplexamsgographmodelPlannedRoom(ctx context.Context, sel ast.SelectionSet, v *model.PlannedRoom) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._PlannedRoom(ctx, sel, v)
}

func (ec *executionContext) marshalOPreExam2githubcomobcodeplexamsgographmodelPreExam(ctx context.Context, sel ast.SelectionSet, v []*model.PreExam) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNPreExam2githubcomobcodeplexamsgographmodelPreExam(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalOPrimussExam2githubcomobcodeplexamsgographmodelPrimussExam(ctx context.Context, sel ast.SelectionSet, v []*model.PrimussExam) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNPrimussExam2githubcomobcodeplexamsgographmodelPrimussExam(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalOPrimussExamByProgram2githubcomobcodeplexamsgographmodelPrimussExamByProgram(ctx context.Context, sel ast.SelectionSet, v []*model.PrimussExamByProgram) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOPrimussExamByProgram2githubcomobcodeplexamsgographmodelPrimussExamByProgram(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) marshalOPrimussExamByProgram2githubcomobcodeplexamsgographmodelPrimussExamByProgram(ctx context.Context, sel ast.SelectionSet, v *model.PrimussExamByProgram) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._PrimussExamByProgram(ctx, sel, v)
}

func (ec *executionContext) marshalORoomConstraints2githubcomobcodeplexamsgographmodelRoomConstraints(ctx context.Context, sel ast.SelectionSet, v *model.RoomConstraints) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._RoomConstraints(ctx, sel, v)
}

func (ec *executionContext) marshalOSlot2githubcomobcodeplexamsgographmodelSlot(ctx context.Context, sel ast.SelectionSet, v []*model.Slot) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNSlot2githubcomobcodeplexamsgographmodelSlot(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOString2string(ctx context.Context, v any) ([]string, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []any
	vSlice = graphql.CoerceList(v)
	var err error
	res := make([]string, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNString2string(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOString2string(ctx context.Context, sel ast.SelectionSet, v []string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalNString2string(ctx, sel, v[i])
	}

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOString2string(ctx context.Context, v any) (*string, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalString(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOString2string(ctx context.Context, sel ast.SelectionSet, v *string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	_ = sel
	_ = ctx
	res := graphql.MarshalString(*v)
	return res
}

func (ec *executionContext) marshalOStudent2githubcomobcodeplexamsgographmodelStudent(ctx context.Context, sel ast.SelectionSet, v []*model.Student) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNStudent2githubcomobcodeplexamsgographmodelStudent(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalOStudent2githubcomobcodeplexamsgographmodelStudent(ctx context.Context, sel ast.SelectionSet, v *model.Student) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Student(ctx, sel, v)
}

func (ec *executionContext) marshalOStudentReg2githubcomobcodeplexamsgographmodelStudentReg(ctx context.Context, sel ast.SelectionSet, v []*model.StudentReg) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNStudentReg2githubcomobcodeplexamsgographmodelStudentReg(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalOStudentRegsPerStudent2githubcomobcodeplexamsgographmodelStudentRegsPerStudent(ctx context.Context, sel ast.SelectionSet, v *model.StudentRegsPerStudent) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._StudentRegsPerStudent(ctx, sel, v)
}

func (ec *executionContext) marshalOTeacher2githubcomobcodeplexamsgographmodelTeacher(ctx context.Context, sel ast.SelectionSet, v *model.Teacher) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Teacher(ctx, sel, v)
}

func (ec *executionContext) unmarshalOTime2timeTime(ctx context.Context, v any) ([]*time.Time, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []any
	vSlice = graphql.CoerceList(v)
	var err error
	res := make([]*time.Time, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNTime2timeTime(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOTime2timeTime(ctx context.Context, sel ast.SelectionSet, v []*time.Time) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalNTime2timeTime(ctx, sel, v[i])
	}

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOTime2timeTime(ctx context.Context, v any) (*time.Time, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalTime(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOTime2timeTime(ctx context.Context, sel ast.SelectionSet, v *time.Time) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	_ = sel
	_ = ctx
	res := graphql.MarshalTime(*v)
	return res
}

func (ec *executionContext) marshalOZPAExam2githubcomobcodeplexamsgographmodelZPAExam(ctx context.Context, sel ast.SelectionSet, v *model.ZPAExam) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._ZPAExam(ctx, sel, v)
}

func (ec *executionContext) marshalOZPAStudent2githubcomobcodeplexamsgographmodelZPAStudent(ctx context.Context, sel ast.SelectionSet, v *model.ZPAStudent) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._ZPAStudent(ctx, sel, v)
}

func (ec *executionContext) marshalO__EnumValue2githubcom99designsgqlgengraphqlintrospectionEnumValue(ctx context.Context, sel ast.SelectionSet, v []introspection.EnumValue) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__EnumValue2githubcom99designsgqlgengraphqlintrospectionEnumValue(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalO__Field2githubcom99designsgqlgengraphqlintrospectionField(ctx context.Context, sel ast.SelectionSet, v []introspection.Field) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Field2githubcom99designsgqlgengraphqlintrospectionField(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalO__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx context.Context, sel ast.SelectionSet, v []introspection.InputValue) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__InputValue2githubcom99designsgqlgengraphqlintrospectionInputValue(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalO__Schema2githubcom99designsgqlgengraphqlintrospectionSchema(ctx context.Context, sel ast.SelectionSet, v *introspection.Schema) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec.___Schema(ctx, sel, v)
}

func (ec *executionContext) marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx context.Context, sel ast.SelectionSet, v []introspection.Type) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalO__Type2githubcom99designsgqlgengraphqlintrospectionType(ctx context.Context, sel ast.SelectionSet, v *introspection.Type) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec.___Type(ctx, sel, v)
}

// endregion ***************************** type.gotpl *****************************
